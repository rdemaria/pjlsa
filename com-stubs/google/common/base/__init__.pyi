import com
import com.google.common.base.internal
import java.io
import java.lang
import java.lang.ref
import java.lang.reflect
import java.nio.charset
import java.time
import java.util
import java.util.concurrent
import java.util.function
import java.util.regex
import java.util.stream
import typing



class Ascii:
    """
    Java class 'com.google.common.base.Ascii'
    
        Extends:
            java.lang.Object
    
      Attributes:
        NUL (byte): final static field
        SOH (byte): final static field
        STX (byte): final static field
        ETX (byte): final static field
        EOT (byte): final static field
        ENQ (byte): final static field
        ACK (byte): final static field
        BEL (byte): final static field
        BS (byte): final static field
        HT (byte): final static field
        LF (byte): final static field
        NL (byte): final static field
        VT (byte): final static field
        FF (byte): final static field
        CR (byte): final static field
        SO (byte): final static field
        SI (byte): final static field
        DLE (byte): final static field
        DC1 (byte): final static field
        XON (byte): final static field
        DC2 (byte): final static field
        DC3 (byte): final static field
        XOFF (byte): final static field
        DC4 (byte): final static field
        NAK (byte): final static field
        SYN (byte): final static field
        ETB (byte): final static field
        CAN (byte): final static field
        EM (byte): final static field
        SUB (byte): final static field
        ESC (byte): final static field
        FS (byte): final static field
        GS (byte): final static field
        RS (byte): final static field
        US (byte): final static field
        SP (byte): final static field
        SPACE (byte): final static field
        DEL (byte): final static field
        MIN (char): final static field
        MAX (char): final static field
    
    """
    NUL: typing.ClassVar[int] = ...
    SOH: typing.ClassVar[int] = ...
    STX: typing.ClassVar[int] = ...
    ETX: typing.ClassVar[int] = ...
    EOT: typing.ClassVar[int] = ...
    ENQ: typing.ClassVar[int] = ...
    ACK: typing.ClassVar[int] = ...
    BEL: typing.ClassVar[int] = ...
    BS: typing.ClassVar[int] = ...
    HT: typing.ClassVar[int] = ...
    LF: typing.ClassVar[int] = ...
    NL: typing.ClassVar[int] = ...
    VT: typing.ClassVar[int] = ...
    FF: typing.ClassVar[int] = ...
    CR: typing.ClassVar[int] = ...
    SO: typing.ClassVar[int] = ...
    SI: typing.ClassVar[int] = ...
    DLE: typing.ClassVar[int] = ...
    DC1: typing.ClassVar[int] = ...
    XON: typing.ClassVar[int] = ...
    DC2: typing.ClassVar[int] = ...
    DC3: typing.ClassVar[int] = ...
    XOFF: typing.ClassVar[int] = ...
    DC4: typing.ClassVar[int] = ...
    NAK: typing.ClassVar[int] = ...
    SYN: typing.ClassVar[int] = ...
    ETB: typing.ClassVar[int] = ...
    CAN: typing.ClassVar[int] = ...
    EM: typing.ClassVar[int] = ...
    SUB: typing.ClassVar[int] = ...
    ESC: typing.ClassVar[int] = ...
    FS: typing.ClassVar[int] = ...
    GS: typing.ClassVar[int] = ...
    RS: typing.ClassVar[int] = ...
    US: typing.ClassVar[int] = ...
    SP: typing.ClassVar[int] = ...
    SPACE: typing.ClassVar[int] = ...
    DEL: typing.ClassVar[int] = ...
    MIN: typing.ClassVar[str] = ...
    MAX: typing.ClassVar[str] = ...
    @staticmethod
    def equalsIgnoreCase(charSequence: typing.Union[java.lang.CharSequence, str], charSequence2: typing.Union[java.lang.CharSequence, str]) -> bool: ...
    @staticmethod
    def isLowerCase(char: str) -> bool: ...
    @staticmethod
    def isUpperCase(char: str) -> bool: ...
    @typing.overload
    @staticmethod
    def toLowerCase(char: str) -> str: ...
    @typing.overload
    @staticmethod
    def toLowerCase(charSequence: typing.Union[java.lang.CharSequence, str]) -> str: ...
    @typing.overload
    @staticmethod
    def toLowerCase(string: str) -> str: ...
    @typing.overload
    @staticmethod
    def toUpperCase(char: str) -> str: ...
    @typing.overload
    @staticmethod
    def toUpperCase(charSequence: typing.Union[java.lang.CharSequence, str]) -> str: ...
    @typing.overload
    @staticmethod
    def toUpperCase(string: str) -> str: ...
    @staticmethod
    def truncate(charSequence: typing.Union[java.lang.CharSequence, str], int: int, string: str) -> str: ...

class CaseFormat(java.lang.Enum['CaseFormat']):
    """
    Java class 'com.google.common.base.CaseFormat'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        LOWER_HYPHEN (com.google.common.base.CaseFormat): final static enum constant
        LOWER_UNDERSCORE (com.google.common.base.CaseFormat): final static enum constant
        LOWER_CAMEL (com.google.common.base.CaseFormat): final static enum constant
        UPPER_CAMEL (com.google.common.base.CaseFormat): final static enum constant
        UPPER_UNDERSCORE (com.google.common.base.CaseFormat): final static enum constant
    
    """
    LOWER_HYPHEN: typing.ClassVar['CaseFormat'] = ...
    LOWER_UNDERSCORE: typing.ClassVar['CaseFormat'] = ...
    LOWER_CAMEL: typing.ClassVar['CaseFormat'] = ...
    UPPER_CAMEL: typing.ClassVar['CaseFormat'] = ...
    UPPER_UNDERSCORE: typing.ClassVar['CaseFormat'] = ...
    def converterTo(self, caseFormat: 'CaseFormat') -> 'Converter'[str, str]: ...
    def to(self, caseFormat: 'CaseFormat', string: str) -> str: ...
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'CaseFormat': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @staticmethod
    def values() -> typing.List['CaseFormat']: ...

class Charsets:
    """
    Java class 'com.google.common.base.Charsets'
    
        Extends:
            java.lang.Object
    
      Attributes:
        US_ASCII (java.nio.charset.Charset): final static field
        ISO_8859_1 (java.nio.charset.Charset): final static field
        UTF_8 (java.nio.charset.Charset): final static field
        UTF_16BE (java.nio.charset.Charset): final static field
        UTF_16LE (java.nio.charset.Charset): final static field
        UTF_16 (java.nio.charset.Charset): final static field
    
    """
    US_ASCII: typing.ClassVar[java.nio.charset.Charset] = ...
    ISO_8859_1: typing.ClassVar[java.nio.charset.Charset] = ...
    UTF_8: typing.ClassVar[java.nio.charset.Charset] = ...
    UTF_16BE: typing.ClassVar[java.nio.charset.Charset] = ...
    UTF_16LE: typing.ClassVar[java.nio.charset.Charset] = ...
    UTF_16: typing.ClassVar[java.nio.charset.Charset] = ...

class Defaults:
    """
    Java class 'com.google.common.base.Defaults'
    
        Extends:
            java.lang.Object
    
    """
    _defaultValue__T = typing.TypeVar('_defaultValue__T')  # <T>
    @staticmethod
    def defaultValue(class_: typing.Type[_defaultValue__T]) -> _defaultValue__T: ...

class Enums:
    """
    Java class 'com.google.common.base.Enums'
    
        Extends:
            java.lang.Object
    
    """
    @staticmethod
    def getField(enum: java.lang.Enum[typing.Any]) -> java.lang.reflect.Field: ...
    _getIfPresent__T = typing.TypeVar('_getIfPresent__T', bound=java.lang.Enum)  # <T>
    @staticmethod
    def getIfPresent(class_: typing.Type[_getIfPresent__T], string: str) -> 'Optional'[_getIfPresent__T]: ...
    _stringConverter__T = typing.TypeVar('_stringConverter__T', bound=java.lang.Enum)  # <T>
    @staticmethod
    def stringConverter(class_: typing.Type[_stringConverter__T]) -> 'Converter'[str, _stringConverter__T]: ...

_Equivalence__Wrapper__T = typing.TypeVar('_Equivalence__Wrapper__T')  # <T>
_Equivalence__T = typing.TypeVar('_Equivalence__T')  # <T>
class Equivalence(java.util.function.BiPredicate[_Equivalence__T, _Equivalence__T], typing.Generic[_Equivalence__T]):
    """
    Java class 'com.google.common.base.Equivalence'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.function.BiPredicate
    
    """
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def equals() -> 'Equivalence'[typing.Any]: ...
    def equivalent(self, t: _Equivalence__T, t2: _Equivalence__T) -> bool: ...
    def equivalentTo(self, t: _Equivalence__T) -> 'Predicate'[_Equivalence__T]: ...
    def hash(self, t: _Equivalence__T) -> int: ...
    @staticmethod
    def identity() -> 'Equivalence'[typing.Any]: ...
    _onResultOf__F = typing.TypeVar('_onResultOf__F')  # <F>
    def onResultOf(self, function: typing.Union['Function'[_onResultOf__F, _Equivalence__T], typing.Callable[[_onResultOf__F], _Equivalence__T]]) -> 'Equivalence'[_onResultOf__F]: ...
    _pairwise__S = typing.TypeVar('_pairwise__S')  # <S>
    def pairwise(self) -> 'Equivalence'[java.lang.Iterable[_pairwise__S]]: ...
    def test(self, t: _Equivalence__T, t2: _Equivalence__T) -> bool: ...
    _wrap__S = typing.TypeVar('_wrap__S')  # <S>
    def wrap(self, s2: _wrap__S) -> 'Equivalence.Wrapper'[_wrap__S]: ...
    class Wrapper(java.io.Serializable, typing.Generic[_Equivalence__Wrapper__T]):
        """
        Java class 'com.google.common.base.Equivalence$Wrapper'
        
            Extends:
                java.lang.Object
        
            Interfaces:
                java.io.Serializable
        
        """
        def equals(self, object: typing.Any) -> bool: ...
        def get(self) -> _Equivalence__Wrapper__T: ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...

class FinalizableReference:
    """
    Java class 'com.google.common.base.FinalizableReference'
    
    """
    def finalizeReferent(self) -> None: ...

class FinalizableReferenceQueue(java.io.Closeable):
    """
    Java class 'com.google.common.base.FinalizableReferenceQueue'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Closeable
    
      Constructors:
        * FinalizableReferenceQueue()
    
    """
    def __init__(self): ...
    def close(self) -> None: ...

_Function__F = typing.TypeVar('_Function__F')  # <F>
_Function__T = typing.TypeVar('_Function__T')  # <T>
class Function(java.util.function.Function[_Function__F, _Function__T], typing.Generic[_Function__F, _Function__T]):
    """
    Java class 'com.google.common.base.Function'
    
        Interfaces:
            java.util.function.Function
    
    """
    def apply(self, f: _Function__F) -> _Function__T: ...
    def equals(self, object: typing.Any) -> bool: ...

class Functions:
    """
    Java class 'com.google.common.base.Functions'
    
        Extends:
            java.lang.Object
    
    """
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    _compose__B = typing.TypeVar('_compose__B')  # <B>
    _compose__C = typing.TypeVar('_compose__C')  # <C>
    @staticmethod
    def compose(function: typing.Union[Function[_compose__B, _compose__C], typing.Callable[[_compose__B], _compose__C]], function2: typing.Union[Function[_compose__A, _compose__B], typing.Callable[[_compose__A], _compose__B]]) -> Function[_compose__A, _compose__C]: ...
    _constant__E = typing.TypeVar('_constant__E')  # <E>
    @staticmethod
    def constant(e: _constant__E) -> Function[typing.Any, _constant__E]: ...
    _forMap_0__K = typing.TypeVar('_forMap_0__K')  # <K>
    _forMap_0__V = typing.TypeVar('_forMap_0__V')  # <V>
    _forMap_1__K = typing.TypeVar('_forMap_1__K')  # <K>
    _forMap_1__V = typing.TypeVar('_forMap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def forMap(map: typing.Union[java.util.Map[_forMap_0__K, _forMap_0__V], typing.Mapping[_forMap_0__K, _forMap_0__V]]) -> Function[_forMap_0__K, _forMap_0__V]: ...
    @typing.overload
    @staticmethod
    def forMap(map: typing.Union[java.util.Map[_forMap_1__K, _forMap_1__V], typing.Mapping[_forMap_1__K, _forMap_1__V]], v: _forMap_1__V) -> Function[_forMap_1__K, _forMap_1__V]: ...
    _forPredicate__T = typing.TypeVar('_forPredicate__T')  # <T>
    @staticmethod
    def forPredicate(predicate: typing.Union['Predicate'[_forPredicate__T], typing.Callable[[_forPredicate__T], bool]]) -> Function[_forPredicate__T, bool]: ...
    _forSupplier__T = typing.TypeVar('_forSupplier__T')  # <T>
    @staticmethod
    def forSupplier(supplier: typing.Union['Supplier'[_forSupplier__T], typing.Callable[[], _forSupplier__T]]) -> Function[typing.Any, _forSupplier__T]: ...
    _identity__E = typing.TypeVar('_identity__E')  # <E>
    @staticmethod
    def identity() -> Function[_identity__E, _identity__E]: ...
    @staticmethod
    def toStringFunction() -> Function[typing.Any, str]: ...

class Joiner:
    """
    Java class 'com.google.common.base.Joiner'
    
        Extends:
            java.lang.Object
    
    """
    _appendTo_0__A = typing.TypeVar('_appendTo_0__A', bound=java.lang.Appendable)  # <A>
    _appendTo_1__A = typing.TypeVar('_appendTo_1__A', bound=java.lang.Appendable)  # <A>
    _appendTo_6__A = typing.TypeVar('_appendTo_6__A', bound=java.lang.Appendable)  # <A>
    _appendTo_7__A = typing.TypeVar('_appendTo_7__A', bound=java.lang.Appendable)  # <A>
    @typing.overload
    def appendTo(self, a: _appendTo_0__A, object: typing.Any, object2: typing.Any, objectArray: typing.List[typing.Any]) -> _appendTo_0__A: ...
    @typing.overload
    def appendTo(self, a: _appendTo_1__A, objectArray: typing.List[typing.Any]) -> _appendTo_1__A: ...
    @typing.overload
    def appendTo(self, stringBuilder: java.lang.StringBuilder, iterable: java.lang.Iterable[typing.Any]) -> java.lang.StringBuilder: ...
    @typing.overload
    def appendTo(self, stringBuilder: java.lang.StringBuilder, object: typing.Any, object2: typing.Any, objectArray: typing.List[typing.Any]) -> java.lang.StringBuilder: ...
    @typing.overload
    def appendTo(self, stringBuilder: java.lang.StringBuilder, objectArray: typing.List[typing.Any]) -> java.lang.StringBuilder: ...
    @typing.overload
    def appendTo(self, stringBuilder: java.lang.StringBuilder, iterator: java.util.Iterator[typing.Any]) -> java.lang.StringBuilder: ...
    @typing.overload
    def appendTo(self, a: _appendTo_6__A, iterable: java.lang.Iterable[typing.Any]) -> _appendTo_6__A: ...
    @typing.overload
    def appendTo(self, a: _appendTo_7__A, iterator: java.util.Iterator[typing.Any]) -> _appendTo_7__A: ...
    @typing.overload
    def join(self, iterable: java.lang.Iterable[typing.Any]) -> str: ...
    @typing.overload
    def join(self, object: typing.Any, object2: typing.Any, objectArray: typing.List[typing.Any]) -> str: ...
    @typing.overload
    def join(self, objectArray: typing.List[typing.Any]) -> str: ...
    @typing.overload
    def join(self, iterator: java.util.Iterator[typing.Any]) -> str: ...
    @typing.overload
    @staticmethod
    def on(char: str) -> 'Joiner': ...
    @typing.overload
    @staticmethod
    def on(string: str) -> 'Joiner': ...
    def skipNulls(self) -> 'Joiner': ...
    def useForNull(self, string: str) -> 'Joiner': ...
    @typing.overload
    def withKeyValueSeparator(self, char: str) -> 'Joiner.MapJoiner': ...
    @typing.overload
    def withKeyValueSeparator(self, string: str) -> 'Joiner.MapJoiner': ...
    class MapJoiner:
        """
        Java class 'com.google.common.base.Joiner$MapJoiner'
        
            Extends:
                java.lang.Object
        
        """
        _appendTo_0__A = typing.TypeVar('_appendTo_0__A', bound=java.lang.Appendable)  # <A>
        _appendTo_1__A = typing.TypeVar('_appendTo_1__A', bound=java.lang.Appendable)  # <A>
        _appendTo_2__A = typing.TypeVar('_appendTo_2__A', bound=java.lang.Appendable)  # <A>
        @typing.overload
        def appendTo(self, a: _appendTo_0__A, iterable: java.lang.Iterable[java.util.Map.Entry[typing.Any, typing.Any]]) -> _appendTo_0__A: ...
        @typing.overload
        def appendTo(self, a: _appendTo_1__A, iterator: java.util.Iterator[java.util.Map.Entry[typing.Any, typing.Any]]) -> _appendTo_1__A: ...
        @typing.overload
        def appendTo(self, a: _appendTo_2__A, map: typing.Union[java.util.Map[typing.Any, typing.Any], typing.Mapping[typing.Any, typing.Any]]) -> _appendTo_2__A: ...
        @typing.overload
        def appendTo(self, stringBuilder: java.lang.StringBuilder, iterable: java.lang.Iterable[java.util.Map.Entry[typing.Any, typing.Any]]) -> java.lang.StringBuilder: ...
        @typing.overload
        def appendTo(self, stringBuilder: java.lang.StringBuilder, iterator: java.util.Iterator[java.util.Map.Entry[typing.Any, typing.Any]]) -> java.lang.StringBuilder: ...
        @typing.overload
        def appendTo(self, stringBuilder: java.lang.StringBuilder, map: typing.Union[java.util.Map[typing.Any, typing.Any], typing.Mapping[typing.Any, typing.Any]]) -> java.lang.StringBuilder: ...
        @typing.overload
        def join(self, iterable: java.lang.Iterable[java.util.Map.Entry[typing.Any, typing.Any]]) -> str: ...
        @typing.overload
        def join(self, iterator: java.util.Iterator[java.util.Map.Entry[typing.Any, typing.Any]]) -> str: ...
        @typing.overload
        def join(self, map: typing.Union[java.util.Map[typing.Any, typing.Any], typing.Mapping[typing.Any, typing.Any]]) -> str: ...
        def useForNull(self, string: str) -> 'Joiner.MapJoiner': ...

class MoreObjects:
    """
    Java class 'com.google.common.base.MoreObjects'
    
        Extends:
            java.lang.Object
    
    """
    _firstNonNull__T = typing.TypeVar('_firstNonNull__T')  # <T>
    @staticmethod
    def firstNonNull(t: _firstNonNull__T, t2: _firstNonNull__T) -> _firstNonNull__T: ...
    @typing.overload
    @staticmethod
    def toStringHelper(class_: typing.Type[typing.Any]) -> 'MoreObjects.ToStringHelper': ...
    @typing.overload
    @staticmethod
    def toStringHelper(object: typing.Any) -> 'MoreObjects.ToStringHelper': ...
    @typing.overload
    @staticmethod
    def toStringHelper(string: str) -> 'MoreObjects.ToStringHelper': ...
    class ToStringHelper:
        """
        Java class 'com.google.common.base.MoreObjects$ToStringHelper'
        
            Extends:
                java.lang.Object
        
        """
        @typing.overload
        def add(self, string: str, boolean: bool) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def add(self, string: str, char: str) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def add(self, string: str, double: float) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def add(self, string: str, float: float) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def add(self, string: str, int: int) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def add(self, string: str, object: typing.Any) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def add(self, string: str, long: int) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def addValue(self, boolean: bool) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def addValue(self, char: str) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def addValue(self, double: float) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def addValue(self, float: float) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def addValue(self, int: int) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def addValue(self, object: typing.Any) -> 'MoreObjects.ToStringHelper': ...
        @typing.overload
        def addValue(self, long: int) -> 'MoreObjects.ToStringHelper': ...
        def omitNullValues(self) -> 'MoreObjects.ToStringHelper': ...
        def toString(self) -> str: ...

_Optional__T = typing.TypeVar('_Optional__T')  # <T>
class Optional(java.io.Serializable, typing.Generic[_Optional__T]):
    """
    Java class 'com.google.common.base.Optional'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
    """
    _absent__T = typing.TypeVar('_absent__T')  # <T>
    @staticmethod
    def absent() -> 'Optional'[_absent__T]: ...
    def asSet(self) -> java.util.Set[_Optional__T]: ...
    def equals(self, object: typing.Any) -> bool: ...
    _fromJavaUtil__T = typing.TypeVar('_fromJavaUtil__T')  # <T>
    @staticmethod
    def fromJavaUtil(optional: java.util.Optional[_fromJavaUtil__T]) -> 'Optional'[_fromJavaUtil__T]: ...
    _fromNullable__T = typing.TypeVar('_fromNullable__T')  # <T>
    @staticmethod
    def fromNullable(t: _fromNullable__T) -> 'Optional'[_fromNullable__T]: ...
    def get(self) -> _Optional__T: ...
    def hashCode(self) -> int: ...
    def isPresent(self) -> bool: ...
    _of__T = typing.TypeVar('_of__T')  # <T>
    @staticmethod
    def of(t: _of__T) -> 'Optional'[_of__T]: ...
    def orNull(self) -> _Optional__T: ...
    _presentInstances__T = typing.TypeVar('_presentInstances__T')  # <T>
    @staticmethod
    def presentInstances(iterable: java.lang.Iterable['Optional'[_presentInstances__T]]) -> java.lang.Iterable[_presentInstances__T]: ...
    _toJavaUtil_1__T = typing.TypeVar('_toJavaUtil_1__T')  # <T>
    @typing.overload
    def toJavaUtil(self) -> java.util.Optional[_Optional__T]: ...
    @typing.overload
    @staticmethod
    def toJavaUtil(optional: 'Optional'[_toJavaUtil_1__T]) -> java.util.Optional[_toJavaUtil_1__T]: ...
    def toString(self) -> str: ...
    _transform__V = typing.TypeVar('_transform__V')  # <V>
    def transform(self, function: typing.Union[Function[_Optional__T, _transform__V], typing.Callable[[_Optional__T], _transform__V]]) -> 'Optional'[_transform__V]: ...

class Preconditions:
    """
    Java class 'com.google.common.base.Preconditions'
    
        Extends:
            java.lang.Object
    
    """
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, char: str, char2: str) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, char: str, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, char: str, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, char: str, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, int: int, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, int: int, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, int: int, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, object: typing.Any, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, object: typing.Any, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, object: typing.Any, object2: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, object: typing.Any, object2: typing.Any, object3: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, object: typing.Any, object2: typing.Any, object3: typing.Any, object4: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, object: typing.Any, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, objectArray: typing.List[typing.Any]) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, long: int, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, long: int, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, long: int, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkArgument(boolean: bool, string: str, long: int, long2: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkElementIndex(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def checkElementIndex(int: int, int2: int, string: str) -> int: ...
    _checkNotNull_0__T = typing.TypeVar('_checkNotNull_0__T')  # <T>
    _checkNotNull_1__T = typing.TypeVar('_checkNotNull_1__T')  # <T>
    _checkNotNull_2__T = typing.TypeVar('_checkNotNull_2__T')  # <T>
    _checkNotNull_3__T = typing.TypeVar('_checkNotNull_3__T')  # <T>
    _checkNotNull_4__T = typing.TypeVar('_checkNotNull_4__T')  # <T>
    _checkNotNull_5__T = typing.TypeVar('_checkNotNull_5__T')  # <T>
    _checkNotNull_6__T = typing.TypeVar('_checkNotNull_6__T')  # <T>
    _checkNotNull_7__T = typing.TypeVar('_checkNotNull_7__T')  # <T>
    _checkNotNull_8__T = typing.TypeVar('_checkNotNull_8__T')  # <T>
    _checkNotNull_9__T = typing.TypeVar('_checkNotNull_9__T')  # <T>
    _checkNotNull_10__T = typing.TypeVar('_checkNotNull_10__T')  # <T>
    _checkNotNull_11__T = typing.TypeVar('_checkNotNull_11__T')  # <T>
    _checkNotNull_12__T = typing.TypeVar('_checkNotNull_12__T')  # <T>
    _checkNotNull_13__T = typing.TypeVar('_checkNotNull_13__T')  # <T>
    _checkNotNull_14__T = typing.TypeVar('_checkNotNull_14__T')  # <T>
    _checkNotNull_15__T = typing.TypeVar('_checkNotNull_15__T')  # <T>
    _checkNotNull_16__T = typing.TypeVar('_checkNotNull_16__T')  # <T>
    _checkNotNull_17__T = typing.TypeVar('_checkNotNull_17__T')  # <T>
    _checkNotNull_18__T = typing.TypeVar('_checkNotNull_18__T')  # <T>
    _checkNotNull_19__T = typing.TypeVar('_checkNotNull_19__T')  # <T>
    _checkNotNull_20__T = typing.TypeVar('_checkNotNull_20__T')  # <T>
    _checkNotNull_21__T = typing.TypeVar('_checkNotNull_21__T')  # <T>
    _checkNotNull_22__T = typing.TypeVar('_checkNotNull_22__T')  # <T>
    _checkNotNull_23__T = typing.TypeVar('_checkNotNull_23__T')  # <T>
    _checkNotNull_24__T = typing.TypeVar('_checkNotNull_24__T')  # <T>
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_0__T) -> _checkNotNull_0__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_1__T, object: typing.Any) -> _checkNotNull_1__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_2__T, string: str, char: str) -> _checkNotNull_2__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_3__T, string: str, char: str, char2: str) -> _checkNotNull_3__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_4__T, string: str, char: str, int: int) -> _checkNotNull_4__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_5__T, string: str, char: str, object: typing.Any) -> _checkNotNull_5__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_6__T, string: str, char: str, long: int) -> _checkNotNull_6__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_7__T, string: str, int: int) -> _checkNotNull_7__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_8__T, string: str, int: int, char: str) -> _checkNotNull_8__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_9__T, string: str, int: int, int2: int) -> _checkNotNull_9__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_10__T, string: str, int: int, object: typing.Any) -> _checkNotNull_10__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_11__T, string: str, int: int, long: int) -> _checkNotNull_11__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_12__T, string: str, object: typing.Any) -> _checkNotNull_12__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_13__T, string: str, object: typing.Any, char: str) -> _checkNotNull_13__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_14__T, string: str, object: typing.Any, int: int) -> _checkNotNull_14__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_15__T, string: str, object: typing.Any, object2: typing.Any) -> _checkNotNull_15__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_16__T, string: str, object: typing.Any, object2: typing.Any, object3: typing.Any) -> _checkNotNull_16__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_17__T, string: str, object: typing.Any, object2: typing.Any, object3: typing.Any, object4: typing.Any) -> _checkNotNull_17__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_18__T, string: str, object: typing.Any, long: int) -> _checkNotNull_18__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_19__T, string: str, objectArray: typing.List[typing.Any]) -> _checkNotNull_19__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_20__T, string: str, long: int) -> _checkNotNull_20__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_21__T, string: str, long: int, char: str) -> _checkNotNull_21__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_22__T, string: str, long: int, int: int) -> _checkNotNull_22__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_23__T, string: str, long: int, object: typing.Any) -> _checkNotNull_23__T: ...
    @typing.overload
    @staticmethod
    def checkNotNull(t: _checkNotNull_24__T, string: str, long: int, long2: int) -> _checkNotNull_24__T: ...
    @typing.overload
    @staticmethod
    def checkPositionIndex(int: int, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def checkPositionIndex(int: int, int2: int, string: str) -> int: ...
    @staticmethod
    def checkPositionIndexes(int: int, int2: int, int3: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, char: str, char2: str) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, char: str, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, char: str, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, char: str, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, int: int, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, int: int, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, int: int, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, object: typing.Any, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, object: typing.Any, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, object: typing.Any, object2: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, object: typing.Any, object2: typing.Any, object3: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, object: typing.Any, object2: typing.Any, object3: typing.Any, object4: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, object: typing.Any, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, objectArray: typing.List[typing.Any]) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, long: int, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, long: int, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, long: int, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def checkState(boolean: bool, string: str, long: int, long2: int) -> None: ...

_Predicate__T = typing.TypeVar('_Predicate__T')  # <T>
class Predicate(java.util.function.Predicate[_Predicate__T], typing.Generic[_Predicate__T]):
    """
    Java class 'com.google.common.base.Predicate'
    
        Interfaces:
            java.util.function.Predicate
    
    """
    def apply(self, t: _Predicate__T) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def test(self, t: _Predicate__T) -> bool: ...

class Predicates:
    """
    Java class 'com.google.common.base.Predicates'
    
        Extends:
            java.lang.Object
    
    """
    _alwaysFalse__T = typing.TypeVar('_alwaysFalse__T')  # <T>
    @staticmethod
    def alwaysFalse() -> Predicate[_alwaysFalse__T]: ...
    _alwaysTrue__T = typing.TypeVar('_alwaysTrue__T')  # <T>
    @staticmethod
    def alwaysTrue() -> Predicate[_alwaysTrue__T]: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    _compose__B = typing.TypeVar('_compose__B')  # <B>
    @staticmethod
    def compose(predicate: typing.Union[Predicate[_compose__B], typing.Callable[[_compose__B], bool]], function: typing.Union[Function[_compose__A, _compose__B], typing.Callable[[_compose__A], _compose__B]]) -> Predicate[_compose__A]: ...
    @staticmethod
    def contains(pattern: java.util.regex.Pattern) -> Predicate[java.lang.CharSequence]: ...
    @staticmethod
    def containsPattern(string: str) -> Predicate[java.lang.CharSequence]: ...
    _equalTo__T = typing.TypeVar('_equalTo__T')  # <T>
    @staticmethod
    def equalTo(t: _equalTo__T) -> Predicate[_equalTo__T]: ...
    @staticmethod
    def instanceOf(class_: typing.Type[typing.Any]) -> Predicate[typing.Any]: ...
    _isNull__T = typing.TypeVar('_isNull__T')  # <T>
    @staticmethod
    def isNull() -> Predicate[_isNull__T]: ...
    _notNull__T = typing.TypeVar('_notNull__T')  # <T>
    @staticmethod
    def notNull() -> Predicate[_notNull__T]: ...
    @staticmethod
    def subtypeOf(class_: typing.Type[typing.Any]) -> Predicate[typing.Type[typing.Any]]: ...

class Splitter:
    """
    Java class 'com.google.common.base.Splitter'
    
        Extends:
            java.lang.Object
    
    """
    @staticmethod
    def fixedLength(int: int) -> 'Splitter': ...
    def limit(self, int: int) -> 'Splitter': ...
    def omitEmptyStrings(self) -> 'Splitter': ...
    @typing.overload
    @staticmethod
    def on(char: str) -> 'Splitter': ...
    @typing.overload
    @staticmethod
    def on(charMatcher: 'CharMatcher') -> 'Splitter': ...
    @typing.overload
    @staticmethod
    def on(string: str) -> 'Splitter': ...
    @typing.overload
    @staticmethod
    def on(pattern: java.util.regex.Pattern) -> 'Splitter': ...
    @staticmethod
    def onPattern(string: str) -> 'Splitter': ...
    def split(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> java.lang.Iterable[str]: ...
    def splitToList(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> java.util.List[str]: ...
    def splitToStream(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> java.util.stream.Stream[str]: ...
    @typing.overload
    def trimResults(self) -> 'Splitter': ...
    @typing.overload
    def trimResults(self, charMatcher: 'CharMatcher') -> 'Splitter': ...
    @typing.overload
    def withKeyValueSeparator(self, char: str) -> 'Splitter.MapSplitter': ...
    @typing.overload
    def withKeyValueSeparator(self, splitter: 'Splitter') -> 'Splitter.MapSplitter': ...
    @typing.overload
    def withKeyValueSeparator(self, string: str) -> 'Splitter.MapSplitter': ...
    class MapSplitter:
        """
        Java class 'com.google.common.base.Splitter$MapSplitter'
        
            Extends:
                java.lang.Object
        
        """
        def split(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> java.util.Map[str, str]: ...

class StandardSystemProperty(java.lang.Enum['StandardSystemProperty']):
    """
    Java class 'com.google.common.base.StandardSystemProperty'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        JAVA_VERSION (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_VENDOR (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_VENDOR_URL (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_HOME (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_VM_SPECIFICATION_VERSION (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_VM_SPECIFICATION_VENDOR (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_VM_SPECIFICATION_NAME (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_VM_VERSION (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_VM_VENDOR (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_VM_NAME (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_SPECIFICATION_VERSION (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_SPECIFICATION_VENDOR (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_SPECIFICATION_NAME (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_CLASS_VERSION (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_CLASS_PATH (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_LIBRARY_PATH (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_IO_TMPDIR (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_COMPILER (com.google.common.base.StandardSystemProperty): final static enum constant
        JAVA_EXT_DIRS (com.google.common.base.StandardSystemProperty): final static enum constant
        OS_NAME (com.google.common.base.StandardSystemProperty): final static enum constant
        OS_ARCH (com.google.common.base.StandardSystemProperty): final static enum constant
        OS_VERSION (com.google.common.base.StandardSystemProperty): final static enum constant
        FILE_SEPARATOR (com.google.common.base.StandardSystemProperty): final static enum constant
        PATH_SEPARATOR (com.google.common.base.StandardSystemProperty): final static enum constant
        LINE_SEPARATOR (com.google.common.base.StandardSystemProperty): final static enum constant
        USER_NAME (com.google.common.base.StandardSystemProperty): final static enum constant
        USER_HOME (com.google.common.base.StandardSystemProperty): final static enum constant
        USER_DIR (com.google.common.base.StandardSystemProperty): final static enum constant
    
    """
    JAVA_VERSION: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_VENDOR: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_VENDOR_URL: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_HOME: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_VM_SPECIFICATION_VERSION: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_VM_SPECIFICATION_VENDOR: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_VM_SPECIFICATION_NAME: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_VM_VERSION: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_VM_VENDOR: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_VM_NAME: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_SPECIFICATION_VERSION: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_SPECIFICATION_VENDOR: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_SPECIFICATION_NAME: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_CLASS_VERSION: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_CLASS_PATH: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_LIBRARY_PATH: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_IO_TMPDIR: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_COMPILER: typing.ClassVar['StandardSystemProperty'] = ...
    JAVA_EXT_DIRS: typing.ClassVar['StandardSystemProperty'] = ...
    OS_NAME: typing.ClassVar['StandardSystemProperty'] = ...
    OS_ARCH: typing.ClassVar['StandardSystemProperty'] = ...
    OS_VERSION: typing.ClassVar['StandardSystemProperty'] = ...
    FILE_SEPARATOR: typing.ClassVar['StandardSystemProperty'] = ...
    PATH_SEPARATOR: typing.ClassVar['StandardSystemProperty'] = ...
    LINE_SEPARATOR: typing.ClassVar['StandardSystemProperty'] = ...
    USER_NAME: typing.ClassVar['StandardSystemProperty'] = ...
    USER_HOME: typing.ClassVar['StandardSystemProperty'] = ...
    USER_DIR: typing.ClassVar['StandardSystemProperty'] = ...
    def key(self) -> str: ...
    def toString(self) -> str: ...
    def value(self) -> str: ...
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'StandardSystemProperty': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @staticmethod
    def values() -> typing.List['StandardSystemProperty']: ...

class Stopwatch:
    """
    Java class 'com.google.common.base.Stopwatch'
    
        Extends:
            java.lang.Object
    
    """
    @typing.overload
    @staticmethod
    def createStarted() -> 'Stopwatch': ...
    @typing.overload
    @staticmethod
    def createStarted(ticker: 'Ticker') -> 'Stopwatch': ...
    @typing.overload
    @staticmethod
    def createUnstarted() -> 'Stopwatch': ...
    @typing.overload
    @staticmethod
    def createUnstarted(ticker: 'Ticker') -> 'Stopwatch': ...
    @typing.overload
    def elapsed(self) -> java.time.Duration: ...
    @typing.overload
    def elapsed(self, timeUnit: java.util.concurrent.TimeUnit) -> int: ...
    def isRunning(self) -> bool: ...
    def reset(self) -> 'Stopwatch': ...
    def start(self) -> 'Stopwatch': ...
    def stop(self) -> 'Stopwatch': ...
    def toString(self) -> str: ...

class Strings:
    """
    Java class 'com.google.common.base.Strings'
    
        Extends:
            java.lang.Object
    
    """
    @staticmethod
    def commonPrefix(charSequence: typing.Union[java.lang.CharSequence, str], charSequence2: typing.Union[java.lang.CharSequence, str]) -> str: ...
    @staticmethod
    def commonSuffix(charSequence: typing.Union[java.lang.CharSequence, str], charSequence2: typing.Union[java.lang.CharSequence, str]) -> str: ...
    @staticmethod
    def emptyToNull(string: str) -> str: ...
    @staticmethod
    def isNullOrEmpty(string: str) -> bool: ...
    @staticmethod
    def lenientFormat(string: str, objectArray: typing.List[typing.Any]) -> str: ...
    @staticmethod
    def nullToEmpty(string: str) -> str: ...
    @staticmethod
    def padEnd(string: str, int: int, char: str) -> str: ...
    @staticmethod
    def padStart(string: str, int: int, char: str) -> str: ...
    @staticmethod
    def repeat(string: str, int: int) -> str: ...

_Supplier__T = typing.TypeVar('_Supplier__T')  # <T>
class Supplier(java.util.function.Supplier[_Supplier__T], typing.Generic[_Supplier__T]):
    """
    Java class 'com.google.common.base.Supplier'
    
        Interfaces:
            java.util.function.Supplier
    
    """
    def get(self) -> _Supplier__T: ...

class Suppliers:
    """
    Java class 'com.google.common.base.Suppliers'
    
        Extends:
            java.lang.Object
    
    """
    _compose__F = typing.TypeVar('_compose__F')  # <F>
    _compose__T = typing.TypeVar('_compose__T')  # <T>
    @staticmethod
    def compose(function: typing.Union[Function[_compose__F, _compose__T], typing.Callable[[_compose__F], _compose__T]], supplier: typing.Union[Supplier[_compose__F], typing.Callable[[], _compose__F]]) -> Supplier[_compose__T]: ...
    _memoize__T = typing.TypeVar('_memoize__T')  # <T>
    @staticmethod
    def memoize(supplier: typing.Union[Supplier[_memoize__T], typing.Callable[[], _memoize__T]]) -> Supplier[_memoize__T]: ...
    _memoizeWithExpiration__T = typing.TypeVar('_memoizeWithExpiration__T')  # <T>
    @staticmethod
    def memoizeWithExpiration(supplier: typing.Union[Supplier[_memoizeWithExpiration__T], typing.Callable[[], _memoizeWithExpiration__T]], long: int, timeUnit: java.util.concurrent.TimeUnit) -> Supplier[_memoizeWithExpiration__T]: ...
    _ofInstance__T = typing.TypeVar('_ofInstance__T')  # <T>
    @staticmethod
    def ofInstance(t: _ofInstance__T) -> Supplier[_ofInstance__T]: ...
    _supplierFunction__T = typing.TypeVar('_supplierFunction__T')  # <T>
    @staticmethod
    def supplierFunction() -> Function[Supplier[_supplierFunction__T], _supplierFunction__T]: ...
    _synchronizedSupplier__T = typing.TypeVar('_synchronizedSupplier__T')  # <T>
    @staticmethod
    def synchronizedSupplier(supplier: typing.Union[Supplier[_synchronizedSupplier__T], typing.Callable[[], _synchronizedSupplier__T]]) -> Supplier[_synchronizedSupplier__T]: ...

class Throwables:
    """
    Java class 'com.google.common.base.Throwables'
    
        Extends:
            java.lang.Object
    
    """
    @staticmethod
    def getCausalChain(throwable: java.lang.Throwable) -> java.util.List[java.lang.Throwable]: ...
    _getCauseAs__X = typing.TypeVar('_getCauseAs__X', bound=java.lang.Throwable)  # <X>
    @staticmethod
    def getCauseAs(throwable: java.lang.Throwable, class_: typing.Type[_getCauseAs__X]) -> _getCauseAs__X: ...
    @staticmethod
    def getRootCause(throwable: java.lang.Throwable) -> java.lang.Throwable: ...
    @staticmethod
    def getStackTraceAsString(throwable: java.lang.Throwable) -> str: ...
    @staticmethod
    def lazyStackTrace(throwable: java.lang.Throwable) -> java.util.List[java.lang.StackTraceElement]: ...
    @staticmethod
    def lazyStackTraceIsLazy() -> bool: ...
    @staticmethod
    def propagate(throwable: java.lang.Throwable) -> java.lang.RuntimeException: ...
    _propagateIfInstanceOf__X = typing.TypeVar('_propagateIfInstanceOf__X', bound=java.lang.Throwable)  # <X>
    @staticmethod
    def propagateIfInstanceOf(throwable: java.lang.Throwable, class_: typing.Type[_propagateIfInstanceOf__X]) -> None: ...
    _propagateIfPossible_1__X = typing.TypeVar('_propagateIfPossible_1__X', bound=java.lang.Throwable)  # <X>
    _propagateIfPossible_2__X1 = typing.TypeVar('_propagateIfPossible_2__X1', bound=java.lang.Throwable)  # <X1>
    _propagateIfPossible_2__X2 = typing.TypeVar('_propagateIfPossible_2__X2', bound=java.lang.Throwable)  # <X2>
    @typing.overload
    @staticmethod
    def propagateIfPossible(throwable: java.lang.Throwable) -> None: ...
    @typing.overload
    @staticmethod
    def propagateIfPossible(throwable: java.lang.Throwable, class_: typing.Type[_propagateIfPossible_1__X]) -> None: ...
    @typing.overload
    @staticmethod
    def propagateIfPossible(throwable: java.lang.Throwable, class_: typing.Type[_propagateIfPossible_2__X1], class2: typing.Type[_propagateIfPossible_2__X2]) -> None: ...
    _throwIfInstanceOf__X = typing.TypeVar('_throwIfInstanceOf__X', bound=java.lang.Throwable)  # <X>
    @staticmethod
    def throwIfInstanceOf(throwable: java.lang.Throwable, class_: typing.Type[_throwIfInstanceOf__X]) -> None: ...
    @staticmethod
    def throwIfUnchecked(throwable: java.lang.Throwable) -> None: ...

class Ticker:
    """
    Java class 'com.google.common.base.Ticker'
    
        Extends:
            java.lang.Object
    
    """
    def read(self) -> int: ...
    @staticmethod
    def systemTicker() -> 'Ticker': ...

class Utf8:
    """
    Java class 'com.google.common.base.Utf8'
    
        Extends:
            java.lang.Object
    
    """
    @staticmethod
    def encodedLength(charSequence: typing.Union[java.lang.CharSequence, str]) -> int: ...
    @typing.overload
    @staticmethod
    def isWellFormed(byteArray: typing.List[int]) -> bool: ...
    @typing.overload
    @staticmethod
    def isWellFormed(byteArray: typing.List[int], int: int, int2: int) -> bool: ...

class Verify:
    """
    Java class 'com.google.common.base.Verify'
    
        Extends:
            java.lang.Object
    
    """
    @typing.overload
    @staticmethod
    def verify(boolean: bool) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, char: str, char2: str) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, char: str, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, char: str, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, char: str, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, int: int, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, int: int, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, int: int, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, object: typing.Any, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, object: typing.Any, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, object: typing.Any, object2: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, object: typing.Any, object2: typing.Any, object3: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, object: typing.Any, object2: typing.Any, object3: typing.Any, object4: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, object: typing.Any, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, objectArray: typing.List[typing.Any]) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, long: int) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, long: int, char: str) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, long: int, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, long: int, object: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def verify(boolean: bool, string: str, long: int, long2: int) -> None: ...
    _verifyNotNull_0__T = typing.TypeVar('_verifyNotNull_0__T')  # <T>
    _verifyNotNull_1__T = typing.TypeVar('_verifyNotNull_1__T')  # <T>
    @typing.overload
    @staticmethod
    def verifyNotNull(t: _verifyNotNull_0__T) -> _verifyNotNull_0__T: ...
    @typing.overload
    @staticmethod
    def verifyNotNull(t: _verifyNotNull_1__T, string: str, objectArray: typing.List[typing.Any]) -> _verifyNotNull_1__T: ...

class VerifyException(java.lang.RuntimeException):
    """
    Java class 'com.google.common.base.VerifyException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * VerifyException(java.lang.String, java.lang.Throwable)
        * VerifyException(java.lang.Throwable)
        * VerifyException(java.lang.String)
        * VerifyException()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class CharMatcher(Predicate[str]):
    """
    Java class 'com.google.common.base.CharMatcher'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            com.google.common.base.Predicate
    
    """
    @staticmethod
    def any() -> 'CharMatcher': ...
    @staticmethod
    def anyOf(charSequence: typing.Union[java.lang.CharSequence, str]) -> 'CharMatcher': ...
    def apply(self, character: str) -> bool: ...
    @staticmethod
    def ascii() -> 'CharMatcher': ...
    @staticmethod
    def breakingWhitespace() -> 'CharMatcher': ...
    def collapseFrom(self, charSequence: typing.Union[java.lang.CharSequence, str], char2: str) -> str: ...
    def countIn(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> int: ...
    @staticmethod
    def digit() -> 'CharMatcher': ...
    @staticmethod
    def forPredicate(predicate: typing.Union[Predicate[str], typing.Callable[[str], bool]]) -> 'CharMatcher': ...
    @staticmethod
    def inRange(char: str, char2: str) -> 'CharMatcher': ...
    @typing.overload
    def indexIn(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> int: ...
    @typing.overload
    def indexIn(self, charSequence: typing.Union[java.lang.CharSequence, str], int: int) -> int: ...
    @staticmethod
    def invisible() -> 'CharMatcher': ...
    @staticmethod
    def isNot(char: str) -> 'CharMatcher': ...
    @staticmethod
    def javaDigit() -> 'CharMatcher': ...
    @staticmethod
    def javaIsoControl() -> 'CharMatcher': ...
    @staticmethod
    def javaLetter() -> 'CharMatcher': ...
    @staticmethod
    def javaLetterOrDigit() -> 'CharMatcher': ...
    @staticmethod
    def javaLowerCase() -> 'CharMatcher': ...
    @staticmethod
    def javaUpperCase() -> 'CharMatcher': ...
    def lastIndexIn(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> int: ...
    def matches(self, char: str) -> bool: ...
    def matchesAllOf(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> bool: ...
    def matchesAnyOf(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> bool: ...
    def matchesNoneOf(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> bool: ...
    def negate(self) -> 'CharMatcher': ...
    @staticmethod
    def none() -> 'CharMatcher': ...
    @staticmethod
    def noneOf(charSequence: typing.Union[java.lang.CharSequence, str]) -> 'CharMatcher': ...
    def precomputed(self) -> 'CharMatcher': ...
    def removeFrom(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> str: ...
    @typing.overload
    def replaceFrom(self, charSequence: typing.Union[java.lang.CharSequence, str], char2: str) -> str: ...
    @typing.overload
    def replaceFrom(self, charSequence: typing.Union[java.lang.CharSequence, str], charSequence2: typing.Union[java.lang.CharSequence, str]) -> str: ...
    def retainFrom(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> str: ...
    @staticmethod
    def singleWidth() -> 'CharMatcher': ...
    def toString(self) -> str: ...
    def trimAndCollapseFrom(self, charSequence: typing.Union[java.lang.CharSequence, str], char2: str) -> str: ...
    def trimFrom(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> str: ...
    def trimLeadingFrom(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> str: ...
    def trimTrailingFrom(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> str: ...
    @staticmethod
    def whitespace() -> 'CharMatcher': ...

_Converter__A = typing.TypeVar('_Converter__A')  # <A>
_Converter__B = typing.TypeVar('_Converter__B')  # <B>
class Converter(Function[_Converter__A, _Converter__B], typing.Generic[_Converter__A, _Converter__B]):
    """
    Java class 'com.google.common.base.Converter'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            com.google.common.base.Function
    
    """
    _andThen_0__V = typing.TypeVar('_andThen_0__V')  # <V>
    _andThen_1__C = typing.TypeVar('_andThen_1__C')  # <C>
    @typing.overload
    def andThen(self, function: typing.Union[java.util.function.Function[typing.Any, _andThen_0__V], typing.Callable[[typing.Any], _andThen_0__V]]) -> java.util.function.Function[typing.Any, _andThen_0__V]: ...
    @typing.overload
    def andThen(self, converter: 'Converter'[_Converter__B, _andThen_1__C]) -> 'Converter'[_Converter__A, _andThen_1__C]: ...
    def apply(self, a: _Converter__A) -> _Converter__B: ...
    def convert(self, a: _Converter__A) -> _Converter__B: ...
    def convertAll(self, iterable: java.lang.Iterable[_Converter__A]) -> java.lang.Iterable[_Converter__B]: ...
    def equals(self, object: typing.Any) -> bool: ...
    _identity__T = typing.TypeVar('_identity__T')  # <T>
    @staticmethod
    def identity() -> 'Converter'[_identity__T, _identity__T]: ...
    def reverse(self) -> 'Converter'[_Converter__B, _Converter__A]: ...

_FinalizablePhantomReference__T = typing.TypeVar('_FinalizablePhantomReference__T')  # <T>
class FinalizablePhantomReference(java.lang.ref.PhantomReference[_FinalizablePhantomReference__T], FinalizableReference, typing.Generic[_FinalizablePhantomReference__T]): ...

_FinalizableSoftReference__T = typing.TypeVar('_FinalizableSoftReference__T')  # <T>
class FinalizableSoftReference(java.lang.ref.SoftReference[_FinalizableSoftReference__T], FinalizableReference, typing.Generic[_FinalizableSoftReference__T]): ...

_FinalizableWeakReference__T = typing.TypeVar('_FinalizableWeakReference__T')  # <T>
class FinalizableWeakReference(java.lang.ref.WeakReference[_FinalizableWeakReference__T], FinalizableReference, typing.Generic[_FinalizableWeakReference__T]): ...

class Objects(com.google.common.base.ExtraObjectsMethodsForWeb):
    """
    Java class 'com.google.common.base.Objects'
    
        Extends:
            com.google.common.base.ExtraObjectsMethodsForWeb
    
    """
    @staticmethod
    def equal(object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(objectArray: typing.List[typing.Any]) -> int: ...

class ExtraObjectsMethodsForWeb: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("com.google.common.base")``.

    Ascii: typing.Type[Ascii]
    CaseFormat: typing.Type[CaseFormat]
    CharMatcher: typing.Type[CharMatcher]
    Charsets: typing.Type[Charsets]
    Converter: typing.Type[Converter]
    Defaults: typing.Type[Defaults]
    Enums: typing.Type[Enums]
    Equivalence: typing.Type[Equivalence]
    ExtraObjectsMethodsForWeb: typing.Type[ExtraObjectsMethodsForWeb]
    FinalizablePhantomReference: typing.Type[FinalizablePhantomReference]
    FinalizableReference: typing.Type[FinalizableReference]
    FinalizableReferenceQueue: typing.Type[FinalizableReferenceQueue]
    FinalizableSoftReference: typing.Type[FinalizableSoftReference]
    FinalizableWeakReference: typing.Type[FinalizableWeakReference]
    Function: typing.Type[Function]
    Functions: typing.Type[Functions]
    Joiner: typing.Type[Joiner]
    MoreObjects: typing.Type[MoreObjects]
    Objects: typing.Type[Objects]
    Optional: typing.Type[Optional]
    Preconditions: typing.Type[Preconditions]
    Predicate: typing.Type[Predicate]
    Predicates: typing.Type[Predicates]
    Splitter: typing.Type[Splitter]
    StandardSystemProperty: typing.Type[StandardSystemProperty]
    Stopwatch: typing.Type[Stopwatch]
    Strings: typing.Type[Strings]
    Supplier: typing.Type[Supplier]
    Suppliers: typing.Type[Suppliers]
    Throwables: typing.Type[Throwables]
    Ticker: typing.Type[Ticker]
    Utf8: typing.Type[Utf8]
    Verify: typing.Type[Verify]
    VerifyException: typing.Type[VerifyException]
    internal: com.google.common.base.internal.__module_protocol__
