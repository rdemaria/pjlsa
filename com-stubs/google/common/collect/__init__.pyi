import com
import com.google.common.base
import java.io
import java.lang
import java.math
import java.time
import java.util
import java.util.concurrent
import java.util.concurrent.atomic
import java.util.function
import java.util.stream
import typing



_BiMap__K = typing.TypeVar('_BiMap__K')  # <K>
_BiMap__V = typing.TypeVar('_BiMap__V')  # <V>
class BiMap(java.util.Map[_BiMap__K, _BiMap__V], typing.Generic[_BiMap__K, _BiMap__V]):
    """
    Java class 'com.google.common.collect.BiMap'
    
        Interfaces:
            java.util.Map
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def forcePut(self, k: _BiMap__K, v: _BiMap__V) -> _BiMap__V: ...
    def hashCode(self) -> int: ...
    def inverse(self) -> 'BiMap'[_BiMap__V, _BiMap__K]: ...
    def put(self, k: _BiMap__K, v: _BiMap__V) -> _BiMap__V: ...
    def putAll(self, map: typing.Union[java.util.Map[_BiMap__K, _BiMap__V], typing.Mapping[_BiMap__K, _BiMap__V]]) -> None: ...
    def values(self) -> java.util.Set[_BiMap__V]: ...

class BoundType(java.lang.Enum['BoundType']):
    """
    Java class 'com.google.common.collect.BoundType'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        OPEN (com.google.common.collect.BoundType): final static enum constant
        CLOSED (com.google.common.collect.BoundType): final static enum constant
    
    """
    OPEN: typing.ClassVar['BoundType'] = ...
    CLOSED: typing.ClassVar['BoundType'] = ...
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'BoundType': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @staticmethod
    def values() -> typing.List['BoundType']: ...

_ClassToInstanceMap__B = typing.TypeVar('_ClassToInstanceMap__B')  # <B>
class ClassToInstanceMap(java.util.Map[typing.Type[_ClassToInstanceMap__B], _ClassToInstanceMap__B], typing.Generic[_ClassToInstanceMap__B]):
    """
    Java class 'com.google.common.collect.ClassToInstanceMap'
    
        Interfaces:
            java.util.Map
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    _getInstance__T = typing.TypeVar('_getInstance__T')  # <T>
    def getInstance(self, class_: typing.Type[_getInstance__T]) -> _getInstance__T: ...
    def hashCode(self) -> int: ...
    _putInstance__T = typing.TypeVar('_putInstance__T')  # <T>
    def putInstance(self, class_: typing.Type[_putInstance__T], t: _putInstance__T) -> _putInstance__T: ...

class Collections2:
    """
    Java class 'com.google.common.collect.Collections2'
    
        Extends:
            java.lang.Object
    
    """
    _filter__E = typing.TypeVar('_filter__E')  # <E>
    @staticmethod
    def filter(collection: typing.Union[java.util.Collection[_filter__E], typing.Sequence[_filter__E]], predicate: typing.Union[com.google.common.base.Predicate[_filter__E], typing.Callable[[_filter__E], bool]]) -> java.util.Collection[_filter__E]: ...
    _orderedPermutations_0__E = typing.TypeVar('_orderedPermutations_0__E', bound=java.lang.Comparable)  # <E>
    _orderedPermutations_1__E = typing.TypeVar('_orderedPermutations_1__E')  # <E>
    @typing.overload
    @staticmethod
    def orderedPermutations(iterable: java.lang.Iterable[_orderedPermutations_0__E]) -> java.util.Collection[java.util.List[_orderedPermutations_0__E]]: ...
    @typing.overload
    @staticmethod
    def orderedPermutations(iterable: java.lang.Iterable[_orderedPermutations_1__E], comparator: typing.Union[java.util.Comparator[_orderedPermutations_1__E], typing.Callable[[_orderedPermutations_1__E, _orderedPermutations_1__E], int]]) -> java.util.Collection[java.util.List[_orderedPermutations_1__E]]: ...
    _permutations__E = typing.TypeVar('_permutations__E')  # <E>
    @staticmethod
    def permutations(collection: typing.Union[java.util.Collection[_permutations__E], typing.Sequence[_permutations__E]]) -> java.util.Collection[java.util.List[_permutations__E]]: ...
    _transform__F = typing.TypeVar('_transform__F')  # <F>
    _transform__T = typing.TypeVar('_transform__T')  # <T>
    @staticmethod
    def transform(collection: typing.Union[java.util.Collection[_transform__F], typing.Sequence[_transform__F]], function: typing.Union[com.google.common.base.Function[_transform__F, _transform__T], typing.Callable[[_transform__F], _transform__T]]) -> java.util.Collection[_transform__T]: ...

class Comparators:
    """
    Java class 'com.google.common.collect.Comparators'
    
        Extends:
            java.lang.Object
    
    """
    _emptiesFirst__T = typing.TypeVar('_emptiesFirst__T')  # <T>
    @staticmethod
    def emptiesFirst(comparator: typing.Union[java.util.Comparator[_emptiesFirst__T], typing.Callable[[_emptiesFirst__T, _emptiesFirst__T], int]]) -> java.util.Comparator[java.util.Optional[_emptiesFirst__T]]: ...
    _emptiesLast__T = typing.TypeVar('_emptiesLast__T')  # <T>
    @staticmethod
    def emptiesLast(comparator: typing.Union[java.util.Comparator[_emptiesLast__T], typing.Callable[[_emptiesLast__T, _emptiesLast__T], int]]) -> java.util.Comparator[java.util.Optional[_emptiesLast__T]]: ...
    _greatest__T = typing.TypeVar('_greatest__T')  # <T>
    @staticmethod
    def greatest(int: int, comparator: typing.Union[java.util.Comparator[_greatest__T], typing.Callable[[_greatest__T, _greatest__T], int]]) -> java.util.stream.Collector[_greatest__T, typing.Any, java.util.List[_greatest__T]]: ...
    _isInOrder__T = typing.TypeVar('_isInOrder__T')  # <T>
    @staticmethod
    def isInOrder(iterable: java.lang.Iterable[_isInOrder__T], comparator: typing.Union[java.util.Comparator[_isInOrder__T], typing.Callable[[_isInOrder__T, _isInOrder__T], int]]) -> bool: ...
    _isInStrictOrder__T = typing.TypeVar('_isInStrictOrder__T')  # <T>
    @staticmethod
    def isInStrictOrder(iterable: java.lang.Iterable[_isInStrictOrder__T], comparator: typing.Union[java.util.Comparator[_isInStrictOrder__T], typing.Callable[[_isInStrictOrder__T, _isInStrictOrder__T], int]]) -> bool: ...
    _least__T = typing.TypeVar('_least__T')  # <T>
    @staticmethod
    def least(int: int, comparator: typing.Union[java.util.Comparator[_least__T], typing.Callable[[_least__T, _least__T], int]]) -> java.util.stream.Collector[_least__T, typing.Any, java.util.List[_least__T]]: ...
    _lexicographical__T = typing.TypeVar('_lexicographical__T')  # <T>
    _lexicographical__S = typing.TypeVar('_lexicographical__S')  # <S>
    @staticmethod
    def lexicographical(comparator: typing.Union[java.util.Comparator[_lexicographical__T], typing.Callable[[_lexicographical__T, _lexicographical__T], int]]) -> java.util.Comparator[java.lang.Iterable[_lexicographical__S]]: ...

class ComparisonChain:
    """
    Java class 'com.google.common.collect.ComparisonChain'
    
        Extends:
            java.lang.Object
    
    """
    _compare_4__T = typing.TypeVar('_compare_4__T')  # <T>
    @typing.overload
    def compare(self, double: float, double2: float) -> 'ComparisonChain': ...
    @typing.overload
    def compare(self, float: float, float2: float) -> 'ComparisonChain': ...
    @typing.overload
    def compare(self, int: int, int2: int) -> 'ComparisonChain': ...
    @typing.overload
    def compare(self, comparable: java.lang.Comparable[typing.Any], comparable2: java.lang.Comparable[typing.Any]) -> 'ComparisonChain': ...
    @typing.overload
    def compare(self, t: _compare_4__T, t2: _compare_4__T, comparator: typing.Union[java.util.Comparator[_compare_4__T], typing.Callable[[_compare_4__T, _compare_4__T], int]]) -> 'ComparisonChain': ...
    @typing.overload
    def compare(self, long: int, long2: int) -> 'ComparisonChain': ...
    @typing.overload
    def compare(self, boolean: bool, boolean2: bool) -> 'ComparisonChain': ...
    def compareFalseFirst(self, boolean: bool, boolean2: bool) -> 'ComparisonChain': ...
    def compareTrueFirst(self, boolean: bool, boolean2: bool) -> 'ComparisonChain': ...
    def result(self) -> int: ...
    @staticmethod
    def start() -> 'ComparisonChain': ...

class ComputationException(java.lang.RuntimeException):
    """
    Java class 'com.google.common.collect.ComputationException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * ComputationException(java.lang.Throwable)
    
    """
    def __init__(self, throwable: java.lang.Throwable): ...

_DiscreteDomain__C = typing.TypeVar('_DiscreteDomain__C', bound=java.lang.Comparable)  # <C>
class DiscreteDomain(typing.Generic[_DiscreteDomain__C]):
    """
    Java class 'com.google.common.collect.DiscreteDomain'
    
        Extends:
            java.lang.Object
    
    """
    @staticmethod
    def bigIntegers() -> 'DiscreteDomain'[java.math.BigInteger]: ...
    def distance(self, c: _DiscreteDomain__C, c2: _DiscreteDomain__C) -> int: ...
    @staticmethod
    def integers() -> 'DiscreteDomain'[int]: ...
    @staticmethod
    def longs() -> 'DiscreteDomain'[int]: ...
    def maxValue(self) -> _DiscreteDomain__C: ...
    def minValue(self) -> _DiscreteDomain__C: ...
    def next(self, c: _DiscreteDomain__C) -> _DiscreteDomain__C: ...
    def previous(self, c: _DiscreteDomain__C) -> _DiscreteDomain__C: ...

_FluentIterable__E = typing.TypeVar('_FluentIterable__E')  # <E>
class FluentIterable(java.lang.Iterable[_FluentIterable__E], typing.Generic[_FluentIterable__E]):
    """
    Java class 'com.google.common.collect.FluentIterable'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.lang.Iterable
    
    """
    def allMatch(self, predicate: typing.Union[com.google.common.base.Predicate[_FluentIterable__E], typing.Callable[[_FluentIterable__E], bool]]) -> bool: ...
    def anyMatch(self, predicate: typing.Union[com.google.common.base.Predicate[_FluentIterable__E], typing.Callable[[_FluentIterable__E], bool]]) -> bool: ...
    @typing.overload
    def append(self, iterable: java.lang.Iterable[_FluentIterable__E]) -> 'FluentIterable'[_FluentIterable__E]: ...
    @typing.overload
    def append(self, eArray: typing.List[_FluentIterable__E]) -> 'FluentIterable'[_FluentIterable__E]: ...
    _concat_0__T = typing.TypeVar('_concat_0__T')  # <T>
    _concat_1__T = typing.TypeVar('_concat_1__T')  # <T>
    _concat_2__T = typing.TypeVar('_concat_2__T')  # <T>
    _concat_3__T = typing.TypeVar('_concat_3__T')  # <T>
    _concat_4__T = typing.TypeVar('_concat_4__T')  # <T>
    @typing.overload
    @staticmethod
    def concat(iterable: java.lang.Iterable[java.lang.Iterable[_concat_0__T]]) -> 'FluentIterable'[_concat_0__T]: ...
    @typing.overload
    @staticmethod
    def concat(iterable: java.lang.Iterable[_concat_1__T], iterable2: java.lang.Iterable[_concat_1__T]) -> 'FluentIterable'[_concat_1__T]: ...
    @typing.overload
    @staticmethod
    def concat(iterable: java.lang.Iterable[_concat_2__T], iterable2: java.lang.Iterable[_concat_2__T], iterable3: java.lang.Iterable[_concat_2__T]) -> 'FluentIterable'[_concat_2__T]: ...
    @typing.overload
    @staticmethod
    def concat(iterable: java.lang.Iterable[_concat_3__T], iterable2: java.lang.Iterable[_concat_3__T], iterable3: java.lang.Iterable[_concat_3__T], iterable4: java.lang.Iterable[_concat_3__T]) -> 'FluentIterable'[_concat_3__T]: ...
    @typing.overload
    @staticmethod
    def concat(iterableArray: typing.List[java.lang.Iterable[_concat_4__T]]) -> 'FluentIterable'[_concat_4__T]: ...
    def contains(self, object: typing.Any) -> bool: ...
    _copyInto__C = typing.TypeVar('_copyInto__C', bound=java.util.Collection)  # <C>
    def copyInto(self, c: _copyInto__C) -> _copyInto__C: ...
    def cycle(self) -> 'FluentIterable'[_FluentIterable__E]: ...
    _filter_1__T = typing.TypeVar('_filter_1__T')  # <T>
    @typing.overload
    def filter(self, predicate: typing.Union[com.google.common.base.Predicate[_FluentIterable__E], typing.Callable[[_FluentIterable__E], bool]]) -> 'FluentIterable'[_FluentIterable__E]: ...
    @typing.overload
    def filter(self, class_: typing.Type[_filter_1__T]) -> 'FluentIterable'[_filter_1__T]: ...
    def first(self) -> com.google.common.base.Optional[_FluentIterable__E]: ...
    def firstMatch(self, predicate: typing.Union[com.google.common.base.Predicate[_FluentIterable__E], typing.Callable[[_FluentIterable__E], bool]]) -> com.google.common.base.Optional[_FluentIterable__E]: ...
    def get(self, int: int) -> _FluentIterable__E: ...
    _index__K = typing.TypeVar('_index__K')  # <K>
    def index(self, function: typing.Union[com.google.common.base.Function[_FluentIterable__E, _index__K], typing.Callable[[_FluentIterable__E], _index__K]]) -> 'ImmutableListMultimap'[_index__K, _FluentIterable__E]: ...
    def isEmpty(self) -> bool: ...
    def join(self, joiner: com.google.common.base.Joiner) -> str: ...
    def last(self) -> com.google.common.base.Optional[_FluentIterable__E]: ...
    def limit(self, int: int) -> 'FluentIterable'[_FluentIterable__E]: ...
    _of_0__E = typing.TypeVar('_of_0__E')  # <E>
    _of_1__E = typing.TypeVar('_of_1__E')  # <E>
    @typing.overload
    @staticmethod
    def of() -> 'FluentIterable'[_of_0__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_1__E, eArray: typing.List[_of_1__E]) -> 'FluentIterable'[_of_1__E]: ...
    def size(self) -> int: ...
    def skip(self, int: int) -> 'FluentIterable'[_FluentIterable__E]: ...
    def stream(self) -> java.util.stream.Stream[_FluentIterable__E]: ...
    def toArray(self, class_: typing.Type[_FluentIterable__E]) -> typing.List[_FluentIterable__E]: ...
    def toList(self) -> 'ImmutableList'[_FluentIterable__E]: ...
    _toMap__V = typing.TypeVar('_toMap__V')  # <V>
    def toMap(self, function: typing.Union[com.google.common.base.Function[_FluentIterable__E, _toMap__V], typing.Callable[[_FluentIterable__E], _toMap__V]]) -> 'ImmutableMap'[_FluentIterable__E, _toMap__V]: ...
    def toMultiset(self) -> 'ImmutableMultiset'[_FluentIterable__E]: ...
    def toSet(self) -> 'ImmutableSet'[_FluentIterable__E]: ...
    def toSortedList(self, comparator: typing.Union[java.util.Comparator[_FluentIterable__E], typing.Callable[[_FluentIterable__E, _FluentIterable__E], int]]) -> 'ImmutableList'[_FluentIterable__E]: ...
    def toSortedSet(self, comparator: typing.Union[java.util.Comparator[_FluentIterable__E], typing.Callable[[_FluentIterable__E, _FluentIterable__E], int]]) -> 'ImmutableSortedSet'[_FluentIterable__E]: ...
    def toString(self) -> str: ...
    _transform__T = typing.TypeVar('_transform__T')  # <T>
    def transform(self, function: typing.Union[com.google.common.base.Function[_FluentIterable__E, _transform__T], typing.Callable[[_FluentIterable__E], _transform__T]]) -> 'FluentIterable'[_transform__T]: ...
    _transformAndConcat__T = typing.TypeVar('_transformAndConcat__T')  # <T>
    def transformAndConcat(self, function: typing.Union[com.google.common.base.Function[_FluentIterable__E, java.lang.Iterable[_transformAndConcat__T]], typing.Callable[[_FluentIterable__E], java.lang.Iterable[_transformAndConcat__T]]]) -> 'FluentIterable'[_transformAndConcat__T]: ...
    _uniqueIndex__K = typing.TypeVar('_uniqueIndex__K')  # <K>
    def uniqueIndex(self, function: typing.Union[com.google.common.base.Function[_FluentIterable__E, _uniqueIndex__K], typing.Callable[[_FluentIterable__E], _uniqueIndex__K]]) -> 'ImmutableMap'[_uniqueIndex__K, _FluentIterable__E]: ...

class ForwardingObject:
    """
    Java class 'com.google.common.collect.ForwardingObject'
    
        Extends:
            java.lang.Object
    
    """
    def toString(self) -> str: ...

_ImmutableCollection__Builder__E = typing.TypeVar('_ImmutableCollection__Builder__E')  # <E>
_ImmutableCollection__E = typing.TypeVar('_ImmutableCollection__E')  # <E>
class ImmutableCollection(java.util.AbstractCollection[_ImmutableCollection__E], java.io.Serializable, typing.Generic[_ImmutableCollection__E]):
    """
    Java class 'com.google.common.collect.ImmutableCollection'
    
        Extends:
            java.util.AbstractCollection
    
        Interfaces:
            java.io.Serializable
    
    """
    def add(self, e: _ImmutableCollection__E) -> bool: ...
    def addAll(self, collection: typing.Union[java.util.Collection[_ImmutableCollection__E], typing.Sequence[_ImmutableCollection__E]]) -> bool: ...
    def asList(self) -> 'ImmutableList'[_ImmutableCollection__E]: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def iterator(self) -> 'UnmodifiableIterator'[_ImmutableCollection__E]: ...
    def remove(self, object: typing.Any) -> bool: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_ImmutableCollection__E], typing.Callable[[_ImmutableCollection__E], bool]]) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def spliterator(self) -> java.util.Spliterator[_ImmutableCollection__E]: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[int], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    class Builder(typing.Generic[_ImmutableCollection__Builder__E]):
        """
        Java class 'com.google.common.collect.ImmutableCollection$Builder'
        
            Extends:
                java.lang.Object
        
        """
        @typing.overload
        def add(self, e: _ImmutableCollection__Builder__E) -> 'ImmutableCollection.Builder'[_ImmutableCollection__Builder__E]: ...
        @typing.overload
        def add(self, eArray: typing.List[_ImmutableCollection__Builder__E]) -> 'ImmutableCollection.Builder'[_ImmutableCollection__Builder__E]: ...
        @typing.overload
        def addAll(self, iterable: java.lang.Iterable[_ImmutableCollection__Builder__E]) -> 'ImmutableCollection.Builder'[_ImmutableCollection__Builder__E]: ...
        @typing.overload
        def addAll(self, iterator: java.util.Iterator[_ImmutableCollection__Builder__E]) -> 'ImmutableCollection.Builder'[_ImmutableCollection__Builder__E]: ...
        def build(self) -> 'ImmutableCollection'[_ImmutableCollection__Builder__E]: ...

_ImmutableMap__Builder__K = typing.TypeVar('_ImmutableMap__Builder__K')  # <K>
_ImmutableMap__Builder__V = typing.TypeVar('_ImmutableMap__Builder__V')  # <V>
_ImmutableMap__K = typing.TypeVar('_ImmutableMap__K')  # <K>
_ImmutableMap__V = typing.TypeVar('_ImmutableMap__V')  # <V>
class ImmutableMap(java.util.Map[_ImmutableMap__K, _ImmutableMap__V], java.io.Serializable, typing.Generic[_ImmutableMap__K, _ImmutableMap__V]):
    """
    Java class 'com.google.common.collect.ImmutableMap'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.Map, java.io.Serializable
    
    """
    def asMultimap(self) -> 'ImmutableSetMultimap'[_ImmutableMap__K, _ImmutableMap__V]: ...
    _builder__K = typing.TypeVar('_builder__K')  # <K>
    _builder__V = typing.TypeVar('_builder__V')  # <V>
    @staticmethod
    def builder() -> 'ImmutableMap.Builder'[_builder__K, _builder__V]: ...
    _builderWithExpectedSize__K = typing.TypeVar('_builderWithExpectedSize__K')  # <K>
    _builderWithExpectedSize__V = typing.TypeVar('_builderWithExpectedSize__V')  # <V>
    @staticmethod
    def builderWithExpectedSize(int: int) -> 'ImmutableMap.Builder'[_builderWithExpectedSize__K, _builderWithExpectedSize__V]: ...
    def clear(self) -> None: ...
    def compute(self, k: _ImmutableMap__K, biFunction: typing.Union[java.util.function.BiFunction[_ImmutableMap__K, _ImmutableMap__V, _ImmutableMap__V], typing.Callable[[_ImmutableMap__K, _ImmutableMap__V], _ImmutableMap__V]]) -> _ImmutableMap__V: ...
    def computeIfAbsent(self, k: _ImmutableMap__K, function: typing.Union[java.util.function.Function[_ImmutableMap__K, _ImmutableMap__V], typing.Callable[[_ImmutableMap__K], _ImmutableMap__V]]) -> _ImmutableMap__V: ...
    def computeIfPresent(self, k: _ImmutableMap__K, biFunction: typing.Union[java.util.function.BiFunction[_ImmutableMap__K, _ImmutableMap__V, _ImmutableMap__V], typing.Callable[[_ImmutableMap__K, _ImmutableMap__V], _ImmutableMap__V]]) -> _ImmutableMap__V: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    _copyOf_0__K = typing.TypeVar('_copyOf_0__K')  # <K>
    _copyOf_0__V = typing.TypeVar('_copyOf_0__V')  # <V>
    _copyOf_1__K = typing.TypeVar('_copyOf_1__K')  # <K>
    _copyOf_1__V = typing.TypeVar('_copyOf_1__V')  # <V>
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[java.util.Map.Entry[_copyOf_0__K, _copyOf_0__V]]) -> 'ImmutableMap'[_copyOf_0__K, _copyOf_0__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(map: typing.Union[java.util.Map[_copyOf_1__K, _copyOf_1__V], typing.Mapping[_copyOf_1__K, _copyOf_1__V]]) -> 'ImmutableMap'[_copyOf_1__K, _copyOf_1__V]: ...
    def entrySet(self) -> 'ImmutableSet'[java.util.Map.Entry[_ImmutableMap__K, _ImmutableMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, object: typing.Any) -> _ImmutableMap__V: ...
    def getOrDefault(self, object: typing.Any, v: _ImmutableMap__V) -> _ImmutableMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'ImmutableSet'[_ImmutableMap__K]: ...
    def merge(self, k: _ImmutableMap__K, v: _ImmutableMap__V, biFunction: typing.Union[java.util.function.BiFunction[_ImmutableMap__V, _ImmutableMap__V, _ImmutableMap__V], typing.Callable[[_ImmutableMap__V, _ImmutableMap__V], _ImmutableMap__V]]) -> _ImmutableMap__V: ...
    _of_0__K = typing.TypeVar('_of_0__K')  # <K>
    _of_0__V = typing.TypeVar('_of_0__V')  # <V>
    _of_1__K = typing.TypeVar('_of_1__K')  # <K>
    _of_1__V = typing.TypeVar('_of_1__V')  # <V>
    _of_2__K = typing.TypeVar('_of_2__K')  # <K>
    _of_2__V = typing.TypeVar('_of_2__V')  # <V>
    _of_3__K = typing.TypeVar('_of_3__K')  # <K>
    _of_3__V = typing.TypeVar('_of_3__V')  # <V>
    _of_4__K = typing.TypeVar('_of_4__K')  # <K>
    _of_4__V = typing.TypeVar('_of_4__V')  # <V>
    _of_5__K = typing.TypeVar('_of_5__K')  # <K>
    _of_5__V = typing.TypeVar('_of_5__V')  # <V>
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableMap'[_of_0__K, _of_0__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_1__K, v: _of_1__V) -> 'ImmutableMap'[_of_1__K, _of_1__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_2__K, v: _of_2__V, k2: _of_2__K, v2: _of_2__V) -> 'ImmutableMap'[_of_2__K, _of_2__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_3__K, v: _of_3__V, k2: _of_3__K, v2: _of_3__V, k3: _of_3__K, v3: _of_3__V) -> 'ImmutableMap'[_of_3__K, _of_3__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_4__K, v: _of_4__V, k2: _of_4__K, v2: _of_4__V, k3: _of_4__K, v3: _of_4__V, k4: _of_4__K, v4: _of_4__V) -> 'ImmutableMap'[_of_4__K, _of_4__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_5__K, v: _of_5__V, k2: _of_5__K, v2: _of_5__V, k3: _of_5__K, v3: _of_5__V, k4: _of_5__K, v4: _of_5__V, k5: _of_5__K, v5: _of_5__V) -> 'ImmutableMap'[_of_5__K, _of_5__V]: ...
    def put(self, k: _ImmutableMap__K, v: _ImmutableMap__V) -> _ImmutableMap__V: ...
    def putAll(self, map: typing.Union[java.util.Map[_ImmutableMap__K, _ImmutableMap__V], typing.Mapping[_ImmutableMap__K, _ImmutableMap__V]]) -> None: ...
    def putIfAbsent(self, k: _ImmutableMap__K, v: _ImmutableMap__V) -> _ImmutableMap__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _ImmutableMap__V: ...
    @typing.overload
    def replace(self, k: _ImmutableMap__K, v: _ImmutableMap__V, v2: _ImmutableMap__V) -> bool: ...
    @typing.overload
    def replace(self, k: _ImmutableMap__K, v: _ImmutableMap__V) -> _ImmutableMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_ImmutableMap__K, _ImmutableMap__V, _ImmutableMap__V], typing.Callable[[_ImmutableMap__K, _ImmutableMap__V], _ImmutableMap__V]]) -> None: ...
    _toImmutableMap_0__T = typing.TypeVar('_toImmutableMap_0__T')  # <T>
    _toImmutableMap_0__K = typing.TypeVar('_toImmutableMap_0__K')  # <K>
    _toImmutableMap_0__V = typing.TypeVar('_toImmutableMap_0__V')  # <V>
    _toImmutableMap_1__T = typing.TypeVar('_toImmutableMap_1__T')  # <T>
    _toImmutableMap_1__K = typing.TypeVar('_toImmutableMap_1__K')  # <K>
    _toImmutableMap_1__V = typing.TypeVar('_toImmutableMap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def toImmutableMap(function: typing.Union[java.util.function.Function[_toImmutableMap_0__T, _toImmutableMap_0__K], typing.Callable[[_toImmutableMap_0__T], _toImmutableMap_0__K]], function2: typing.Union[java.util.function.Function[_toImmutableMap_0__T, _toImmutableMap_0__V], typing.Callable[[_toImmutableMap_0__T], _toImmutableMap_0__V]]) -> java.util.stream.Collector[_toImmutableMap_0__T, typing.Any, 'ImmutableMap'[_toImmutableMap_0__K, _toImmutableMap_0__V]]: ...
    @typing.overload
    @staticmethod
    def toImmutableMap(function: typing.Union[java.util.function.Function[_toImmutableMap_1__T, _toImmutableMap_1__K], typing.Callable[[_toImmutableMap_1__T], _toImmutableMap_1__K]], function2: typing.Union[java.util.function.Function[_toImmutableMap_1__T, _toImmutableMap_1__V], typing.Callable[[_toImmutableMap_1__T], _toImmutableMap_1__V]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_toImmutableMap_1__V], typing.Callable]) -> java.util.stream.Collector[_toImmutableMap_1__T, typing.Any, 'ImmutableMap'[_toImmutableMap_1__K, _toImmutableMap_1__V]]: ...
    def toString(self) -> str: ...
    def values(self) -> ImmutableCollection[_ImmutableMap__V]: ...
    class Builder(typing.Generic[_ImmutableMap__Builder__K, _ImmutableMap__Builder__V]):
        """
        Java class 'com.google.common.collect.ImmutableMap$Builder'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        def build(self) -> 'ImmutableMap'[_ImmutableMap__Builder__K, _ImmutableMap__Builder__V]: ...
        def orderEntriesByValue(self, comparator: typing.Union[java.util.Comparator[_ImmutableMap__Builder__V], typing.Callable[[_ImmutableMap__Builder__V, _ImmutableMap__Builder__V], int]]) -> 'ImmutableMap.Builder'[_ImmutableMap__Builder__K, _ImmutableMap__Builder__V]: ...
        @typing.overload
        def put(self, k: _ImmutableMap__Builder__K, v: _ImmutableMap__Builder__V) -> 'ImmutableMap.Builder'[_ImmutableMap__Builder__K, _ImmutableMap__Builder__V]: ...
        @typing.overload
        def put(self, entry: java.util.Map.Entry[_ImmutableMap__Builder__K, _ImmutableMap__Builder__V]) -> 'ImmutableMap.Builder'[_ImmutableMap__Builder__K, _ImmutableMap__Builder__V]: ...
        @typing.overload
        def putAll(self, iterable: java.lang.Iterable[java.util.Map.Entry[_ImmutableMap__Builder__K, _ImmutableMap__Builder__V]]) -> 'ImmutableMap.Builder'[_ImmutableMap__Builder__K, _ImmutableMap__Builder__V]: ...
        @typing.overload
        def putAll(self, map: typing.Union[java.util.Map[_ImmutableMap__Builder__K, _ImmutableMap__Builder__V], typing.Mapping[_ImmutableMap__Builder__K, _ImmutableMap__Builder__V]]) -> 'ImmutableMap.Builder'[_ImmutableMap__Builder__K, _ImmutableMap__Builder__V]: ...

_Interner__E = typing.TypeVar('_Interner__E')  # <E>
class Interner(typing.Generic[_Interner__E]):
    """
    Java class 'com.google.common.collect.Interner'
    
    """
    def intern(self, e: _Interner__E) -> _Interner__E: ...

class Interners:
    """
    Java class 'com.google.common.collect.Interners'
    
        Extends:
            java.lang.Object
    
    """
    _asFunction__E = typing.TypeVar('_asFunction__E')  # <E>
    @staticmethod
    def asFunction(interner: Interner[_asFunction__E]) -> com.google.common.base.Function[_asFunction__E, _asFunction__E]: ...
    @staticmethod
    def newBuilder() -> 'Interners.InternerBuilder': ...
    _newStrongInterner__E = typing.TypeVar('_newStrongInterner__E')  # <E>
    @staticmethod
    def newStrongInterner() -> Interner[_newStrongInterner__E]: ...
    _newWeakInterner__E = typing.TypeVar('_newWeakInterner__E')  # <E>
    @staticmethod
    def newWeakInterner() -> Interner[_newWeakInterner__E]: ...
    class InternerBuilder:
        """
        Java class 'com.google.common.collect.Interners$InternerBuilder'
        
            Extends:
                java.lang.Object
        
        """
        _build__E = typing.TypeVar('_build__E')  # <E>
        def build(self) -> Interner[_build__E]: ...
        def concurrencyLevel(self, int: int) -> 'Interners.InternerBuilder': ...
        def strong(self) -> 'Interners.InternerBuilder': ...
        def weak(self) -> 'Interners.InternerBuilder': ...

class Iterables:
    """
    Java class 'com.google.common.collect.Iterables'
    
        Extends:
            java.lang.Object
    
    """
    _addAll__T = typing.TypeVar('_addAll__T')  # <T>
    @staticmethod
    def addAll(collection: typing.Union[java.util.Collection[_addAll__T], typing.Sequence[_addAll__T]], iterable: java.lang.Iterable[_addAll__T]) -> bool: ...
    _all__T = typing.TypeVar('_all__T')  # <T>
    @staticmethod
    def all(iterable: java.lang.Iterable[_all__T], predicate: typing.Union[com.google.common.base.Predicate[_all__T], typing.Callable[[_all__T], bool]]) -> bool: ...
    _any__T = typing.TypeVar('_any__T')  # <T>
    @staticmethod
    def any(iterable: java.lang.Iterable[_any__T], predicate: typing.Union[com.google.common.base.Predicate[_any__T], typing.Callable[[_any__T], bool]]) -> bool: ...
    _concat_0__T = typing.TypeVar('_concat_0__T')  # <T>
    _concat_1__T = typing.TypeVar('_concat_1__T')  # <T>
    _concat_2__T = typing.TypeVar('_concat_2__T')  # <T>
    _concat_3__T = typing.TypeVar('_concat_3__T')  # <T>
    _concat_4__T = typing.TypeVar('_concat_4__T')  # <T>
    @typing.overload
    @staticmethod
    def concat(iterable: java.lang.Iterable[java.lang.Iterable[_concat_0__T]]) -> java.lang.Iterable[_concat_0__T]: ...
    @typing.overload
    @staticmethod
    def concat(iterable: java.lang.Iterable[_concat_1__T], iterable2: java.lang.Iterable[_concat_1__T]) -> java.lang.Iterable[_concat_1__T]: ...
    @typing.overload
    @staticmethod
    def concat(iterable: java.lang.Iterable[_concat_2__T], iterable2: java.lang.Iterable[_concat_2__T], iterable3: java.lang.Iterable[_concat_2__T]) -> java.lang.Iterable[_concat_2__T]: ...
    @typing.overload
    @staticmethod
    def concat(iterable: java.lang.Iterable[_concat_3__T], iterable2: java.lang.Iterable[_concat_3__T], iterable3: java.lang.Iterable[_concat_3__T], iterable4: java.lang.Iterable[_concat_3__T]) -> java.lang.Iterable[_concat_3__T]: ...
    @typing.overload
    @staticmethod
    def concat(iterableArray: typing.List[java.lang.Iterable[_concat_4__T]]) -> java.lang.Iterable[_concat_4__T]: ...
    _consumingIterable__T = typing.TypeVar('_consumingIterable__T')  # <T>
    @staticmethod
    def consumingIterable(iterable: java.lang.Iterable[_consumingIterable__T]) -> java.lang.Iterable[_consumingIterable__T]: ...
    @staticmethod
    def contains(iterable: java.lang.Iterable[typing.Any], object: typing.Any) -> bool: ...
    _cycle_0__T = typing.TypeVar('_cycle_0__T')  # <T>
    _cycle_1__T = typing.TypeVar('_cycle_1__T')  # <T>
    @typing.overload
    @staticmethod
    def cycle(iterable: java.lang.Iterable[_cycle_0__T]) -> java.lang.Iterable[_cycle_0__T]: ...
    @typing.overload
    @staticmethod
    def cycle(tArray: typing.List[_cycle_1__T]) -> java.lang.Iterable[_cycle_1__T]: ...
    @staticmethod
    def elementsEqual(iterable: java.lang.Iterable[typing.Any], iterable2: java.lang.Iterable[typing.Any]) -> bool: ...
    _filter_0__T = typing.TypeVar('_filter_0__T')  # <T>
    _filter_1__T = typing.TypeVar('_filter_1__T')  # <T>
    @typing.overload
    @staticmethod
    def filter(iterable: java.lang.Iterable[_filter_0__T], predicate: typing.Union[com.google.common.base.Predicate[_filter_0__T], typing.Callable[[_filter_0__T], bool]]) -> java.lang.Iterable[_filter_0__T]: ...
    @typing.overload
    @staticmethod
    def filter(iterable: java.lang.Iterable[typing.Any], class_: typing.Type[_filter_1__T]) -> java.lang.Iterable[_filter_1__T]: ...
    _find_0__T = typing.TypeVar('_find_0__T')  # <T>
    _find_1__T = typing.TypeVar('_find_1__T')  # <T>
    @typing.overload
    @staticmethod
    def find(iterable: java.lang.Iterable[_find_0__T], predicate: typing.Union[com.google.common.base.Predicate[_find_0__T], typing.Callable[[_find_0__T], bool]]) -> _find_0__T: ...
    @typing.overload
    @staticmethod
    def find(iterable: java.lang.Iterable[_find_1__T], predicate: typing.Union[com.google.common.base.Predicate[_find_1__T], typing.Callable[[_find_1__T], bool]], t: _find_1__T) -> _find_1__T: ...
    @staticmethod
    def frequency(iterable: java.lang.Iterable[typing.Any], object: typing.Any) -> int: ...
    _get_0__T = typing.TypeVar('_get_0__T')  # <T>
    _get_1__T = typing.TypeVar('_get_1__T')  # <T>
    @typing.overload
    @staticmethod
    def get(iterable: java.lang.Iterable[_get_0__T], int: int) -> _get_0__T: ...
    @typing.overload
    @staticmethod
    def get(iterable: java.lang.Iterable[_get_1__T], int: int, t: _get_1__T) -> _get_1__T: ...
    _getFirst__T = typing.TypeVar('_getFirst__T')  # <T>
    @staticmethod
    def getFirst(iterable: java.lang.Iterable[_getFirst__T], t: _getFirst__T) -> _getFirst__T: ...
    _getLast_0__T = typing.TypeVar('_getLast_0__T')  # <T>
    _getLast_1__T = typing.TypeVar('_getLast_1__T')  # <T>
    @typing.overload
    @staticmethod
    def getLast(iterable: java.lang.Iterable[_getLast_0__T]) -> _getLast_0__T: ...
    @typing.overload
    @staticmethod
    def getLast(iterable: java.lang.Iterable[_getLast_1__T], t: _getLast_1__T) -> _getLast_1__T: ...
    _getOnlyElement_0__T = typing.TypeVar('_getOnlyElement_0__T')  # <T>
    _getOnlyElement_1__T = typing.TypeVar('_getOnlyElement_1__T')  # <T>
    @typing.overload
    @staticmethod
    def getOnlyElement(iterable: java.lang.Iterable[_getOnlyElement_0__T]) -> _getOnlyElement_0__T: ...
    @typing.overload
    @staticmethod
    def getOnlyElement(iterable: java.lang.Iterable[_getOnlyElement_1__T], t: _getOnlyElement_1__T) -> _getOnlyElement_1__T: ...
    _indexOf__T = typing.TypeVar('_indexOf__T')  # <T>
    @staticmethod
    def indexOf(iterable: java.lang.Iterable[_indexOf__T], predicate: typing.Union[com.google.common.base.Predicate[_indexOf__T], typing.Callable[[_indexOf__T], bool]]) -> int: ...
    @staticmethod
    def isEmpty(iterable: java.lang.Iterable[typing.Any]) -> bool: ...
    _limit__T = typing.TypeVar('_limit__T')  # <T>
    @staticmethod
    def limit(iterable: java.lang.Iterable[_limit__T], int: int) -> java.lang.Iterable[_limit__T]: ...
    _mergeSorted__T = typing.TypeVar('_mergeSorted__T')  # <T>
    @staticmethod
    def mergeSorted(iterable: java.lang.Iterable[java.lang.Iterable[_mergeSorted__T]], comparator: typing.Union[java.util.Comparator[_mergeSorted__T], typing.Callable[[_mergeSorted__T, _mergeSorted__T], int]]) -> java.lang.Iterable[_mergeSorted__T]: ...
    _paddedPartition__T = typing.TypeVar('_paddedPartition__T')  # <T>
    @staticmethod
    def paddedPartition(iterable: java.lang.Iterable[_paddedPartition__T], int: int) -> java.lang.Iterable[java.util.List[_paddedPartition__T]]: ...
    _partition__T = typing.TypeVar('_partition__T')  # <T>
    @staticmethod
    def partition(iterable: java.lang.Iterable[_partition__T], int: int) -> java.lang.Iterable[java.util.List[_partition__T]]: ...
    @staticmethod
    def removeAll(iterable: java.lang.Iterable[typing.Any], collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    _removeIf__T = typing.TypeVar('_removeIf__T')  # <T>
    @staticmethod
    def removeIf(iterable: java.lang.Iterable[_removeIf__T], predicate: typing.Union[com.google.common.base.Predicate[_removeIf__T], typing.Callable[[_removeIf__T], bool]]) -> bool: ...
    @staticmethod
    def retainAll(iterable: java.lang.Iterable[typing.Any], collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    @staticmethod
    def size(iterable: java.lang.Iterable[typing.Any]) -> int: ...
    _skip__T = typing.TypeVar('_skip__T')  # <T>
    @staticmethod
    def skip(iterable: java.lang.Iterable[_skip__T], int: int) -> java.lang.Iterable[_skip__T]: ...
    _toArray__T = typing.TypeVar('_toArray__T')  # <T>
    @staticmethod
    def toArray(iterable: java.lang.Iterable[_toArray__T], class_: typing.Type[_toArray__T]) -> typing.List[_toArray__T]: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(iterable: java.lang.Iterable[typing.Any]) -> str: ...
    _transform__F = typing.TypeVar('_transform__F')  # <F>
    _transform__T = typing.TypeVar('_transform__T')  # <T>
    @staticmethod
    def transform(iterable: java.lang.Iterable[_transform__F], function: typing.Union[com.google.common.base.Function[_transform__F, _transform__T], typing.Callable[[_transform__F], _transform__T]]) -> java.lang.Iterable[_transform__T]: ...
    _tryFind__T = typing.TypeVar('_tryFind__T')  # <T>
    @staticmethod
    def tryFind(iterable: java.lang.Iterable[_tryFind__T], predicate: typing.Union[com.google.common.base.Predicate[_tryFind__T], typing.Callable[[_tryFind__T], bool]]) -> com.google.common.base.Optional[_tryFind__T]: ...
    _unmodifiableIterable_0__E = typing.TypeVar('_unmodifiableIterable_0__E')  # <E>
    _unmodifiableIterable_1__T = typing.TypeVar('_unmodifiableIterable_1__T')  # <T>
    @typing.overload
    @staticmethod
    def unmodifiableIterable(immutableCollection: ImmutableCollection[_unmodifiableIterable_0__E]) -> java.lang.Iterable[_unmodifiableIterable_0__E]: ...
    @typing.overload
    @staticmethod
    def unmodifiableIterable(iterable: java.lang.Iterable[_unmodifiableIterable_1__T]) -> java.lang.Iterable[_unmodifiableIterable_1__T]: ...

class Iterators:
    """
    Java class 'com.google.common.collect.Iterators'
    
        Extends:
            java.lang.Object
    
    """
    _addAll__T = typing.TypeVar('_addAll__T')  # <T>
    @staticmethod
    def addAll(collection: typing.Union[java.util.Collection[_addAll__T], typing.Sequence[_addAll__T]], iterator: java.util.Iterator[_addAll__T]) -> bool: ...
    @staticmethod
    def advance(iterator: java.util.Iterator[typing.Any], int: int) -> int: ...
    _all__T = typing.TypeVar('_all__T')  # <T>
    @staticmethod
    def all(iterator: java.util.Iterator[_all__T], predicate: typing.Union[com.google.common.base.Predicate[_all__T], typing.Callable[[_all__T], bool]]) -> bool: ...
    _any__T = typing.TypeVar('_any__T')  # <T>
    @staticmethod
    def any(iterator: java.util.Iterator[_any__T], predicate: typing.Union[com.google.common.base.Predicate[_any__T], typing.Callable[[_any__T], bool]]) -> bool: ...
    _asEnumeration__T = typing.TypeVar('_asEnumeration__T')  # <T>
    @staticmethod
    def asEnumeration(iterator: java.util.Iterator[_asEnumeration__T]) -> java.util.Enumeration[_asEnumeration__T]: ...
    _concat_0__T = typing.TypeVar('_concat_0__T')  # <T>
    _concat_1__T = typing.TypeVar('_concat_1__T')  # <T>
    _concat_2__T = typing.TypeVar('_concat_2__T')  # <T>
    _concat_3__T = typing.TypeVar('_concat_3__T')  # <T>
    _concat_4__T = typing.TypeVar('_concat_4__T')  # <T>
    @typing.overload
    @staticmethod
    def concat(iterator: java.util.Iterator[java.util.Iterator[_concat_0__T]]) -> java.util.Iterator[_concat_0__T]: ...
    @typing.overload
    @staticmethod
    def concat(iterator: java.util.Iterator[_concat_1__T], iterator2: java.util.Iterator[_concat_1__T]) -> java.util.Iterator[_concat_1__T]: ...
    @typing.overload
    @staticmethod
    def concat(iterator: java.util.Iterator[_concat_2__T], iterator2: java.util.Iterator[_concat_2__T], iterator3: java.util.Iterator[_concat_2__T]) -> java.util.Iterator[_concat_2__T]: ...
    @typing.overload
    @staticmethod
    def concat(iterator: java.util.Iterator[_concat_3__T], iterator2: java.util.Iterator[_concat_3__T], iterator3: java.util.Iterator[_concat_3__T], iterator4: java.util.Iterator[_concat_3__T]) -> java.util.Iterator[_concat_3__T]: ...
    @typing.overload
    @staticmethod
    def concat(iteratorArray: typing.List[java.util.Iterator[_concat_4__T]]) -> java.util.Iterator[_concat_4__T]: ...
    _consumingIterator__T = typing.TypeVar('_consumingIterator__T')  # <T>
    @staticmethod
    def consumingIterator(iterator: java.util.Iterator[_consumingIterator__T]) -> java.util.Iterator[_consumingIterator__T]: ...
    @staticmethod
    def contains(iterator: java.util.Iterator[typing.Any], object: typing.Any) -> bool: ...
    _cycle_0__T = typing.TypeVar('_cycle_0__T')  # <T>
    _cycle_1__T = typing.TypeVar('_cycle_1__T')  # <T>
    @typing.overload
    @staticmethod
    def cycle(iterable: java.lang.Iterable[_cycle_0__T]) -> java.util.Iterator[_cycle_0__T]: ...
    @typing.overload
    @staticmethod
    def cycle(tArray: typing.List[_cycle_1__T]) -> java.util.Iterator[_cycle_1__T]: ...
    @staticmethod
    def elementsEqual(iterator: java.util.Iterator[typing.Any], iterator2: java.util.Iterator[typing.Any]) -> bool: ...
    _filter_0__T = typing.TypeVar('_filter_0__T')  # <T>
    _filter_1__T = typing.TypeVar('_filter_1__T')  # <T>
    @typing.overload
    @staticmethod
    def filter(iterator: java.util.Iterator[_filter_0__T], predicate: typing.Union[com.google.common.base.Predicate[_filter_0__T], typing.Callable[[_filter_0__T], bool]]) -> 'UnmodifiableIterator'[_filter_0__T]: ...
    @typing.overload
    @staticmethod
    def filter(iterator: java.util.Iterator[typing.Any], class_: typing.Type[_filter_1__T]) -> 'UnmodifiableIterator'[_filter_1__T]: ...
    _find_0__T = typing.TypeVar('_find_0__T')  # <T>
    _find_1__T = typing.TypeVar('_find_1__T')  # <T>
    @typing.overload
    @staticmethod
    def find(iterator: java.util.Iterator[_find_0__T], predicate: typing.Union[com.google.common.base.Predicate[_find_0__T], typing.Callable[[_find_0__T], bool]]) -> _find_0__T: ...
    @typing.overload
    @staticmethod
    def find(iterator: java.util.Iterator[_find_1__T], predicate: typing.Union[com.google.common.base.Predicate[_find_1__T], typing.Callable[[_find_1__T], bool]], t: _find_1__T) -> _find_1__T: ...
    _forArray__T = typing.TypeVar('_forArray__T')  # <T>
    @staticmethod
    def forArray(tArray: typing.List[_forArray__T]) -> 'UnmodifiableIterator'[_forArray__T]: ...
    _forEnumeration__T = typing.TypeVar('_forEnumeration__T')  # <T>
    @staticmethod
    def forEnumeration(enumeration: java.util.Enumeration[_forEnumeration__T]) -> 'UnmodifiableIterator'[_forEnumeration__T]: ...
    @staticmethod
    def frequency(iterator: java.util.Iterator[typing.Any], object: typing.Any) -> int: ...
    _get_0__T = typing.TypeVar('_get_0__T')  # <T>
    _get_1__T = typing.TypeVar('_get_1__T')  # <T>
    @typing.overload
    @staticmethod
    def get(iterator: java.util.Iterator[_get_0__T], int: int) -> _get_0__T: ...
    @typing.overload
    @staticmethod
    def get(iterator: java.util.Iterator[_get_1__T], int: int, t: _get_1__T) -> _get_1__T: ...
    _getLast_0__T = typing.TypeVar('_getLast_0__T')  # <T>
    _getLast_1__T = typing.TypeVar('_getLast_1__T')  # <T>
    @typing.overload
    @staticmethod
    def getLast(iterator: java.util.Iterator[_getLast_0__T]) -> _getLast_0__T: ...
    @typing.overload
    @staticmethod
    def getLast(iterator: java.util.Iterator[_getLast_1__T], t: _getLast_1__T) -> _getLast_1__T: ...
    _getNext__T = typing.TypeVar('_getNext__T')  # <T>
    @staticmethod
    def getNext(iterator: java.util.Iterator[_getNext__T], t: _getNext__T) -> _getNext__T: ...
    _getOnlyElement_0__T = typing.TypeVar('_getOnlyElement_0__T')  # <T>
    _getOnlyElement_1__T = typing.TypeVar('_getOnlyElement_1__T')  # <T>
    @typing.overload
    @staticmethod
    def getOnlyElement(iterator: java.util.Iterator[_getOnlyElement_0__T]) -> _getOnlyElement_0__T: ...
    @typing.overload
    @staticmethod
    def getOnlyElement(iterator: java.util.Iterator[_getOnlyElement_1__T], t: _getOnlyElement_1__T) -> _getOnlyElement_1__T: ...
    _indexOf__T = typing.TypeVar('_indexOf__T')  # <T>
    @staticmethod
    def indexOf(iterator: java.util.Iterator[_indexOf__T], predicate: typing.Union[com.google.common.base.Predicate[_indexOf__T], typing.Callable[[_indexOf__T], bool]]) -> int: ...
    _limit__T = typing.TypeVar('_limit__T')  # <T>
    @staticmethod
    def limit(iterator: java.util.Iterator[_limit__T], int: int) -> java.util.Iterator[_limit__T]: ...
    _mergeSorted__T = typing.TypeVar('_mergeSorted__T')  # <T>
    @staticmethod
    def mergeSorted(iterable: java.lang.Iterable[java.util.Iterator[_mergeSorted__T]], comparator: typing.Union[java.util.Comparator[_mergeSorted__T], typing.Callable[[_mergeSorted__T, _mergeSorted__T], int]]) -> 'UnmodifiableIterator'[_mergeSorted__T]: ...
    _paddedPartition__T = typing.TypeVar('_paddedPartition__T')  # <T>
    @staticmethod
    def paddedPartition(iterator: java.util.Iterator[_paddedPartition__T], int: int) -> 'UnmodifiableIterator'[java.util.List[_paddedPartition__T]]: ...
    _partition__T = typing.TypeVar('_partition__T')  # <T>
    @staticmethod
    def partition(iterator: java.util.Iterator[_partition__T], int: int) -> 'UnmodifiableIterator'[java.util.List[_partition__T]]: ...
    _peekingIterator_0__T = typing.TypeVar('_peekingIterator_0__T')  # <T>
    _peekingIterator_1__T = typing.TypeVar('_peekingIterator_1__T')  # <T>
    @typing.overload
    @staticmethod
    def peekingIterator(peekingIterator: 'PeekingIterator'[_peekingIterator_0__T]) -> 'PeekingIterator'[_peekingIterator_0__T]: ...
    @typing.overload
    @staticmethod
    def peekingIterator(iterator: java.util.Iterator[_peekingIterator_1__T]) -> 'PeekingIterator'[_peekingIterator_1__T]: ...
    @staticmethod
    def removeAll(iterator: java.util.Iterator[typing.Any], collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    _removeIf__T = typing.TypeVar('_removeIf__T')  # <T>
    @staticmethod
    def removeIf(iterator: java.util.Iterator[_removeIf__T], predicate: typing.Union[com.google.common.base.Predicate[_removeIf__T], typing.Callable[[_removeIf__T], bool]]) -> bool: ...
    @staticmethod
    def retainAll(iterator: java.util.Iterator[typing.Any], collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    _singletonIterator__T = typing.TypeVar('_singletonIterator__T')  # <T>
    @staticmethod
    def singletonIterator(t: _singletonIterator__T) -> 'UnmodifiableIterator'[_singletonIterator__T]: ...
    @staticmethod
    def size(iterator: java.util.Iterator[typing.Any]) -> int: ...
    _toArray__T = typing.TypeVar('_toArray__T')  # <T>
    @staticmethod
    def toArray(iterator: java.util.Iterator[_toArray__T], class_: typing.Type[_toArray__T]) -> typing.List[_toArray__T]: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(iterator: java.util.Iterator[typing.Any]) -> str: ...
    _transform__F = typing.TypeVar('_transform__F')  # <F>
    _transform__T = typing.TypeVar('_transform__T')  # <T>
    @staticmethod
    def transform(iterator: java.util.Iterator[_transform__F], function: typing.Union[com.google.common.base.Function[_transform__F, _transform__T], typing.Callable[[_transform__F], _transform__T]]) -> java.util.Iterator[_transform__T]: ...
    _tryFind__T = typing.TypeVar('_tryFind__T')  # <T>
    @staticmethod
    def tryFind(iterator: java.util.Iterator[_tryFind__T], predicate: typing.Union[com.google.common.base.Predicate[_tryFind__T], typing.Callable[[_tryFind__T], bool]]) -> com.google.common.base.Optional[_tryFind__T]: ...
    _unmodifiableIterator_0__T = typing.TypeVar('_unmodifiableIterator_0__T')  # <T>
    _unmodifiableIterator_1__T = typing.TypeVar('_unmodifiableIterator_1__T')  # <T>
    @typing.overload
    @staticmethod
    def unmodifiableIterator(unmodifiableIterator: 'UnmodifiableIterator'[_unmodifiableIterator_0__T]) -> 'UnmodifiableIterator'[_unmodifiableIterator_0__T]: ...
    @typing.overload
    @staticmethod
    def unmodifiableIterator(iterator: java.util.Iterator[_unmodifiableIterator_1__T]) -> 'UnmodifiableIterator'[_unmodifiableIterator_1__T]: ...

class Lists:
    """
    Java class 'com.google.common.collect.Lists'
    
        Extends:
            java.lang.Object
    
    """
    _asList_0__E = typing.TypeVar('_asList_0__E')  # <E>
    _asList_1__E = typing.TypeVar('_asList_1__E')  # <E>
    @typing.overload
    @staticmethod
    def asList(e: _asList_0__E, e2: _asList_0__E, eArray: typing.List[_asList_0__E]) -> java.util.List[_asList_0__E]: ...
    @typing.overload
    @staticmethod
    def asList(e: _asList_1__E, eArray: typing.List[_asList_1__E]) -> java.util.List[_asList_1__E]: ...
    _cartesianProduct_0__B = typing.TypeVar('_cartesianProduct_0__B')  # <B>
    _cartesianProduct_1__B = typing.TypeVar('_cartesianProduct_1__B')  # <B>
    @typing.overload
    @staticmethod
    def cartesianProduct(list: java.util.List[java.util.List[_cartesianProduct_0__B]]) -> java.util.List[java.util.List[_cartesianProduct_0__B]]: ...
    @typing.overload
    @staticmethod
    def cartesianProduct(listArray: typing.List[java.util.List[_cartesianProduct_1__B]]) -> java.util.List[java.util.List[_cartesianProduct_1__B]]: ...
    @typing.overload
    @staticmethod
    def charactersOf(string: str) -> 'ImmutableList'[str]: ...
    @typing.overload
    @staticmethod
    def charactersOf(charSequence: typing.Union[java.lang.CharSequence, str]) -> java.util.List[str]: ...
    _newArrayList_0__E = typing.TypeVar('_newArrayList_0__E')  # <E>
    _newArrayList_1__E = typing.TypeVar('_newArrayList_1__E')  # <E>
    _newArrayList_2__E = typing.TypeVar('_newArrayList_2__E')  # <E>
    _newArrayList_3__E = typing.TypeVar('_newArrayList_3__E')  # <E>
    @typing.overload
    @staticmethod
    def newArrayList() -> java.util.ArrayList[_newArrayList_0__E]: ...
    @typing.overload
    @staticmethod
    def newArrayList(iterable: java.lang.Iterable[_newArrayList_1__E]) -> java.util.ArrayList[_newArrayList_1__E]: ...
    @typing.overload
    @staticmethod
    def newArrayList(eArray: typing.List[_newArrayList_2__E]) -> java.util.ArrayList[_newArrayList_2__E]: ...
    @typing.overload
    @staticmethod
    def newArrayList(iterator: java.util.Iterator[_newArrayList_3__E]) -> java.util.ArrayList[_newArrayList_3__E]: ...
    _newArrayListWithCapacity__E = typing.TypeVar('_newArrayListWithCapacity__E')  # <E>
    @staticmethod
    def newArrayListWithCapacity(int: int) -> java.util.ArrayList[_newArrayListWithCapacity__E]: ...
    _newArrayListWithExpectedSize__E = typing.TypeVar('_newArrayListWithExpectedSize__E')  # <E>
    @staticmethod
    def newArrayListWithExpectedSize(int: int) -> java.util.ArrayList[_newArrayListWithExpectedSize__E]: ...
    _newCopyOnWriteArrayList_0__E = typing.TypeVar('_newCopyOnWriteArrayList_0__E')  # <E>
    _newCopyOnWriteArrayList_1__E = typing.TypeVar('_newCopyOnWriteArrayList_1__E')  # <E>
    @typing.overload
    @staticmethod
    def newCopyOnWriteArrayList() -> java.util.concurrent.CopyOnWriteArrayList[_newCopyOnWriteArrayList_0__E]: ...
    @typing.overload
    @staticmethod
    def newCopyOnWriteArrayList(iterable: java.lang.Iterable[_newCopyOnWriteArrayList_1__E]) -> java.util.concurrent.CopyOnWriteArrayList[_newCopyOnWriteArrayList_1__E]: ...
    _newLinkedList_0__E = typing.TypeVar('_newLinkedList_0__E')  # <E>
    _newLinkedList_1__E = typing.TypeVar('_newLinkedList_1__E')  # <E>
    @typing.overload
    @staticmethod
    def newLinkedList() -> java.util.LinkedList[_newLinkedList_0__E]: ...
    @typing.overload
    @staticmethod
    def newLinkedList(iterable: java.lang.Iterable[_newLinkedList_1__E]) -> java.util.LinkedList[_newLinkedList_1__E]: ...
    _partition__T = typing.TypeVar('_partition__T')  # <T>
    @staticmethod
    def partition(list: java.util.List[_partition__T], int: int) -> java.util.List[java.util.List[_partition__T]]: ...
    _reverse__T = typing.TypeVar('_reverse__T')  # <T>
    @staticmethod
    def reverse(list: java.util.List[_reverse__T]) -> java.util.List[_reverse__T]: ...
    _transform__F = typing.TypeVar('_transform__F')  # <F>
    _transform__T = typing.TypeVar('_transform__T')  # <T>
    @staticmethod
    def transform(list: java.util.List[_transform__F], function: typing.Union[com.google.common.base.Function[_transform__F, _transform__T], typing.Callable[[_transform__F], _transform__T]]) -> java.util.List[_transform__T]: ...

_MapDifference__ValueDifference__V = typing.TypeVar('_MapDifference__ValueDifference__V')  # <V>
_MapDifference__K = typing.TypeVar('_MapDifference__K')  # <K>
_MapDifference__V = typing.TypeVar('_MapDifference__V')  # <V>
class MapDifference(typing.Generic[_MapDifference__K, _MapDifference__V]):
    """
    Java class 'com.google.common.collect.MapDifference'
    
    """
    def areEqual(self) -> bool: ...
    def entriesDiffering(self) -> java.util.Map[_MapDifference__K, 'MapDifference.ValueDifference'[_MapDifference__V]]: ...
    def entriesInCommon(self) -> java.util.Map[_MapDifference__K, _MapDifference__V]: ...
    def entriesOnlyOnLeft(self) -> java.util.Map[_MapDifference__K, _MapDifference__V]: ...
    def entriesOnlyOnRight(self) -> java.util.Map[_MapDifference__K, _MapDifference__V]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    class ValueDifference(typing.Generic[_MapDifference__ValueDifference__V]):
        """
        Java class 'com.google.common.collect.MapDifference$ValueDifference'
        
        """
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def leftValue(self) -> _MapDifference__ValueDifference__V: ...
        def rightValue(self) -> _MapDifference__ValueDifference__V: ...

class MapMaker:
    """
    Java class 'com.google.common.collect.MapMaker'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * MapMaker()
    
    """
    def __init__(self): ...
    def concurrencyLevel(self, int: int) -> 'MapMaker': ...
    def initialCapacity(self, int: int) -> 'MapMaker': ...
    _makeMap__K = typing.TypeVar('_makeMap__K')  # <K>
    _makeMap__V = typing.TypeVar('_makeMap__V')  # <V>
    def makeMap(self) -> java.util.concurrent.ConcurrentMap[_makeMap__K, _makeMap__V]: ...
    def toString(self) -> str: ...
    def weakKeys(self) -> 'MapMaker': ...
    def weakValues(self) -> 'MapMaker': ...

_Maps__EntryTransformer__K = typing.TypeVar('_Maps__EntryTransformer__K')  # <K>
_Maps__EntryTransformer__V1 = typing.TypeVar('_Maps__EntryTransformer__V1')  # <V1>
_Maps__EntryTransformer__V2 = typing.TypeVar('_Maps__EntryTransformer__V2')  # <V2>
class Maps:
    """
    Java class 'com.google.common.collect.Maps'
    
        Extends:
            java.lang.Object
    
    """
    _asConverter__A = typing.TypeVar('_asConverter__A')  # <A>
    _asConverter__B = typing.TypeVar('_asConverter__B')  # <B>
    @staticmethod
    def asConverter(biMap: BiMap[_asConverter__A, _asConverter__B]) -> com.google.common.base.Converter[_asConverter__A, _asConverter__B]: ...
    _asMap_0__K = typing.TypeVar('_asMap_0__K')  # <K>
    _asMap_0__V = typing.TypeVar('_asMap_0__V')  # <V>
    _asMap_1__K = typing.TypeVar('_asMap_1__K')  # <K>
    _asMap_1__V = typing.TypeVar('_asMap_1__V')  # <V>
    _asMap_2__K = typing.TypeVar('_asMap_2__K')  # <K>
    _asMap_2__V = typing.TypeVar('_asMap_2__V')  # <V>
    @typing.overload
    @staticmethod
    def asMap(set: java.util.Set[_asMap_0__K], function: typing.Union[com.google.common.base.Function[_asMap_0__K, _asMap_0__V], typing.Callable[[_asMap_0__K], _asMap_0__V]]) -> java.util.Map[_asMap_0__K, _asMap_0__V]: ...
    @typing.overload
    @staticmethod
    def asMap(navigableSet: java.util.NavigableSet[_asMap_1__K], function: typing.Union[com.google.common.base.Function[_asMap_1__K, _asMap_1__V], typing.Callable[[_asMap_1__K], _asMap_1__V]]) -> java.util.NavigableMap[_asMap_1__K, _asMap_1__V]: ...
    @typing.overload
    @staticmethod
    def asMap(sortedSet: java.util.SortedSet[_asMap_2__K], function: typing.Union[com.google.common.base.Function[_asMap_2__K, _asMap_2__V], typing.Callable[[_asMap_2__K], _asMap_2__V]]) -> java.util.SortedMap[_asMap_2__K, _asMap_2__V]: ...
    _difference_0__K = typing.TypeVar('_difference_0__K')  # <K>
    _difference_0__V = typing.TypeVar('_difference_0__V')  # <V>
    _difference_1__K = typing.TypeVar('_difference_1__K')  # <K>
    _difference_1__V = typing.TypeVar('_difference_1__V')  # <V>
    _difference_2__K = typing.TypeVar('_difference_2__K')  # <K>
    _difference_2__V = typing.TypeVar('_difference_2__V')  # <V>
    @typing.overload
    @staticmethod
    def difference(map: typing.Union[java.util.Map[_difference_0__K, _difference_0__V], typing.Mapping[_difference_0__K, _difference_0__V]], map2: typing.Union[java.util.Map[_difference_0__K, _difference_0__V], typing.Mapping[_difference_0__K, _difference_0__V]]) -> MapDifference[_difference_0__K, _difference_0__V]: ...
    @typing.overload
    @staticmethod
    def difference(map: typing.Union[java.util.Map[_difference_1__K, _difference_1__V], typing.Mapping[_difference_1__K, _difference_1__V]], map2: typing.Union[java.util.Map[_difference_1__K, _difference_1__V], typing.Mapping[_difference_1__K, _difference_1__V]], equivalence: com.google.common.base.Equivalence[_difference_1__V]) -> MapDifference[_difference_1__K, _difference_1__V]: ...
    @typing.overload
    @staticmethod
    def difference(sortedMap: java.util.SortedMap[_difference_2__K, _difference_2__V], map: typing.Union[java.util.Map[_difference_2__K, _difference_2__V], typing.Mapping[_difference_2__K, _difference_2__V]]) -> 'SortedMapDifference'[_difference_2__K, _difference_2__V]: ...
    _filterEntries_0__K = typing.TypeVar('_filterEntries_0__K')  # <K>
    _filterEntries_0__V = typing.TypeVar('_filterEntries_0__V')  # <V>
    _filterEntries_1__K = typing.TypeVar('_filterEntries_1__K')  # <K>
    _filterEntries_1__V = typing.TypeVar('_filterEntries_1__V')  # <V>
    _filterEntries_2__K = typing.TypeVar('_filterEntries_2__K')  # <K>
    _filterEntries_2__V = typing.TypeVar('_filterEntries_2__V')  # <V>
    _filterEntries_3__K = typing.TypeVar('_filterEntries_3__K')  # <K>
    _filterEntries_3__V = typing.TypeVar('_filterEntries_3__V')  # <V>
    @typing.overload
    @staticmethod
    def filterEntries(biMap: BiMap[_filterEntries_0__K, _filterEntries_0__V], predicate: typing.Union[com.google.common.base.Predicate[java.util.Map.Entry[_filterEntries_0__K, _filterEntries_0__V]], typing.Callable[[java.util.Map.Entry[_filterEntries_0__K, _filterEntries_0__V]], bool]]) -> BiMap[_filterEntries_0__K, _filterEntries_0__V]: ...
    @typing.overload
    @staticmethod
    def filterEntries(map: typing.Union[java.util.Map[_filterEntries_1__K, _filterEntries_1__V], typing.Mapping[_filterEntries_1__K, _filterEntries_1__V]], predicate: typing.Union[com.google.common.base.Predicate[java.util.Map.Entry[_filterEntries_1__K, _filterEntries_1__V]], typing.Callable[[java.util.Map.Entry[_filterEntries_1__K, _filterEntries_1__V]], bool]]) -> java.util.Map[_filterEntries_1__K, _filterEntries_1__V]: ...
    @typing.overload
    @staticmethod
    def filterEntries(navigableMap: java.util.NavigableMap[_filterEntries_2__K, _filterEntries_2__V], predicate: typing.Union[com.google.common.base.Predicate[java.util.Map.Entry[_filterEntries_2__K, _filterEntries_2__V]], typing.Callable[[java.util.Map.Entry[_filterEntries_2__K, _filterEntries_2__V]], bool]]) -> java.util.NavigableMap[_filterEntries_2__K, _filterEntries_2__V]: ...
    @typing.overload
    @staticmethod
    def filterEntries(sortedMap: java.util.SortedMap[_filterEntries_3__K, _filterEntries_3__V], predicate: typing.Union[com.google.common.base.Predicate[java.util.Map.Entry[_filterEntries_3__K, _filterEntries_3__V]], typing.Callable[[java.util.Map.Entry[_filterEntries_3__K, _filterEntries_3__V]], bool]]) -> java.util.SortedMap[_filterEntries_3__K, _filterEntries_3__V]: ...
    _filterKeys_0__K = typing.TypeVar('_filterKeys_0__K')  # <K>
    _filterKeys_0__V = typing.TypeVar('_filterKeys_0__V')  # <V>
    _filterKeys_1__K = typing.TypeVar('_filterKeys_1__K')  # <K>
    _filterKeys_1__V = typing.TypeVar('_filterKeys_1__V')  # <V>
    _filterKeys_2__K = typing.TypeVar('_filterKeys_2__K')  # <K>
    _filterKeys_2__V = typing.TypeVar('_filterKeys_2__V')  # <V>
    _filterKeys_3__K = typing.TypeVar('_filterKeys_3__K')  # <K>
    _filterKeys_3__V = typing.TypeVar('_filterKeys_3__V')  # <V>
    @typing.overload
    @staticmethod
    def filterKeys(biMap: BiMap[_filterKeys_0__K, _filterKeys_0__V], predicate: typing.Union[com.google.common.base.Predicate[_filterKeys_0__K], typing.Callable[[_filterKeys_0__K], bool]]) -> BiMap[_filterKeys_0__K, _filterKeys_0__V]: ...
    @typing.overload
    @staticmethod
    def filterKeys(map: typing.Union[java.util.Map[_filterKeys_1__K, _filterKeys_1__V], typing.Mapping[_filterKeys_1__K, _filterKeys_1__V]], predicate: typing.Union[com.google.common.base.Predicate[_filterKeys_1__K], typing.Callable[[_filterKeys_1__K], bool]]) -> java.util.Map[_filterKeys_1__K, _filterKeys_1__V]: ...
    @typing.overload
    @staticmethod
    def filterKeys(navigableMap: java.util.NavigableMap[_filterKeys_2__K, _filterKeys_2__V], predicate: typing.Union[com.google.common.base.Predicate[_filterKeys_2__K], typing.Callable[[_filterKeys_2__K], bool]]) -> java.util.NavigableMap[_filterKeys_2__K, _filterKeys_2__V]: ...
    @typing.overload
    @staticmethod
    def filterKeys(sortedMap: java.util.SortedMap[_filterKeys_3__K, _filterKeys_3__V], predicate: typing.Union[com.google.common.base.Predicate[_filterKeys_3__K], typing.Callable[[_filterKeys_3__K], bool]]) -> java.util.SortedMap[_filterKeys_3__K, _filterKeys_3__V]: ...
    _filterValues_0__K = typing.TypeVar('_filterValues_0__K')  # <K>
    _filterValues_0__V = typing.TypeVar('_filterValues_0__V')  # <V>
    _filterValues_1__K = typing.TypeVar('_filterValues_1__K')  # <K>
    _filterValues_1__V = typing.TypeVar('_filterValues_1__V')  # <V>
    _filterValues_2__K = typing.TypeVar('_filterValues_2__K')  # <K>
    _filterValues_2__V = typing.TypeVar('_filterValues_2__V')  # <V>
    _filterValues_3__K = typing.TypeVar('_filterValues_3__K')  # <K>
    _filterValues_3__V = typing.TypeVar('_filterValues_3__V')  # <V>
    @typing.overload
    @staticmethod
    def filterValues(biMap: BiMap[_filterValues_0__K, _filterValues_0__V], predicate: typing.Union[com.google.common.base.Predicate[_filterValues_0__V], typing.Callable[[_filterValues_0__V], bool]]) -> BiMap[_filterValues_0__K, _filterValues_0__V]: ...
    @typing.overload
    @staticmethod
    def filterValues(map: typing.Union[java.util.Map[_filterValues_1__K, _filterValues_1__V], typing.Mapping[_filterValues_1__K, _filterValues_1__V]], predicate: typing.Union[com.google.common.base.Predicate[_filterValues_1__V], typing.Callable[[_filterValues_1__V], bool]]) -> java.util.Map[_filterValues_1__K, _filterValues_1__V]: ...
    @typing.overload
    @staticmethod
    def filterValues(navigableMap: java.util.NavigableMap[_filterValues_2__K, _filterValues_2__V], predicate: typing.Union[com.google.common.base.Predicate[_filterValues_2__V], typing.Callable[[_filterValues_2__V], bool]]) -> java.util.NavigableMap[_filterValues_2__K, _filterValues_2__V]: ...
    @typing.overload
    @staticmethod
    def filterValues(sortedMap: java.util.SortedMap[_filterValues_3__K, _filterValues_3__V], predicate: typing.Union[com.google.common.base.Predicate[_filterValues_3__V], typing.Callable[[_filterValues_3__V], bool]]) -> java.util.SortedMap[_filterValues_3__K, _filterValues_3__V]: ...
    @staticmethod
    def fromProperties(properties: java.util.Properties) -> ImmutableMap[str, str]: ...
    _immutableEntry__K = typing.TypeVar('_immutableEntry__K')  # <K>
    _immutableEntry__V = typing.TypeVar('_immutableEntry__V')  # <V>
    @staticmethod
    def immutableEntry(k: _immutableEntry__K, v: _immutableEntry__V) -> java.util.Map.Entry[_immutableEntry__K, _immutableEntry__V]: ...
    _immutableEnumMap__K = typing.TypeVar('_immutableEnumMap__K', bound=java.lang.Enum)  # <K>
    _immutableEnumMap__V = typing.TypeVar('_immutableEnumMap__V')  # <V>
    @staticmethod
    def immutableEnumMap(map: typing.Union[java.util.Map[_immutableEnumMap__K, _immutableEnumMap__V], typing.Mapping[_immutableEnumMap__K, _immutableEnumMap__V]]) -> ImmutableMap[_immutableEnumMap__K, _immutableEnumMap__V]: ...
    _newConcurrentMap__K = typing.TypeVar('_newConcurrentMap__K')  # <K>
    _newConcurrentMap__V = typing.TypeVar('_newConcurrentMap__V')  # <V>
    @staticmethod
    def newConcurrentMap() -> java.util.concurrent.ConcurrentMap[_newConcurrentMap__K, _newConcurrentMap__V]: ...
    _newEnumMap_0__K = typing.TypeVar('_newEnumMap_0__K', bound=java.lang.Enum)  # <K>
    _newEnumMap_0__V = typing.TypeVar('_newEnumMap_0__V')  # <V>
    _newEnumMap_1__K = typing.TypeVar('_newEnumMap_1__K', bound=java.lang.Enum)  # <K>
    _newEnumMap_1__V = typing.TypeVar('_newEnumMap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def newEnumMap(class_: typing.Type[_newEnumMap_0__K]) -> java.util.EnumMap[_newEnumMap_0__K, _newEnumMap_0__V]: ...
    @typing.overload
    @staticmethod
    def newEnumMap(map: typing.Union[java.util.Map[_newEnumMap_1__K, _newEnumMap_1__V], typing.Mapping[_newEnumMap_1__K, _newEnumMap_1__V]]) -> java.util.EnumMap[_newEnumMap_1__K, _newEnumMap_1__V]: ...
    _newHashMap_0__K = typing.TypeVar('_newHashMap_0__K')  # <K>
    _newHashMap_0__V = typing.TypeVar('_newHashMap_0__V')  # <V>
    _newHashMap_1__K = typing.TypeVar('_newHashMap_1__K')  # <K>
    _newHashMap_1__V = typing.TypeVar('_newHashMap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def newHashMap() -> java.util.HashMap[_newHashMap_0__K, _newHashMap_0__V]: ...
    @typing.overload
    @staticmethod
    def newHashMap(map: typing.Union[java.util.Map[_newHashMap_1__K, _newHashMap_1__V], typing.Mapping[_newHashMap_1__K, _newHashMap_1__V]]) -> java.util.HashMap[_newHashMap_1__K, _newHashMap_1__V]: ...
    _newHashMapWithExpectedSize__K = typing.TypeVar('_newHashMapWithExpectedSize__K')  # <K>
    _newHashMapWithExpectedSize__V = typing.TypeVar('_newHashMapWithExpectedSize__V')  # <V>
    @staticmethod
    def newHashMapWithExpectedSize(int: int) -> java.util.HashMap[_newHashMapWithExpectedSize__K, _newHashMapWithExpectedSize__V]: ...
    _newIdentityHashMap__K = typing.TypeVar('_newIdentityHashMap__K')  # <K>
    _newIdentityHashMap__V = typing.TypeVar('_newIdentityHashMap__V')  # <V>
    @staticmethod
    def newIdentityHashMap() -> java.util.IdentityHashMap[_newIdentityHashMap__K, _newIdentityHashMap__V]: ...
    _newLinkedHashMap_0__K = typing.TypeVar('_newLinkedHashMap_0__K')  # <K>
    _newLinkedHashMap_0__V = typing.TypeVar('_newLinkedHashMap_0__V')  # <V>
    _newLinkedHashMap_1__K = typing.TypeVar('_newLinkedHashMap_1__K')  # <K>
    _newLinkedHashMap_1__V = typing.TypeVar('_newLinkedHashMap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def newLinkedHashMap() -> java.util.LinkedHashMap[_newLinkedHashMap_0__K, _newLinkedHashMap_0__V]: ...
    @typing.overload
    @staticmethod
    def newLinkedHashMap(map: typing.Union[java.util.Map[_newLinkedHashMap_1__K, _newLinkedHashMap_1__V], typing.Mapping[_newLinkedHashMap_1__K, _newLinkedHashMap_1__V]]) -> java.util.LinkedHashMap[_newLinkedHashMap_1__K, _newLinkedHashMap_1__V]: ...
    _newLinkedHashMapWithExpectedSize__K = typing.TypeVar('_newLinkedHashMapWithExpectedSize__K')  # <K>
    _newLinkedHashMapWithExpectedSize__V = typing.TypeVar('_newLinkedHashMapWithExpectedSize__V')  # <V>
    @staticmethod
    def newLinkedHashMapWithExpectedSize(int: int) -> java.util.LinkedHashMap[_newLinkedHashMapWithExpectedSize__K, _newLinkedHashMapWithExpectedSize__V]: ...
    _newTreeMap_0__K = typing.TypeVar('_newTreeMap_0__K', bound=java.lang.Comparable)  # <K>
    _newTreeMap_0__V = typing.TypeVar('_newTreeMap_0__V')  # <V>
    _newTreeMap_1__C = typing.TypeVar('_newTreeMap_1__C')  # <C>
    _newTreeMap_1__K = typing.TypeVar('_newTreeMap_1__K')  # <K>
    _newTreeMap_1__V = typing.TypeVar('_newTreeMap_1__V')  # <V>
    _newTreeMap_2__K = typing.TypeVar('_newTreeMap_2__K')  # <K>
    _newTreeMap_2__V = typing.TypeVar('_newTreeMap_2__V')  # <V>
    @typing.overload
    @staticmethod
    def newTreeMap() -> java.util.TreeMap[_newTreeMap_0__K, _newTreeMap_0__V]: ...
    @typing.overload
    @staticmethod
    def newTreeMap(comparator: typing.Union[java.util.Comparator[_newTreeMap_1__C], typing.Callable[[_newTreeMap_1__C, _newTreeMap_1__C], int]]) -> java.util.TreeMap[_newTreeMap_1__K, _newTreeMap_1__V]: ...
    @typing.overload
    @staticmethod
    def newTreeMap(sortedMap: java.util.SortedMap[_newTreeMap_2__K, _newTreeMap_2__V]) -> java.util.TreeMap[_newTreeMap_2__K, _newTreeMap_2__V]: ...
    _subMap__K = typing.TypeVar('_subMap__K', bound=java.lang.Comparable)  # <K>
    _subMap__V = typing.TypeVar('_subMap__V')  # <V>
    @staticmethod
    def subMap(navigableMap: java.util.NavigableMap[_subMap__K, _subMap__V], range: 'Range'[_subMap__K]) -> java.util.NavigableMap[_subMap__K, _subMap__V]: ...
    _synchronizedBiMap__K = typing.TypeVar('_synchronizedBiMap__K')  # <K>
    _synchronizedBiMap__V = typing.TypeVar('_synchronizedBiMap__V')  # <V>
    @staticmethod
    def synchronizedBiMap(biMap: BiMap[_synchronizedBiMap__K, _synchronizedBiMap__V]) -> BiMap[_synchronizedBiMap__K, _synchronizedBiMap__V]: ...
    _synchronizedNavigableMap__K = typing.TypeVar('_synchronizedNavigableMap__K')  # <K>
    _synchronizedNavigableMap__V = typing.TypeVar('_synchronizedNavigableMap__V')  # <V>
    @staticmethod
    def synchronizedNavigableMap(navigableMap: java.util.NavigableMap[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V]) -> java.util.NavigableMap[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V]: ...
    _toImmutableEnumMap_0__T = typing.TypeVar('_toImmutableEnumMap_0__T')  # <T>
    _toImmutableEnumMap_0__K = typing.TypeVar('_toImmutableEnumMap_0__K', bound=java.lang.Enum)  # <K>
    _toImmutableEnumMap_0__V = typing.TypeVar('_toImmutableEnumMap_0__V')  # <V>
    _toImmutableEnumMap_1__T = typing.TypeVar('_toImmutableEnumMap_1__T')  # <T>
    _toImmutableEnumMap_1__K = typing.TypeVar('_toImmutableEnumMap_1__K', bound=java.lang.Enum)  # <K>
    _toImmutableEnumMap_1__V = typing.TypeVar('_toImmutableEnumMap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def toImmutableEnumMap(function: typing.Union[java.util.function.Function[_toImmutableEnumMap_0__T, _toImmutableEnumMap_0__K], typing.Callable[[_toImmutableEnumMap_0__T], _toImmutableEnumMap_0__K]], function2: typing.Union[java.util.function.Function[_toImmutableEnumMap_0__T, _toImmutableEnumMap_0__V], typing.Callable[[_toImmutableEnumMap_0__T], _toImmutableEnumMap_0__V]]) -> java.util.stream.Collector[_toImmutableEnumMap_0__T, typing.Any, ImmutableMap[_toImmutableEnumMap_0__K, _toImmutableEnumMap_0__V]]: ...
    @typing.overload
    @staticmethod
    def toImmutableEnumMap(function: typing.Union[java.util.function.Function[_toImmutableEnumMap_1__T, _toImmutableEnumMap_1__K], typing.Callable[[_toImmutableEnumMap_1__T], _toImmutableEnumMap_1__K]], function2: typing.Union[java.util.function.Function[_toImmutableEnumMap_1__T, _toImmutableEnumMap_1__V], typing.Callable[[_toImmutableEnumMap_1__T], _toImmutableEnumMap_1__V]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_toImmutableEnumMap_1__V], typing.Callable]) -> java.util.stream.Collector[_toImmutableEnumMap_1__T, typing.Any, ImmutableMap[_toImmutableEnumMap_1__K, _toImmutableEnumMap_1__V]]: ...
    _toMap_0__K = typing.TypeVar('_toMap_0__K')  # <K>
    _toMap_0__V = typing.TypeVar('_toMap_0__V')  # <V>
    _toMap_1__K = typing.TypeVar('_toMap_1__K')  # <K>
    _toMap_1__V = typing.TypeVar('_toMap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def toMap(iterable: java.lang.Iterable[_toMap_0__K], function: typing.Union[com.google.common.base.Function[_toMap_0__K, _toMap_0__V], typing.Callable[[_toMap_0__K], _toMap_0__V]]) -> ImmutableMap[_toMap_0__K, _toMap_0__V]: ...
    @typing.overload
    @staticmethod
    def toMap(iterator: java.util.Iterator[_toMap_1__K], function: typing.Union[com.google.common.base.Function[_toMap_1__K, _toMap_1__V], typing.Callable[[_toMap_1__K], _toMap_1__V]]) -> ImmutableMap[_toMap_1__K, _toMap_1__V]: ...
    _transformEntries_0__K = typing.TypeVar('_transformEntries_0__K')  # <K>
    _transformEntries_0__V1 = typing.TypeVar('_transformEntries_0__V1')  # <V1>
    _transformEntries_0__V2 = typing.TypeVar('_transformEntries_0__V2')  # <V2>
    _transformEntries_1__K = typing.TypeVar('_transformEntries_1__K')  # <K>
    _transformEntries_1__V1 = typing.TypeVar('_transformEntries_1__V1')  # <V1>
    _transformEntries_1__V2 = typing.TypeVar('_transformEntries_1__V2')  # <V2>
    _transformEntries_2__K = typing.TypeVar('_transformEntries_2__K')  # <K>
    _transformEntries_2__V1 = typing.TypeVar('_transformEntries_2__V1')  # <V1>
    _transformEntries_2__V2 = typing.TypeVar('_transformEntries_2__V2')  # <V2>
    @typing.overload
    @staticmethod
    def transformEntries(map: typing.Union[java.util.Map[_transformEntries_0__K, _transformEntries_0__V1], typing.Mapping[_transformEntries_0__K, _transformEntries_0__V1]], entryTransformer: typing.Union['Maps.EntryTransformer'[_transformEntries_0__K, _transformEntries_0__V1, _transformEntries_0__V2], typing.Callable[[_transformEntries_0__K, _transformEntries_0__V1], _transformEntries_0__V2]]) -> java.util.Map[_transformEntries_0__K, _transformEntries_0__V2]: ...
    @typing.overload
    @staticmethod
    def transformEntries(navigableMap: java.util.NavigableMap[_transformEntries_1__K, _transformEntries_1__V1], entryTransformer: typing.Union['Maps.EntryTransformer'[_transformEntries_1__K, _transformEntries_1__V1, _transformEntries_1__V2], typing.Callable[[_transformEntries_1__K, _transformEntries_1__V1], _transformEntries_1__V2]]) -> java.util.NavigableMap[_transformEntries_1__K, _transformEntries_1__V2]: ...
    @typing.overload
    @staticmethod
    def transformEntries(sortedMap: java.util.SortedMap[_transformEntries_2__K, _transformEntries_2__V1], entryTransformer: typing.Union['Maps.EntryTransformer'[_transformEntries_2__K, _transformEntries_2__V1, _transformEntries_2__V2], typing.Callable[[_transformEntries_2__K, _transformEntries_2__V1], _transformEntries_2__V2]]) -> java.util.SortedMap[_transformEntries_2__K, _transformEntries_2__V2]: ...
    _transformValues_0__K = typing.TypeVar('_transformValues_0__K')  # <K>
    _transformValues_0__V1 = typing.TypeVar('_transformValues_0__V1')  # <V1>
    _transformValues_0__V2 = typing.TypeVar('_transformValues_0__V2')  # <V2>
    _transformValues_1__K = typing.TypeVar('_transformValues_1__K')  # <K>
    _transformValues_1__V1 = typing.TypeVar('_transformValues_1__V1')  # <V1>
    _transformValues_1__V2 = typing.TypeVar('_transformValues_1__V2')  # <V2>
    _transformValues_2__K = typing.TypeVar('_transformValues_2__K')  # <K>
    _transformValues_2__V1 = typing.TypeVar('_transformValues_2__V1')  # <V1>
    _transformValues_2__V2 = typing.TypeVar('_transformValues_2__V2')  # <V2>
    @typing.overload
    @staticmethod
    def transformValues(map: typing.Union[java.util.Map[_transformValues_0__K, _transformValues_0__V1], typing.Mapping[_transformValues_0__K, _transformValues_0__V1]], function: typing.Union[com.google.common.base.Function[_transformValues_0__V1, _transformValues_0__V2], typing.Callable[[_transformValues_0__V1], _transformValues_0__V2]]) -> java.util.Map[_transformValues_0__K, _transformValues_0__V2]: ...
    @typing.overload
    @staticmethod
    def transformValues(navigableMap: java.util.NavigableMap[_transformValues_1__K, _transformValues_1__V1], function: typing.Union[com.google.common.base.Function[_transformValues_1__V1, _transformValues_1__V2], typing.Callable[[_transformValues_1__V1], _transformValues_1__V2]]) -> java.util.NavigableMap[_transformValues_1__K, _transformValues_1__V2]: ...
    @typing.overload
    @staticmethod
    def transformValues(sortedMap: java.util.SortedMap[_transformValues_2__K, _transformValues_2__V1], function: typing.Union[com.google.common.base.Function[_transformValues_2__V1, _transformValues_2__V2], typing.Callable[[_transformValues_2__V1], _transformValues_2__V2]]) -> java.util.SortedMap[_transformValues_2__K, _transformValues_2__V2]: ...
    _uniqueIndex_0__K = typing.TypeVar('_uniqueIndex_0__K')  # <K>
    _uniqueIndex_0__V = typing.TypeVar('_uniqueIndex_0__V')  # <V>
    _uniqueIndex_1__K = typing.TypeVar('_uniqueIndex_1__K')  # <K>
    _uniqueIndex_1__V = typing.TypeVar('_uniqueIndex_1__V')  # <V>
    @typing.overload
    @staticmethod
    def uniqueIndex(iterable: java.lang.Iterable[_uniqueIndex_0__V], function: typing.Union[com.google.common.base.Function[_uniqueIndex_0__V, _uniqueIndex_0__K], typing.Callable[[_uniqueIndex_0__V], _uniqueIndex_0__K]]) -> ImmutableMap[_uniqueIndex_0__K, _uniqueIndex_0__V]: ...
    @typing.overload
    @staticmethod
    def uniqueIndex(iterator: java.util.Iterator[_uniqueIndex_1__V], function: typing.Union[com.google.common.base.Function[_uniqueIndex_1__V, _uniqueIndex_1__K], typing.Callable[[_uniqueIndex_1__V], _uniqueIndex_1__K]]) -> ImmutableMap[_uniqueIndex_1__K, _uniqueIndex_1__V]: ...
    _unmodifiableBiMap__K = typing.TypeVar('_unmodifiableBiMap__K')  # <K>
    _unmodifiableBiMap__V = typing.TypeVar('_unmodifiableBiMap__V')  # <V>
    @staticmethod
    def unmodifiableBiMap(biMap: BiMap[_unmodifiableBiMap__K, _unmodifiableBiMap__V]) -> BiMap[_unmodifiableBiMap__K, _unmodifiableBiMap__V]: ...
    _unmodifiableNavigableMap__K = typing.TypeVar('_unmodifiableNavigableMap__K')  # <K>
    _unmodifiableNavigableMap__V = typing.TypeVar('_unmodifiableNavigableMap__V')  # <V>
    @staticmethod
    def unmodifiableNavigableMap(navigableMap: java.util.NavigableMap[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V]) -> java.util.NavigableMap[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V]: ...
    class EntryTransformer(typing.Generic[_Maps__EntryTransformer__K, _Maps__EntryTransformer__V1, _Maps__EntryTransformer__V2]):
        """
        Java class 'com.google.common.collect.Maps$EntryTransformer'
        
        """
        def transformEntry(self, k: _Maps__EntryTransformer__K, v1: _Maps__EntryTransformer__V1) -> _Maps__EntryTransformer__V2: ...

_MinMaxPriorityQueue__Builder__B = typing.TypeVar('_MinMaxPriorityQueue__Builder__B')  # <B>
_MinMaxPriorityQueue__E = typing.TypeVar('_MinMaxPriorityQueue__E')  # <E>
class MinMaxPriorityQueue(java.util.AbstractQueue[_MinMaxPriorityQueue__E], typing.Generic[_MinMaxPriorityQueue__E]):
    """
    Java class 'com.google.common.collect.MinMaxPriorityQueue'
    
        Extends:
            java.util.AbstractQueue
    
    """
    def add(self, e: _MinMaxPriorityQueue__E) -> bool: ...
    def addAll(self, collection: typing.Union[java.util.Collection[_MinMaxPriorityQueue__E], typing.Sequence[_MinMaxPriorityQueue__E]]) -> bool: ...
    def clear(self) -> None: ...
    def comparator(self) -> java.util.Comparator[_MinMaxPriorityQueue__E]: ...
    _create_0__E = typing.TypeVar('_create_0__E', bound=java.lang.Comparable)  # <E>
    _create_1__E = typing.TypeVar('_create_1__E', bound=java.lang.Comparable)  # <E>
    @typing.overload
    @staticmethod
    def create() -> 'MinMaxPriorityQueue'[_create_0__E]: ...
    @typing.overload
    @staticmethod
    def create(iterable: java.lang.Iterable[_create_1__E]) -> 'MinMaxPriorityQueue'[_create_1__E]: ...
    @staticmethod
    def expectedSize(int: int) -> 'MinMaxPriorityQueue.Builder'[java.lang.Comparable]: ...
    def iterator(self) -> java.util.Iterator[_MinMaxPriorityQueue__E]: ...
    @staticmethod
    def maximumSize(int: int) -> 'MinMaxPriorityQueue.Builder'[java.lang.Comparable]: ...
    def offer(self, e: _MinMaxPriorityQueue__E) -> bool: ...
    _orderedBy__B = typing.TypeVar('_orderedBy__B')  # <B>
    @staticmethod
    def orderedBy(comparator: typing.Union[java.util.Comparator[_orderedBy__B], typing.Callable[[_orderedBy__B, _orderedBy__B], int]]) -> 'MinMaxPriorityQueue.Builder'[_orderedBy__B]: ...
    def peek(self) -> _MinMaxPriorityQueue__E: ...
    def peekFirst(self) -> _MinMaxPriorityQueue__E: ...
    def peekLast(self) -> _MinMaxPriorityQueue__E: ...
    def poll(self) -> _MinMaxPriorityQueue__E: ...
    def pollFirst(self) -> _MinMaxPriorityQueue__E: ...
    def pollLast(self) -> _MinMaxPriorityQueue__E: ...
    def removeFirst(self) -> _MinMaxPriorityQueue__E: ...
    def removeLast(self) -> _MinMaxPriorityQueue__E: ...
    def size(self) -> int: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[int], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...
    class Builder(typing.Generic[_MinMaxPriorityQueue__Builder__B]):
        """
        Java class 'com.google.common.collect.MinMaxPriorityQueue$Builder'
        
            Extends:
                java.lang.Object
        
        """
        _create_0__T = typing.TypeVar('_create_0__T')  # <T>
        _create_1__T = typing.TypeVar('_create_1__T')  # <T>
        @typing.overload
        def create(self) -> 'MinMaxPriorityQueue'[_create_0__T]: ...
        @typing.overload
        def create(self, iterable: java.lang.Iterable[_create_1__T]) -> 'MinMaxPriorityQueue'[_create_1__T]: ...
        def expectedSize(self, int: int) -> 'MinMaxPriorityQueue.Builder'[_MinMaxPriorityQueue__Builder__B]: ...
        def maximumSize(self, int: int) -> 'MinMaxPriorityQueue.Builder'[_MinMaxPriorityQueue__Builder__B]: ...

class MoreCollectors:
    """
    Java class 'com.google.common.collect.MoreCollectors'
    
        Extends:
            java.lang.Object
    
    """
    _onlyElement__T = typing.TypeVar('_onlyElement__T')  # <T>
    @staticmethod
    def onlyElement() -> java.util.stream.Collector[_onlyElement__T, typing.Any, _onlyElement__T]: ...
    _toOptional__T = typing.TypeVar('_toOptional__T')  # <T>
    @staticmethod
    def toOptional() -> java.util.stream.Collector[_toOptional__T, typing.Any, java.util.Optional[_toOptional__T]]: ...

_Multimap__K = typing.TypeVar('_Multimap__K')  # <K>
_Multimap__V = typing.TypeVar('_Multimap__V')  # <V>
class Multimap(typing.Generic[_Multimap__K, _Multimap__V]):
    """
    Java class 'com.google.common.collect.Multimap'
    
    """
    def asMap(self) -> java.util.Map[_Multimap__K, java.util.Collection[_Multimap__V]]: ...
    def clear(self) -> None: ...
    def containsEntry(self, object: typing.Any, object2: typing.Any) -> bool: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entries(self) -> java.util.Collection[java.util.Map.Entry[_Multimap__K, _Multimap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_Multimap__K, _Multimap__V], typing.Callable[[_Multimap__K, _Multimap__V], None]]) -> None: ...
    def get(self, k: _Multimap__K) -> java.util.Collection[_Multimap__V]: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.Set[_Multimap__K]: ...
    def keys(self) -> 'Multiset'[_Multimap__K]: ...
    def put(self, k: _Multimap__K, v: _Multimap__V) -> bool: ...
    @typing.overload
    def putAll(self, multimap: 'Multimap'[_Multimap__K, _Multimap__V]) -> bool: ...
    @typing.overload
    def putAll(self, k: _Multimap__K, iterable: java.lang.Iterable[_Multimap__V]) -> bool: ...
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    def removeAll(self, object: typing.Any) -> java.util.Collection[_Multimap__V]: ...
    def replaceValues(self, k: _Multimap__K, iterable: java.lang.Iterable[_Multimap__V]) -> java.util.Collection[_Multimap__V]: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Collection[_Multimap__V]: ...

class Multimaps:
    """
    Java class 'com.google.common.collect.Multimaps'
    
        Extends:
            java.lang.Object
    
    """
    _asMap_0__K = typing.TypeVar('_asMap_0__K')  # <K>
    _asMap_0__V = typing.TypeVar('_asMap_0__V')  # <V>
    _asMap_1__K = typing.TypeVar('_asMap_1__K')  # <K>
    _asMap_1__V = typing.TypeVar('_asMap_1__V')  # <V>
    _asMap_2__K = typing.TypeVar('_asMap_2__K')  # <K>
    _asMap_2__V = typing.TypeVar('_asMap_2__V')  # <V>
    _asMap_3__K = typing.TypeVar('_asMap_3__K')  # <K>
    _asMap_3__V = typing.TypeVar('_asMap_3__V')  # <V>
    @typing.overload
    @staticmethod
    def asMap(listMultimap: 'ListMultimap'[_asMap_0__K, _asMap_0__V]) -> java.util.Map[_asMap_0__K, java.util.List[_asMap_0__V]]: ...
    @typing.overload
    @staticmethod
    def asMap(multimap: Multimap[_asMap_1__K, _asMap_1__V]) -> java.util.Map[_asMap_1__K, java.util.Collection[_asMap_1__V]]: ...
    @typing.overload
    @staticmethod
    def asMap(setMultimap: 'SetMultimap'[_asMap_2__K, _asMap_2__V]) -> java.util.Map[_asMap_2__K, java.util.Set[_asMap_2__V]]: ...
    @typing.overload
    @staticmethod
    def asMap(sortedSetMultimap: 'SortedSetMultimap'[_asMap_3__K, _asMap_3__V]) -> java.util.Map[_asMap_3__K, java.util.SortedSet[_asMap_3__V]]: ...
    _filterEntries_0__K = typing.TypeVar('_filterEntries_0__K')  # <K>
    _filterEntries_0__V = typing.TypeVar('_filterEntries_0__V')  # <V>
    _filterEntries_1__K = typing.TypeVar('_filterEntries_1__K')  # <K>
    _filterEntries_1__V = typing.TypeVar('_filterEntries_1__V')  # <V>
    @typing.overload
    @staticmethod
    def filterEntries(multimap: Multimap[_filterEntries_0__K, _filterEntries_0__V], predicate: typing.Union[com.google.common.base.Predicate[java.util.Map.Entry[_filterEntries_0__K, _filterEntries_0__V]], typing.Callable[[java.util.Map.Entry[_filterEntries_0__K, _filterEntries_0__V]], bool]]) -> Multimap[_filterEntries_0__K, _filterEntries_0__V]: ...
    @typing.overload
    @staticmethod
    def filterEntries(setMultimap: 'SetMultimap'[_filterEntries_1__K, _filterEntries_1__V], predicate: typing.Union[com.google.common.base.Predicate[java.util.Map.Entry[_filterEntries_1__K, _filterEntries_1__V]], typing.Callable[[java.util.Map.Entry[_filterEntries_1__K, _filterEntries_1__V]], bool]]) -> 'SetMultimap'[_filterEntries_1__K, _filterEntries_1__V]: ...
    _filterKeys_0__K = typing.TypeVar('_filterKeys_0__K')  # <K>
    _filterKeys_0__V = typing.TypeVar('_filterKeys_0__V')  # <V>
    _filterKeys_1__K = typing.TypeVar('_filterKeys_1__K')  # <K>
    _filterKeys_1__V = typing.TypeVar('_filterKeys_1__V')  # <V>
    _filterKeys_2__K = typing.TypeVar('_filterKeys_2__K')  # <K>
    _filterKeys_2__V = typing.TypeVar('_filterKeys_2__V')  # <V>
    @typing.overload
    @staticmethod
    def filterKeys(listMultimap: 'ListMultimap'[_filterKeys_0__K, _filterKeys_0__V], predicate: typing.Union[com.google.common.base.Predicate[_filterKeys_0__K], typing.Callable[[_filterKeys_0__K], bool]]) -> 'ListMultimap'[_filterKeys_0__K, _filterKeys_0__V]: ...
    @typing.overload
    @staticmethod
    def filterKeys(multimap: Multimap[_filterKeys_1__K, _filterKeys_1__V], predicate: typing.Union[com.google.common.base.Predicate[_filterKeys_1__K], typing.Callable[[_filterKeys_1__K], bool]]) -> Multimap[_filterKeys_1__K, _filterKeys_1__V]: ...
    @typing.overload
    @staticmethod
    def filterKeys(setMultimap: 'SetMultimap'[_filterKeys_2__K, _filterKeys_2__V], predicate: typing.Union[com.google.common.base.Predicate[_filterKeys_2__K], typing.Callable[[_filterKeys_2__K], bool]]) -> 'SetMultimap'[_filterKeys_2__K, _filterKeys_2__V]: ...
    _filterValues_0__K = typing.TypeVar('_filterValues_0__K')  # <K>
    _filterValues_0__V = typing.TypeVar('_filterValues_0__V')  # <V>
    _filterValues_1__K = typing.TypeVar('_filterValues_1__K')  # <K>
    _filterValues_1__V = typing.TypeVar('_filterValues_1__V')  # <V>
    @typing.overload
    @staticmethod
    def filterValues(multimap: Multimap[_filterValues_0__K, _filterValues_0__V], predicate: typing.Union[com.google.common.base.Predicate[_filterValues_0__V], typing.Callable[[_filterValues_0__V], bool]]) -> Multimap[_filterValues_0__K, _filterValues_0__V]: ...
    @typing.overload
    @staticmethod
    def filterValues(setMultimap: 'SetMultimap'[_filterValues_1__K, _filterValues_1__V], predicate: typing.Union[com.google.common.base.Predicate[_filterValues_1__V], typing.Callable[[_filterValues_1__V], bool]]) -> 'SetMultimap'[_filterValues_1__K, _filterValues_1__V]: ...
    _flatteningToMultimap__T = typing.TypeVar('_flatteningToMultimap__T')  # <T>
    _flatteningToMultimap__K = typing.TypeVar('_flatteningToMultimap__K')  # <K>
    _flatteningToMultimap__V = typing.TypeVar('_flatteningToMultimap__V')  # <V>
    _flatteningToMultimap__M = typing.TypeVar('_flatteningToMultimap__M', bound=Multimap)  # <M>
    @staticmethod
    def flatteningToMultimap(function: typing.Union[java.util.function.Function[_flatteningToMultimap__T, _flatteningToMultimap__K], typing.Callable[[_flatteningToMultimap__T], _flatteningToMultimap__K]], function2: typing.Union[java.util.function.Function[_flatteningToMultimap__T, java.util.stream.Stream[_flatteningToMultimap__V]], typing.Callable[[_flatteningToMultimap__T], java.util.stream.Stream[_flatteningToMultimap__V]]], supplier: typing.Union[java.util.function.Supplier[_flatteningToMultimap__M], typing.Callable[[], _flatteningToMultimap__M]]) -> java.util.stream.Collector[_flatteningToMultimap__T, typing.Any, _flatteningToMultimap__M]: ...
    _forMap__K = typing.TypeVar('_forMap__K')  # <K>
    _forMap__V = typing.TypeVar('_forMap__V')  # <V>
    @staticmethod
    def forMap(map: typing.Union[java.util.Map[_forMap__K, _forMap__V], typing.Mapping[_forMap__K, _forMap__V]]) -> 'SetMultimap'[_forMap__K, _forMap__V]: ...
    _index_0__K = typing.TypeVar('_index_0__K')  # <K>
    _index_0__V = typing.TypeVar('_index_0__V')  # <V>
    _index_1__K = typing.TypeVar('_index_1__K')  # <K>
    _index_1__V = typing.TypeVar('_index_1__V')  # <V>
    @typing.overload
    @staticmethod
    def index(iterable: java.lang.Iterable[_index_0__V], function: typing.Union[com.google.common.base.Function[_index_0__V, _index_0__K], typing.Callable[[_index_0__V], _index_0__K]]) -> 'ImmutableListMultimap'[_index_0__K, _index_0__V]: ...
    @typing.overload
    @staticmethod
    def index(iterator: java.util.Iterator[_index_1__V], function: typing.Union[com.google.common.base.Function[_index_1__V, _index_1__K], typing.Callable[[_index_1__V], _index_1__K]]) -> 'ImmutableListMultimap'[_index_1__K, _index_1__V]: ...
    _invertFrom__K = typing.TypeVar('_invertFrom__K')  # <K>
    _invertFrom__V = typing.TypeVar('_invertFrom__V')  # <V>
    _invertFrom__M = typing.TypeVar('_invertFrom__M', bound=Multimap)  # <M>
    @staticmethod
    def invertFrom(multimap: Multimap[_invertFrom__V, _invertFrom__K], m2: _invertFrom__M) -> _invertFrom__M: ...
    _newListMultimap__K = typing.TypeVar('_newListMultimap__K')  # <K>
    _newListMultimap__V = typing.TypeVar('_newListMultimap__V')  # <V>
    @staticmethod
    def newListMultimap(map: typing.Union[java.util.Map[_newListMultimap__K, typing.Union[java.util.Collection[_newListMultimap__V], typing.Sequence[_newListMultimap__V]]], typing.Mapping[_newListMultimap__K, typing.Union[java.util.Collection[_newListMultimap__V], typing.Sequence[_newListMultimap__V]]]], supplier: typing.Union[com.google.common.base.Supplier[java.util.List[_newListMultimap__V]], typing.Callable[[], java.util.List[_newListMultimap__V]]]) -> 'ListMultimap'[_newListMultimap__K, _newListMultimap__V]: ...
    _newMultimap__K = typing.TypeVar('_newMultimap__K')  # <K>
    _newMultimap__V = typing.TypeVar('_newMultimap__V')  # <V>
    @staticmethod
    def newMultimap(map: typing.Union[java.util.Map[_newMultimap__K, typing.Union[java.util.Collection[_newMultimap__V], typing.Sequence[_newMultimap__V]]], typing.Mapping[_newMultimap__K, typing.Union[java.util.Collection[_newMultimap__V], typing.Sequence[_newMultimap__V]]]], supplier: typing.Union[com.google.common.base.Supplier[java.util.Collection[_newMultimap__V]], typing.Callable[[], java.util.Collection[_newMultimap__V]]]) -> Multimap[_newMultimap__K, _newMultimap__V]: ...
    _newSetMultimap__K = typing.TypeVar('_newSetMultimap__K')  # <K>
    _newSetMultimap__V = typing.TypeVar('_newSetMultimap__V')  # <V>
    @staticmethod
    def newSetMultimap(map: typing.Union[java.util.Map[_newSetMultimap__K, typing.Union[java.util.Collection[_newSetMultimap__V], typing.Sequence[_newSetMultimap__V]]], typing.Mapping[_newSetMultimap__K, typing.Union[java.util.Collection[_newSetMultimap__V], typing.Sequence[_newSetMultimap__V]]]], supplier: typing.Union[com.google.common.base.Supplier[java.util.Set[_newSetMultimap__V]], typing.Callable[[], java.util.Set[_newSetMultimap__V]]]) -> 'SetMultimap'[_newSetMultimap__K, _newSetMultimap__V]: ...
    _newSortedSetMultimap__K = typing.TypeVar('_newSortedSetMultimap__K')  # <K>
    _newSortedSetMultimap__V = typing.TypeVar('_newSortedSetMultimap__V')  # <V>
    @staticmethod
    def newSortedSetMultimap(map: typing.Union[java.util.Map[_newSortedSetMultimap__K, typing.Union[java.util.Collection[_newSortedSetMultimap__V], typing.Sequence[_newSortedSetMultimap__V]]], typing.Mapping[_newSortedSetMultimap__K, typing.Union[java.util.Collection[_newSortedSetMultimap__V], typing.Sequence[_newSortedSetMultimap__V]]]], supplier: typing.Union[com.google.common.base.Supplier[java.util.SortedSet[_newSortedSetMultimap__V]], typing.Callable[[], java.util.SortedSet[_newSortedSetMultimap__V]]]) -> 'SortedSetMultimap'[_newSortedSetMultimap__K, _newSortedSetMultimap__V]: ...
    _synchronizedListMultimap__K = typing.TypeVar('_synchronizedListMultimap__K')  # <K>
    _synchronizedListMultimap__V = typing.TypeVar('_synchronizedListMultimap__V')  # <V>
    @staticmethod
    def synchronizedListMultimap(listMultimap: 'ListMultimap'[_synchronizedListMultimap__K, _synchronizedListMultimap__V]) -> 'ListMultimap'[_synchronizedListMultimap__K, _synchronizedListMultimap__V]: ...
    _synchronizedMultimap__K = typing.TypeVar('_synchronizedMultimap__K')  # <K>
    _synchronizedMultimap__V = typing.TypeVar('_synchronizedMultimap__V')  # <V>
    @staticmethod
    def synchronizedMultimap(multimap: Multimap[_synchronizedMultimap__K, _synchronizedMultimap__V]) -> Multimap[_synchronizedMultimap__K, _synchronizedMultimap__V]: ...
    _synchronizedSetMultimap__K = typing.TypeVar('_synchronizedSetMultimap__K')  # <K>
    _synchronizedSetMultimap__V = typing.TypeVar('_synchronizedSetMultimap__V')  # <V>
    @staticmethod
    def synchronizedSetMultimap(setMultimap: 'SetMultimap'[_synchronizedSetMultimap__K, _synchronizedSetMultimap__V]) -> 'SetMultimap'[_synchronizedSetMultimap__K, _synchronizedSetMultimap__V]: ...
    _synchronizedSortedSetMultimap__K = typing.TypeVar('_synchronizedSortedSetMultimap__K')  # <K>
    _synchronizedSortedSetMultimap__V = typing.TypeVar('_synchronizedSortedSetMultimap__V')  # <V>
    @staticmethod
    def synchronizedSortedSetMultimap(sortedSetMultimap: 'SortedSetMultimap'[_synchronizedSortedSetMultimap__K, _synchronizedSortedSetMultimap__V]) -> 'SortedSetMultimap'[_synchronizedSortedSetMultimap__K, _synchronizedSortedSetMultimap__V]: ...
    _toMultimap__T = typing.TypeVar('_toMultimap__T')  # <T>
    _toMultimap__K = typing.TypeVar('_toMultimap__K')  # <K>
    _toMultimap__V = typing.TypeVar('_toMultimap__V')  # <V>
    _toMultimap__M = typing.TypeVar('_toMultimap__M', bound=Multimap)  # <M>
    @staticmethod
    def toMultimap(function: typing.Union[java.util.function.Function[_toMultimap__T, _toMultimap__K], typing.Callable[[_toMultimap__T], _toMultimap__K]], function2: typing.Union[java.util.function.Function[_toMultimap__T, _toMultimap__V], typing.Callable[[_toMultimap__T], _toMultimap__V]], supplier: typing.Union[java.util.function.Supplier[_toMultimap__M], typing.Callable[[], _toMultimap__M]]) -> java.util.stream.Collector[_toMultimap__T, typing.Any, _toMultimap__M]: ...
    _transformEntries_0__K = typing.TypeVar('_transformEntries_0__K')  # <K>
    _transformEntries_0__V1 = typing.TypeVar('_transformEntries_0__V1')  # <V1>
    _transformEntries_0__V2 = typing.TypeVar('_transformEntries_0__V2')  # <V2>
    _transformEntries_1__K = typing.TypeVar('_transformEntries_1__K')  # <K>
    _transformEntries_1__V1 = typing.TypeVar('_transformEntries_1__V1')  # <V1>
    _transformEntries_1__V2 = typing.TypeVar('_transformEntries_1__V2')  # <V2>
    @typing.overload
    @staticmethod
    def transformEntries(listMultimap: 'ListMultimap'[_transformEntries_0__K, _transformEntries_0__V1], entryTransformer: typing.Union[Maps.EntryTransformer[_transformEntries_0__K, _transformEntries_0__V1, _transformEntries_0__V2], typing.Callable[[_transformEntries_0__K, _transformEntries_0__V1], _transformEntries_0__V2]]) -> 'ListMultimap'[_transformEntries_0__K, _transformEntries_0__V2]: ...
    @typing.overload
    @staticmethod
    def transformEntries(multimap: Multimap[_transformEntries_1__K, _transformEntries_1__V1], entryTransformer: typing.Union[Maps.EntryTransformer[_transformEntries_1__K, _transformEntries_1__V1, _transformEntries_1__V2], typing.Callable[[_transformEntries_1__K, _transformEntries_1__V1], _transformEntries_1__V2]]) -> Multimap[_transformEntries_1__K, _transformEntries_1__V2]: ...
    _transformValues_0__K = typing.TypeVar('_transformValues_0__K')  # <K>
    _transformValues_0__V1 = typing.TypeVar('_transformValues_0__V1')  # <V1>
    _transformValues_0__V2 = typing.TypeVar('_transformValues_0__V2')  # <V2>
    _transformValues_1__K = typing.TypeVar('_transformValues_1__K')  # <K>
    _transformValues_1__V1 = typing.TypeVar('_transformValues_1__V1')  # <V1>
    _transformValues_1__V2 = typing.TypeVar('_transformValues_1__V2')  # <V2>
    @typing.overload
    @staticmethod
    def transformValues(listMultimap: 'ListMultimap'[_transformValues_0__K, _transformValues_0__V1], function: typing.Union[com.google.common.base.Function[_transformValues_0__V1, _transformValues_0__V2], typing.Callable[[_transformValues_0__V1], _transformValues_0__V2]]) -> 'ListMultimap'[_transformValues_0__K, _transformValues_0__V2]: ...
    @typing.overload
    @staticmethod
    def transformValues(multimap: Multimap[_transformValues_1__K, _transformValues_1__V1], function: typing.Union[com.google.common.base.Function[_transformValues_1__V1, _transformValues_1__V2], typing.Callable[[_transformValues_1__V1], _transformValues_1__V2]]) -> Multimap[_transformValues_1__K, _transformValues_1__V2]: ...
    _unmodifiableListMultimap_0__K = typing.TypeVar('_unmodifiableListMultimap_0__K')  # <K>
    _unmodifiableListMultimap_0__V = typing.TypeVar('_unmodifiableListMultimap_0__V')  # <V>
    _unmodifiableListMultimap_1__K = typing.TypeVar('_unmodifiableListMultimap_1__K')  # <K>
    _unmodifiableListMultimap_1__V = typing.TypeVar('_unmodifiableListMultimap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def unmodifiableListMultimap(immutableListMultimap: 'ImmutableListMultimap'[_unmodifiableListMultimap_0__K, _unmodifiableListMultimap_0__V]) -> 'ListMultimap'[_unmodifiableListMultimap_0__K, _unmodifiableListMultimap_0__V]: ...
    @typing.overload
    @staticmethod
    def unmodifiableListMultimap(listMultimap: 'ListMultimap'[_unmodifiableListMultimap_1__K, _unmodifiableListMultimap_1__V]) -> 'ListMultimap'[_unmodifiableListMultimap_1__K, _unmodifiableListMultimap_1__V]: ...
    _unmodifiableMultimap_0__K = typing.TypeVar('_unmodifiableMultimap_0__K')  # <K>
    _unmodifiableMultimap_0__V = typing.TypeVar('_unmodifiableMultimap_0__V')  # <V>
    _unmodifiableMultimap_1__K = typing.TypeVar('_unmodifiableMultimap_1__K')  # <K>
    _unmodifiableMultimap_1__V = typing.TypeVar('_unmodifiableMultimap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def unmodifiableMultimap(immutableMultimap: 'ImmutableMultimap'[_unmodifiableMultimap_0__K, _unmodifiableMultimap_0__V]) -> Multimap[_unmodifiableMultimap_0__K, _unmodifiableMultimap_0__V]: ...
    @typing.overload
    @staticmethod
    def unmodifiableMultimap(multimap: Multimap[_unmodifiableMultimap_1__K, _unmodifiableMultimap_1__V]) -> Multimap[_unmodifiableMultimap_1__K, _unmodifiableMultimap_1__V]: ...
    _unmodifiableSetMultimap_0__K = typing.TypeVar('_unmodifiableSetMultimap_0__K')  # <K>
    _unmodifiableSetMultimap_0__V = typing.TypeVar('_unmodifiableSetMultimap_0__V')  # <V>
    _unmodifiableSetMultimap_1__K = typing.TypeVar('_unmodifiableSetMultimap_1__K')  # <K>
    _unmodifiableSetMultimap_1__V = typing.TypeVar('_unmodifiableSetMultimap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def unmodifiableSetMultimap(immutableSetMultimap: 'ImmutableSetMultimap'[_unmodifiableSetMultimap_0__K, _unmodifiableSetMultimap_0__V]) -> 'SetMultimap'[_unmodifiableSetMultimap_0__K, _unmodifiableSetMultimap_0__V]: ...
    @typing.overload
    @staticmethod
    def unmodifiableSetMultimap(setMultimap: 'SetMultimap'[_unmodifiableSetMultimap_1__K, _unmodifiableSetMultimap_1__V]) -> 'SetMultimap'[_unmodifiableSetMultimap_1__K, _unmodifiableSetMultimap_1__V]: ...
    _unmodifiableSortedSetMultimap__K = typing.TypeVar('_unmodifiableSortedSetMultimap__K')  # <K>
    _unmodifiableSortedSetMultimap__V = typing.TypeVar('_unmodifiableSortedSetMultimap__V')  # <V>
    @staticmethod
    def unmodifiableSortedSetMultimap(sortedSetMultimap: 'SortedSetMultimap'[_unmodifiableSortedSetMultimap__K, _unmodifiableSortedSetMultimap__V]) -> 'SortedSetMultimap'[_unmodifiableSortedSetMultimap__K, _unmodifiableSortedSetMultimap__V]: ...

_Multiset__Entry__E = typing.TypeVar('_Multiset__Entry__E')  # <E>
_Multiset__E = typing.TypeVar('_Multiset__E')  # <E>
class Multiset(java.util.Collection[_Multiset__E], typing.Generic[_Multiset__E]):
    """
    Java class 'com.google.common.collect.Multiset'
    
        Interfaces:
            java.util.Collection
    
    """
    @typing.overload
    def add(self, e: _Multiset__E) -> bool: ...
    @typing.overload
    def add(self, e: _Multiset__E, int: int) -> int: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def count(self, object: typing.Any) -> int: ...
    def elementSet(self) -> java.util.Set[_Multiset__E]: ...
    def entrySet(self) -> java.util.Set['Multiset.Entry'[_Multiset__E]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_Multiset__E], typing.Callable[[_Multiset__E], None]]) -> None: ...
    def forEachEntry(self, objIntConsumer: typing.Union[java.util.function.ObjIntConsumer[_Multiset__E], typing.Callable[[_Multiset__E, int], None]]) -> None: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> java.util.Iterator[_Multiset__E]: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any, int: int) -> int: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    @typing.overload
    def setCount(self, e: _Multiset__E, int: int, int2: int) -> bool: ...
    @typing.overload
    def setCount(self, e: _Multiset__E, int: int) -> int: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_Multiset__E]: ...
    def toString(self) -> str: ...
    class Entry(typing.Generic[_Multiset__Entry__E]):
        """
        Java class 'com.google.common.collect.Multiset$Entry'
        
        """
        def equals(self, object: typing.Any) -> bool: ...
        def getCount(self) -> int: ...
        def getElement(self) -> _Multiset__Entry__E: ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...

class Multisets:
    """
    Java class 'com.google.common.collect.Multisets'
    
        Extends:
            java.lang.Object
    
    """
    @staticmethod
    def containsOccurrences(multiset: Multiset[typing.Any], multiset2: Multiset[typing.Any]) -> bool: ...
    _copyHighestCountFirst__E = typing.TypeVar('_copyHighestCountFirst__E')  # <E>
    @staticmethod
    def copyHighestCountFirst(multiset: Multiset[_copyHighestCountFirst__E]) -> 'ImmutableMultiset'[_copyHighestCountFirst__E]: ...
    _difference__E = typing.TypeVar('_difference__E')  # <E>
    @staticmethod
    def difference(multiset: Multiset[_difference__E], multiset2: Multiset[typing.Any]) -> Multiset[_difference__E]: ...
    _filter__E = typing.TypeVar('_filter__E')  # <E>
    @staticmethod
    def filter(multiset: Multiset[_filter__E], predicate: typing.Union[com.google.common.base.Predicate[_filter__E], typing.Callable[[_filter__E], bool]]) -> Multiset[_filter__E]: ...
    _immutableEntry__E = typing.TypeVar('_immutableEntry__E')  # <E>
    @staticmethod
    def immutableEntry(e: _immutableEntry__E, int: int) -> Multiset.Entry[_immutableEntry__E]: ...
    _intersection__E = typing.TypeVar('_intersection__E')  # <E>
    @staticmethod
    def intersection(multiset: Multiset[_intersection__E], multiset2: Multiset[typing.Any]) -> Multiset[_intersection__E]: ...
    @typing.overload
    @staticmethod
    def removeOccurrences(multiset: Multiset[typing.Any], multiset2: Multiset[typing.Any]) -> bool: ...
    @typing.overload
    @staticmethod
    def removeOccurrences(multiset: Multiset[typing.Any], iterable: java.lang.Iterable[typing.Any]) -> bool: ...
    @staticmethod
    def retainOccurrences(multiset: Multiset[typing.Any], multiset2: Multiset[typing.Any]) -> bool: ...
    _sum__E = typing.TypeVar('_sum__E')  # <E>
    @staticmethod
    def sum(multiset: Multiset[_sum__E], multiset2: Multiset[_sum__E]) -> Multiset[_sum__E]: ...
    _toMultiset__T = typing.TypeVar('_toMultiset__T')  # <T>
    _toMultiset__E = typing.TypeVar('_toMultiset__E')  # <E>
    _toMultiset__M = typing.TypeVar('_toMultiset__M', bound=Multiset)  # <M>
    @staticmethod
    def toMultiset(function: typing.Union[java.util.function.Function[_toMultiset__T, _toMultiset__E], typing.Callable[[_toMultiset__T], _toMultiset__E]], toIntFunction: typing.Union[java.util.function.ToIntFunction[_toMultiset__T], typing.Callable[[_toMultiset__T], int]], supplier: typing.Union[java.util.function.Supplier[_toMultiset__M], typing.Callable[[], _toMultiset__M]]) -> java.util.stream.Collector[_toMultiset__T, typing.Any, _toMultiset__M]: ...
    _union__E = typing.TypeVar('_union__E')  # <E>
    @staticmethod
    def union(multiset: Multiset[_union__E], multiset2: Multiset[_union__E]) -> Multiset[_union__E]: ...
    _unmodifiableMultiset_0__E = typing.TypeVar('_unmodifiableMultiset_0__E')  # <E>
    _unmodifiableMultiset_1__E = typing.TypeVar('_unmodifiableMultiset_1__E')  # <E>
    @typing.overload
    @staticmethod
    def unmodifiableMultiset(immutableMultiset: 'ImmutableMultiset'[_unmodifiableMultiset_0__E]) -> Multiset[_unmodifiableMultiset_0__E]: ...
    @typing.overload
    @staticmethod
    def unmodifiableMultiset(multiset: Multiset[_unmodifiableMultiset_1__E]) -> Multiset[_unmodifiableMultiset_1__E]: ...
    _unmodifiableSortedMultiset__E = typing.TypeVar('_unmodifiableSortedMultiset__E')  # <E>
    @staticmethod
    def unmodifiableSortedMultiset(sortedMultiset: 'SortedMultiset'[_unmodifiableSortedMultiset__E]) -> 'SortedMultiset'[_unmodifiableSortedMultiset__E]: ...

class ObjectArrays:
    """
    Java class 'com.google.common.collect.ObjectArrays'
    
        Extends:
            java.lang.Object
    
    """
    _concat_0__T = typing.TypeVar('_concat_0__T')  # <T>
    _concat_1__T = typing.TypeVar('_concat_1__T')  # <T>
    _concat_2__T = typing.TypeVar('_concat_2__T')  # <T>
    @typing.overload
    @staticmethod
    def concat(t: _concat_0__T, tArray: typing.List[_concat_0__T]) -> typing.List[_concat_0__T]: ...
    @typing.overload
    @staticmethod
    def concat(tArray: typing.List[_concat_1__T], t2: _concat_1__T) -> typing.List[_concat_1__T]: ...
    @typing.overload
    @staticmethod
    def concat(tArray: typing.List[_concat_2__T], tArray2: typing.List[_concat_2__T], class_: typing.Type[_concat_2__T]) -> typing.List[_concat_2__T]: ...
    _newArray_0__T = typing.TypeVar('_newArray_0__T')  # <T>
    _newArray_1__T = typing.TypeVar('_newArray_1__T')  # <T>
    @typing.overload
    @staticmethod
    def newArray(class_: typing.Type[_newArray_0__T], int: int) -> typing.List[_newArray_0__T]: ...
    @typing.overload
    @staticmethod
    def newArray(tArray: typing.List[_newArray_1__T], int: int) -> typing.List[_newArray_1__T]: ...

_Ordering__T = typing.TypeVar('_Ordering__T')  # <T>
class Ordering(java.util.Comparator[_Ordering__T], typing.Generic[_Ordering__T]):
    """
    Java class 'com.google.common.collect.Ordering'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.Comparator
    
    """
    @staticmethod
    def allEqual() -> 'Ordering'[typing.Any]: ...
    @staticmethod
    def arbitrary() -> 'Ordering'[typing.Any]: ...
    def binarySearch(self, list: java.util.List[_Ordering__T], t: _Ordering__T) -> int: ...
    def compare(self, t: _Ordering__T, t2: _Ordering__T) -> int: ...
    _compound_0__U = typing.TypeVar('_compound_0__U')  # <U>
    _compound_1__T = typing.TypeVar('_compound_1__T')  # <T>
    @typing.overload
    def compound(self, comparator: typing.Union[java.util.Comparator[_compound_0__U], typing.Callable[[_compound_0__U, _compound_0__U], int]]) -> 'Ordering'[_compound_0__U]: ...
    @typing.overload
    @staticmethod
    def compound(iterable: java.lang.Iterable[java.util.Comparator[_compound_1__T]]) -> 'Ordering'[_compound_1__T]: ...
    _explicit_0__T = typing.TypeVar('_explicit_0__T')  # <T>
    _explicit_1__T = typing.TypeVar('_explicit_1__T')  # <T>
    @typing.overload
    @staticmethod
    def explicit(t: _explicit_0__T, tArray: typing.List[_explicit_0__T]) -> 'Ordering'[_explicit_0__T]: ...
    @typing.overload
    @staticmethod
    def explicit(list: java.util.List[_explicit_1__T]) -> 'Ordering'[_explicit_1__T]: ...
    _greatestOf_0__E = typing.TypeVar('_greatestOf_0__E')  # <E>
    _greatestOf_1__E = typing.TypeVar('_greatestOf_1__E')  # <E>
    @typing.overload
    def greatestOf(self, iterable: java.lang.Iterable[_greatestOf_0__E], int: int) -> java.util.List[_greatestOf_0__E]: ...
    @typing.overload
    def greatestOf(self, iterator: java.util.Iterator[_greatestOf_1__E], int: int) -> java.util.List[_greatestOf_1__E]: ...
    _immutableSortedCopy__E = typing.TypeVar('_immutableSortedCopy__E')  # <E>
    def immutableSortedCopy(self, iterable: java.lang.Iterable[_immutableSortedCopy__E]) -> 'ImmutableList'[_immutableSortedCopy__E]: ...
    def isOrdered(self, iterable: java.lang.Iterable[_Ordering__T]) -> bool: ...
    def isStrictlyOrdered(self, iterable: java.lang.Iterable[_Ordering__T]) -> bool: ...
    _leastOf_0__E = typing.TypeVar('_leastOf_0__E')  # <E>
    _leastOf_1__E = typing.TypeVar('_leastOf_1__E')  # <E>
    @typing.overload
    def leastOf(self, iterable: java.lang.Iterable[_leastOf_0__E], int: int) -> java.util.List[_leastOf_0__E]: ...
    @typing.overload
    def leastOf(self, iterator: java.util.Iterator[_leastOf_1__E], int: int) -> java.util.List[_leastOf_1__E]: ...
    _lexicographical__S = typing.TypeVar('_lexicographical__S')  # <S>
    def lexicographical(self) -> 'Ordering'[java.lang.Iterable[_lexicographical__S]]: ...
    _max_0__E = typing.TypeVar('_max_0__E')  # <E>
    _max_1__E = typing.TypeVar('_max_1__E')  # <E>
    _max_2__E = typing.TypeVar('_max_2__E')  # <E>
    _max_3__E = typing.TypeVar('_max_3__E')  # <E>
    @typing.overload
    def max(self, iterable: java.lang.Iterable[_max_0__E]) -> _max_0__E: ...
    @typing.overload
    def max(self, e: _max_1__E, e2: _max_1__E) -> _max_1__E: ...
    @typing.overload
    def max(self, e: _max_2__E, e2: _max_2__E, e3: _max_2__E, eArray: typing.List[_max_2__E]) -> _max_2__E: ...
    @typing.overload
    def max(self, iterator: java.util.Iterator[_max_3__E]) -> _max_3__E: ...
    _min_0__E = typing.TypeVar('_min_0__E')  # <E>
    _min_1__E = typing.TypeVar('_min_1__E')  # <E>
    _min_2__E = typing.TypeVar('_min_2__E')  # <E>
    _min_3__E = typing.TypeVar('_min_3__E')  # <E>
    @typing.overload
    def min(self, iterable: java.lang.Iterable[_min_0__E]) -> _min_0__E: ...
    @typing.overload
    def min(self, e: _min_1__E, e2: _min_1__E) -> _min_1__E: ...
    @typing.overload
    def min(self, e: _min_2__E, e2: _min_2__E, e3: _min_2__E, eArray: typing.List[_min_2__E]) -> _min_2__E: ...
    @typing.overload
    def min(self, iterator: java.util.Iterator[_min_3__E]) -> _min_3__E: ...
    _natural__C = typing.TypeVar('_natural__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def natural() -> 'Ordering'[_natural__C]: ...
    _nullsFirst__S = typing.TypeVar('_nullsFirst__S')  # <S>
    def nullsFirst(self) -> 'Ordering'[_nullsFirst__S]: ...
    _nullsLast__S = typing.TypeVar('_nullsLast__S')  # <S>
    def nullsLast(self) -> 'Ordering'[_nullsLast__S]: ...
    _onResultOf__F = typing.TypeVar('_onResultOf__F')  # <F>
    def onResultOf(self, function: typing.Union[com.google.common.base.Function[_onResultOf__F, _Ordering__T], typing.Callable[[_onResultOf__F], _Ordering__T]]) -> 'Ordering'[_onResultOf__F]: ...
    _reverse__S = typing.TypeVar('_reverse__S')  # <S>
    def reverse(self) -> 'Ordering'[_reverse__S]: ...
    _sortedCopy__E = typing.TypeVar('_sortedCopy__E')  # <E>
    def sortedCopy(self, iterable: java.lang.Iterable[_sortedCopy__E]) -> java.util.List[_sortedCopy__E]: ...
    @staticmethod
    def usingToString() -> 'Ordering'[typing.Any]: ...

_PeekingIterator__E = typing.TypeVar('_PeekingIterator__E')  # <E>
class PeekingIterator(java.util.Iterator[_PeekingIterator__E], typing.Generic[_PeekingIterator__E]):
    """
    Java class 'com.google.common.collect.PeekingIterator'
    
        Interfaces:
            java.util.Iterator
    
    """
    def next(self) -> _PeekingIterator__E: ...
    def peek(self) -> _PeekingIterator__E: ...
    def remove(self) -> None: ...

class Queues:
    """
    Java class 'com.google.common.collect.Queues'
    
        Extends:
            java.lang.Object
    
    """
    _drain_0__E = typing.TypeVar('_drain_0__E')  # <E>
    _drain_1__E = typing.TypeVar('_drain_1__E')  # <E>
    @typing.overload
    @staticmethod
    def drain(blockingQueue: java.util.concurrent.BlockingQueue[_drain_0__E], collection: typing.Union[java.util.Collection[_drain_0__E], typing.Sequence[_drain_0__E]], int: int, duration: java.time.Duration) -> int: ...
    @typing.overload
    @staticmethod
    def drain(blockingQueue: java.util.concurrent.BlockingQueue[_drain_1__E], collection: typing.Union[java.util.Collection[_drain_1__E], typing.Sequence[_drain_1__E]], int: int, long: int, timeUnit: java.util.concurrent.TimeUnit) -> int: ...
    _drainUninterruptibly_0__E = typing.TypeVar('_drainUninterruptibly_0__E')  # <E>
    _drainUninterruptibly_1__E = typing.TypeVar('_drainUninterruptibly_1__E')  # <E>
    @typing.overload
    @staticmethod
    def drainUninterruptibly(blockingQueue: java.util.concurrent.BlockingQueue[_drainUninterruptibly_0__E], collection: typing.Union[java.util.Collection[_drainUninterruptibly_0__E], typing.Sequence[_drainUninterruptibly_0__E]], int: int, duration: java.time.Duration) -> int: ...
    @typing.overload
    @staticmethod
    def drainUninterruptibly(blockingQueue: java.util.concurrent.BlockingQueue[_drainUninterruptibly_1__E], collection: typing.Union[java.util.Collection[_drainUninterruptibly_1__E], typing.Sequence[_drainUninterruptibly_1__E]], int: int, long: int, timeUnit: java.util.concurrent.TimeUnit) -> int: ...
    _newArrayBlockingQueue__E = typing.TypeVar('_newArrayBlockingQueue__E')  # <E>
    @staticmethod
    def newArrayBlockingQueue(int: int) -> java.util.concurrent.ArrayBlockingQueue[_newArrayBlockingQueue__E]: ...
    _newArrayDeque_0__E = typing.TypeVar('_newArrayDeque_0__E')  # <E>
    _newArrayDeque_1__E = typing.TypeVar('_newArrayDeque_1__E')  # <E>
    @typing.overload
    @staticmethod
    def newArrayDeque() -> java.util.ArrayDeque[_newArrayDeque_0__E]: ...
    @typing.overload
    @staticmethod
    def newArrayDeque(iterable: java.lang.Iterable[_newArrayDeque_1__E]) -> java.util.ArrayDeque[_newArrayDeque_1__E]: ...
    _newConcurrentLinkedQueue_0__E = typing.TypeVar('_newConcurrentLinkedQueue_0__E')  # <E>
    _newConcurrentLinkedQueue_1__E = typing.TypeVar('_newConcurrentLinkedQueue_1__E')  # <E>
    @typing.overload
    @staticmethod
    def newConcurrentLinkedQueue() -> java.util.concurrent.ConcurrentLinkedQueue[_newConcurrentLinkedQueue_0__E]: ...
    @typing.overload
    @staticmethod
    def newConcurrentLinkedQueue(iterable: java.lang.Iterable[_newConcurrentLinkedQueue_1__E]) -> java.util.concurrent.ConcurrentLinkedQueue[_newConcurrentLinkedQueue_1__E]: ...
    _newLinkedBlockingDeque_0__E = typing.TypeVar('_newLinkedBlockingDeque_0__E')  # <E>
    _newLinkedBlockingDeque_1__E = typing.TypeVar('_newLinkedBlockingDeque_1__E')  # <E>
    _newLinkedBlockingDeque_2__E = typing.TypeVar('_newLinkedBlockingDeque_2__E')  # <E>
    @typing.overload
    @staticmethod
    def newLinkedBlockingDeque() -> java.util.concurrent.LinkedBlockingDeque[_newLinkedBlockingDeque_0__E]: ...
    @typing.overload
    @staticmethod
    def newLinkedBlockingDeque(int: int) -> java.util.concurrent.LinkedBlockingDeque[_newLinkedBlockingDeque_1__E]: ...
    @typing.overload
    @staticmethod
    def newLinkedBlockingDeque(iterable: java.lang.Iterable[_newLinkedBlockingDeque_2__E]) -> java.util.concurrent.LinkedBlockingDeque[_newLinkedBlockingDeque_2__E]: ...
    _newLinkedBlockingQueue_0__E = typing.TypeVar('_newLinkedBlockingQueue_0__E')  # <E>
    _newLinkedBlockingQueue_1__E = typing.TypeVar('_newLinkedBlockingQueue_1__E')  # <E>
    _newLinkedBlockingQueue_2__E = typing.TypeVar('_newLinkedBlockingQueue_2__E')  # <E>
    @typing.overload
    @staticmethod
    def newLinkedBlockingQueue() -> java.util.concurrent.LinkedBlockingQueue[_newLinkedBlockingQueue_0__E]: ...
    @typing.overload
    @staticmethod
    def newLinkedBlockingQueue(int: int) -> java.util.concurrent.LinkedBlockingQueue[_newLinkedBlockingQueue_1__E]: ...
    @typing.overload
    @staticmethod
    def newLinkedBlockingQueue(iterable: java.lang.Iterable[_newLinkedBlockingQueue_2__E]) -> java.util.concurrent.LinkedBlockingQueue[_newLinkedBlockingQueue_2__E]: ...
    _newPriorityBlockingQueue_0__E = typing.TypeVar('_newPriorityBlockingQueue_0__E', bound=java.lang.Comparable)  # <E>
    _newPriorityBlockingQueue_1__E = typing.TypeVar('_newPriorityBlockingQueue_1__E', bound=java.lang.Comparable)  # <E>
    @typing.overload
    @staticmethod
    def newPriorityBlockingQueue() -> java.util.concurrent.PriorityBlockingQueue[_newPriorityBlockingQueue_0__E]: ...
    @typing.overload
    @staticmethod
    def newPriorityBlockingQueue(iterable: java.lang.Iterable[_newPriorityBlockingQueue_1__E]) -> java.util.concurrent.PriorityBlockingQueue[_newPriorityBlockingQueue_1__E]: ...
    _newPriorityQueue_0__E = typing.TypeVar('_newPriorityQueue_0__E', bound=java.lang.Comparable)  # <E>
    _newPriorityQueue_1__E = typing.TypeVar('_newPriorityQueue_1__E', bound=java.lang.Comparable)  # <E>
    @typing.overload
    @staticmethod
    def newPriorityQueue() -> java.util.PriorityQueue[_newPriorityQueue_0__E]: ...
    @typing.overload
    @staticmethod
    def newPriorityQueue(iterable: java.lang.Iterable[_newPriorityQueue_1__E]) -> java.util.PriorityQueue[_newPriorityQueue_1__E]: ...
    _newSynchronousQueue__E = typing.TypeVar('_newSynchronousQueue__E')  # <E>
    @staticmethod
    def newSynchronousQueue() -> java.util.concurrent.SynchronousQueue[_newSynchronousQueue__E]: ...
    _synchronizedDeque__E = typing.TypeVar('_synchronizedDeque__E')  # <E>
    @staticmethod
    def synchronizedDeque(deque: java.util.Deque[_synchronizedDeque__E]) -> java.util.Deque[_synchronizedDeque__E]: ...
    _synchronizedQueue__E = typing.TypeVar('_synchronizedQueue__E')  # <E>
    @staticmethod
    def synchronizedQueue(queue: java.util.Queue[_synchronizedQueue__E]) -> java.util.Queue[_synchronizedQueue__E]: ...

_RangeMap__K = typing.TypeVar('_RangeMap__K', bound=java.lang.Comparable)  # <K>
_RangeMap__V = typing.TypeVar('_RangeMap__V')  # <V>
class RangeMap(typing.Generic[_RangeMap__K, _RangeMap__V]):
    """
    Java class 'com.google.common.collect.RangeMap'
    
    """
    def asDescendingMapOfRanges(self) -> java.util.Map['Range'[_RangeMap__K], _RangeMap__V]: ...
    def asMapOfRanges(self) -> java.util.Map['Range'[_RangeMap__K], _RangeMap__V]: ...
    def clear(self) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, k: _RangeMap__K) -> _RangeMap__V: ...
    def getEntry(self, k: _RangeMap__K) -> java.util.Map.Entry['Range'[_RangeMap__K], _RangeMap__V]: ...
    def hashCode(self) -> int: ...
    def merge(self, range: 'Range'[_RangeMap__K], v: _RangeMap__V, biFunction: typing.Union[java.util.function.BiFunction[_RangeMap__V, _RangeMap__V, _RangeMap__V], typing.Callable[[_RangeMap__V, _RangeMap__V], _RangeMap__V]]) -> None: ...
    def put(self, range: 'Range'[_RangeMap__K], v: _RangeMap__V) -> None: ...
    def putAll(self, rangeMap: 'RangeMap'[_RangeMap__K, _RangeMap__V]) -> None: ...
    def putCoalescing(self, range: 'Range'[_RangeMap__K], v: _RangeMap__V) -> None: ...
    def remove(self, range: 'Range'[_RangeMap__K]) -> None: ...
    def span(self) -> 'Range'[_RangeMap__K]: ...
    def subRangeMap(self, range: 'Range'[_RangeMap__K]) -> 'RangeMap'[_RangeMap__K, _RangeMap__V]: ...
    def toString(self) -> str: ...

_RangeSet__C = typing.TypeVar('_RangeSet__C', bound=java.lang.Comparable)  # <C>
class RangeSet(typing.Generic[_RangeSet__C]):
    """
    Java class 'com.google.common.collect.RangeSet'
    
    """
    def add(self, range: 'Range'[_RangeSet__C]) -> None: ...
    @typing.overload
    def addAll(self, rangeSet: 'RangeSet'[_RangeSet__C]) -> None: ...
    @typing.overload
    def addAll(self, iterable: java.lang.Iterable['Range'[_RangeSet__C]]) -> None: ...
    def asDescendingSetOfRanges(self) -> java.util.Set['Range'[_RangeSet__C]]: ...
    def asRanges(self) -> java.util.Set['Range'[_RangeSet__C]]: ...
    def clear(self) -> None: ...
    def complement(self) -> 'RangeSet'[_RangeSet__C]: ...
    def contains(self, c: _RangeSet__C) -> bool: ...
    def encloses(self, range: 'Range'[_RangeSet__C]) -> bool: ...
    @typing.overload
    def enclosesAll(self, rangeSet: 'RangeSet'[_RangeSet__C]) -> bool: ...
    @typing.overload
    def enclosesAll(self, iterable: java.lang.Iterable['Range'[_RangeSet__C]]) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def intersects(self, range: 'Range'[_RangeSet__C]) -> bool: ...
    def isEmpty(self) -> bool: ...
    def rangeContaining(self, c: _RangeSet__C) -> 'Range'[_RangeSet__C]: ...
    def remove(self, range: 'Range'[_RangeSet__C]) -> None: ...
    @typing.overload
    def removeAll(self, rangeSet: 'RangeSet'[_RangeSet__C]) -> None: ...
    @typing.overload
    def removeAll(self, iterable: java.lang.Iterable['Range'[_RangeSet__C]]) -> None: ...
    def span(self) -> 'Range'[_RangeSet__C]: ...
    def subRangeSet(self, range: 'Range'[_RangeSet__C]) -> 'RangeSet'[_RangeSet__C]: ...
    def toString(self) -> str: ...

_Sets__SetView__E = typing.TypeVar('_Sets__SetView__E')  # <E>
class Sets:
    """
    Java class 'com.google.common.collect.Sets'
    
        Extends:
            java.lang.Object
    
    """
    _cartesianProduct_0__B = typing.TypeVar('_cartesianProduct_0__B')  # <B>
    _cartesianProduct_1__B = typing.TypeVar('_cartesianProduct_1__B')  # <B>
    @typing.overload
    @staticmethod
    def cartesianProduct(list: java.util.List[java.util.Set[_cartesianProduct_0__B]]) -> java.util.Set[java.util.List[_cartesianProduct_0__B]]: ...
    @typing.overload
    @staticmethod
    def cartesianProduct(setArray: typing.List[java.util.Set[_cartesianProduct_1__B]]) -> java.util.Set[java.util.List[_cartesianProduct_1__B]]: ...
    _combinations__E = typing.TypeVar('_combinations__E')  # <E>
    @staticmethod
    def combinations(set: java.util.Set[_combinations__E], int: int) -> java.util.Set[java.util.Set[_combinations__E]]: ...
    _complementOf_0__E = typing.TypeVar('_complementOf_0__E', bound=java.lang.Enum)  # <E>
    _complementOf_1__E = typing.TypeVar('_complementOf_1__E', bound=java.lang.Enum)  # <E>
    @typing.overload
    @staticmethod
    def complementOf(collection: typing.Union[java.util.Collection[_complementOf_0__E], typing.Sequence[_complementOf_0__E]]) -> java.util.EnumSet[_complementOf_0__E]: ...
    @typing.overload
    @staticmethod
    def complementOf(collection: typing.Union[java.util.Collection[_complementOf_1__E], typing.Sequence[_complementOf_1__E]], class_: typing.Type[_complementOf_1__E]) -> java.util.EnumSet[_complementOf_1__E]: ...
    _difference__E = typing.TypeVar('_difference__E')  # <E>
    @staticmethod
    def difference(set: java.util.Set[_difference__E], set2: java.util.Set[typing.Any]) -> 'Sets.SetView'[_difference__E]: ...
    _filter_0__E = typing.TypeVar('_filter_0__E')  # <E>
    _filter_1__E = typing.TypeVar('_filter_1__E')  # <E>
    _filter_2__E = typing.TypeVar('_filter_2__E')  # <E>
    @typing.overload
    @staticmethod
    def filter(navigableSet: java.util.NavigableSet[_filter_0__E], predicate: typing.Union[com.google.common.base.Predicate[_filter_0__E], typing.Callable[[_filter_0__E], bool]]) -> java.util.NavigableSet[_filter_0__E]: ...
    @typing.overload
    @staticmethod
    def filter(set: java.util.Set[_filter_1__E], predicate: typing.Union[com.google.common.base.Predicate[_filter_1__E], typing.Callable[[_filter_1__E], bool]]) -> java.util.Set[_filter_1__E]: ...
    @typing.overload
    @staticmethod
    def filter(sortedSet: java.util.SortedSet[_filter_2__E], predicate: typing.Union[com.google.common.base.Predicate[_filter_2__E], typing.Callable[[_filter_2__E], bool]]) -> java.util.SortedSet[_filter_2__E]: ...
    _immutableEnumSet_0__E = typing.TypeVar('_immutableEnumSet_0__E', bound=java.lang.Enum)  # <E>
    _immutableEnumSet_1__E = typing.TypeVar('_immutableEnumSet_1__E', bound=java.lang.Enum)  # <E>
    @typing.overload
    @staticmethod
    def immutableEnumSet(e: _immutableEnumSet_0__E, eArray: typing.List[_immutableEnumSet_0__E]) -> 'ImmutableSet'[_immutableEnumSet_0__E]: ...
    @typing.overload
    @staticmethod
    def immutableEnumSet(iterable: java.lang.Iterable[_immutableEnumSet_1__E]) -> 'ImmutableSet'[_immutableEnumSet_1__E]: ...
    _intersection__E = typing.TypeVar('_intersection__E')  # <E>
    @staticmethod
    def intersection(set: java.util.Set[_intersection__E], set2: java.util.Set[typing.Any]) -> 'Sets.SetView'[_intersection__E]: ...
    _newConcurrentHashSet_0__E = typing.TypeVar('_newConcurrentHashSet_0__E')  # <E>
    _newConcurrentHashSet_1__E = typing.TypeVar('_newConcurrentHashSet_1__E')  # <E>
    @typing.overload
    @staticmethod
    def newConcurrentHashSet() -> java.util.Set[_newConcurrentHashSet_0__E]: ...
    @typing.overload
    @staticmethod
    def newConcurrentHashSet(iterable: java.lang.Iterable[_newConcurrentHashSet_1__E]) -> java.util.Set[_newConcurrentHashSet_1__E]: ...
    _newCopyOnWriteArraySet_0__E = typing.TypeVar('_newCopyOnWriteArraySet_0__E')  # <E>
    _newCopyOnWriteArraySet_1__E = typing.TypeVar('_newCopyOnWriteArraySet_1__E')  # <E>
    @typing.overload
    @staticmethod
    def newCopyOnWriteArraySet() -> java.util.concurrent.CopyOnWriteArraySet[_newCopyOnWriteArraySet_0__E]: ...
    @typing.overload
    @staticmethod
    def newCopyOnWriteArraySet(iterable: java.lang.Iterable[_newCopyOnWriteArraySet_1__E]) -> java.util.concurrent.CopyOnWriteArraySet[_newCopyOnWriteArraySet_1__E]: ...
    _newEnumSet__E = typing.TypeVar('_newEnumSet__E', bound=java.lang.Enum)  # <E>
    @staticmethod
    def newEnumSet(iterable: java.lang.Iterable[_newEnumSet__E], class_: typing.Type[_newEnumSet__E]) -> java.util.EnumSet[_newEnumSet__E]: ...
    _newHashSet_0__E = typing.TypeVar('_newHashSet_0__E')  # <E>
    _newHashSet_1__E = typing.TypeVar('_newHashSet_1__E')  # <E>
    _newHashSet_2__E = typing.TypeVar('_newHashSet_2__E')  # <E>
    _newHashSet_3__E = typing.TypeVar('_newHashSet_3__E')  # <E>
    @typing.overload
    @staticmethod
    def newHashSet() -> java.util.HashSet[_newHashSet_0__E]: ...
    @typing.overload
    @staticmethod
    def newHashSet(iterable: java.lang.Iterable[_newHashSet_1__E]) -> java.util.HashSet[_newHashSet_1__E]: ...
    @typing.overload
    @staticmethod
    def newHashSet(eArray: typing.List[_newHashSet_2__E]) -> java.util.HashSet[_newHashSet_2__E]: ...
    @typing.overload
    @staticmethod
    def newHashSet(iterator: java.util.Iterator[_newHashSet_3__E]) -> java.util.HashSet[_newHashSet_3__E]: ...
    _newHashSetWithExpectedSize__E = typing.TypeVar('_newHashSetWithExpectedSize__E')  # <E>
    @staticmethod
    def newHashSetWithExpectedSize(int: int) -> java.util.HashSet[_newHashSetWithExpectedSize__E]: ...
    _newIdentityHashSet__E = typing.TypeVar('_newIdentityHashSet__E')  # <E>
    @staticmethod
    def newIdentityHashSet() -> java.util.Set[_newIdentityHashSet__E]: ...
    _newLinkedHashSet_0__E = typing.TypeVar('_newLinkedHashSet_0__E')  # <E>
    _newLinkedHashSet_1__E = typing.TypeVar('_newLinkedHashSet_1__E')  # <E>
    @typing.overload
    @staticmethod
    def newLinkedHashSet() -> java.util.LinkedHashSet[_newLinkedHashSet_0__E]: ...
    @typing.overload
    @staticmethod
    def newLinkedHashSet(iterable: java.lang.Iterable[_newLinkedHashSet_1__E]) -> java.util.LinkedHashSet[_newLinkedHashSet_1__E]: ...
    _newLinkedHashSetWithExpectedSize__E = typing.TypeVar('_newLinkedHashSetWithExpectedSize__E')  # <E>
    @staticmethod
    def newLinkedHashSetWithExpectedSize(int: int) -> java.util.LinkedHashSet[_newLinkedHashSetWithExpectedSize__E]: ...
    _newSetFromMap__E = typing.TypeVar('_newSetFromMap__E')  # <E>
    @staticmethod
    def newSetFromMap(map: typing.Union[java.util.Map[_newSetFromMap__E, bool], typing.Mapping[_newSetFromMap__E, bool]]) -> java.util.Set[_newSetFromMap__E]: ...
    _newTreeSet_0__E = typing.TypeVar('_newTreeSet_0__E', bound=java.lang.Comparable)  # <E>
    _newTreeSet_1__E = typing.TypeVar('_newTreeSet_1__E', bound=java.lang.Comparable)  # <E>
    _newTreeSet_2__E = typing.TypeVar('_newTreeSet_2__E')  # <E>
    @typing.overload
    @staticmethod
    def newTreeSet() -> java.util.TreeSet[_newTreeSet_0__E]: ...
    @typing.overload
    @staticmethod
    def newTreeSet(iterable: java.lang.Iterable[_newTreeSet_1__E]) -> java.util.TreeSet[_newTreeSet_1__E]: ...
    @typing.overload
    @staticmethod
    def newTreeSet(comparator: typing.Union[java.util.Comparator[_newTreeSet_2__E], typing.Callable[[_newTreeSet_2__E, _newTreeSet_2__E], int]]) -> java.util.TreeSet[_newTreeSet_2__E]: ...
    _powerSet__E = typing.TypeVar('_powerSet__E')  # <E>
    @staticmethod
    def powerSet(set: java.util.Set[_powerSet__E]) -> java.util.Set[java.util.Set[_powerSet__E]]: ...
    _subSet__K = typing.TypeVar('_subSet__K', bound=java.lang.Comparable)  # <K>
    @staticmethod
    def subSet(navigableSet: java.util.NavigableSet[_subSet__K], range: 'Range'[_subSet__K]) -> java.util.NavigableSet[_subSet__K]: ...
    _symmetricDifference__E = typing.TypeVar('_symmetricDifference__E')  # <E>
    @staticmethod
    def symmetricDifference(set: java.util.Set[_symmetricDifference__E], set2: java.util.Set[_symmetricDifference__E]) -> 'Sets.SetView'[_symmetricDifference__E]: ...
    _synchronizedNavigableSet__E = typing.TypeVar('_synchronizedNavigableSet__E')  # <E>
    @staticmethod
    def synchronizedNavigableSet(navigableSet: java.util.NavigableSet[_synchronizedNavigableSet__E]) -> java.util.NavigableSet[_synchronizedNavigableSet__E]: ...
    _toImmutableEnumSet__E = typing.TypeVar('_toImmutableEnumSet__E', bound=java.lang.Enum)  # <E>
    @staticmethod
    def toImmutableEnumSet() -> java.util.stream.Collector[_toImmutableEnumSet__E, typing.Any, 'ImmutableSet'[_toImmutableEnumSet__E]]: ...
    _union__E = typing.TypeVar('_union__E')  # <E>
    @staticmethod
    def union(set: java.util.Set[_union__E], set2: java.util.Set[_union__E]) -> 'Sets.SetView'[_union__E]: ...
    _unmodifiableNavigableSet__E = typing.TypeVar('_unmodifiableNavigableSet__E')  # <E>
    @staticmethod
    def unmodifiableNavigableSet(navigableSet: java.util.NavigableSet[_unmodifiableNavigableSet__E]) -> java.util.NavigableSet[_unmodifiableNavigableSet__E]: ...
    class SetView(java.util.AbstractSet[_Sets__SetView__E], typing.Generic[_Sets__SetView__E]):
        """
        Java class 'com.google.common.collect.Sets$SetView'
        
            Extends:
                java.util.AbstractSet
        
        """
        def add(self, e: _Sets__SetView__E) -> bool: ...
        def addAll(self, collection: typing.Union[java.util.Collection[_Sets__SetView__E], typing.Sequence[_Sets__SetView__E]]) -> bool: ...
        def clear(self) -> None: ...
        _copyInto__S = typing.TypeVar('_copyInto__S', bound=java.util.Set)  # <S>
        def copyInto(self, s2: _copyInto__S) -> _copyInto__S: ...
        def immutableCopy(self) -> 'ImmutableSet'[_Sets__SetView__E]: ...
        def iterator(self) -> 'UnmodifiableIterator'[_Sets__SetView__E]: ...
        def remove(self, object: typing.Any) -> bool: ...
        def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
        def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_Sets__SetView__E], typing.Callable[[_Sets__SetView__E], bool]]) -> bool: ...
        def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...

_Streams__DoubleFunctionWithIndex__R = typing.TypeVar('_Streams__DoubleFunctionWithIndex__R')  # <R>
_Streams__FunctionWithIndex__T = typing.TypeVar('_Streams__FunctionWithIndex__T')  # <T>
_Streams__FunctionWithIndex__R = typing.TypeVar('_Streams__FunctionWithIndex__R')  # <R>
_Streams__IntFunctionWithIndex__R = typing.TypeVar('_Streams__IntFunctionWithIndex__R')  # <R>
_Streams__LongFunctionWithIndex__R = typing.TypeVar('_Streams__LongFunctionWithIndex__R')  # <R>
class Streams:
    """
    Java class 'com.google.common.collect.Streams'
    
        Extends:
            java.lang.Object
    
    """
    _concat_3__T = typing.TypeVar('_concat_3__T')  # <T>
    @typing.overload
    @staticmethod
    def concat(doubleStreamArray: typing.List[java.util.stream.DoubleStream]) -> java.util.stream.DoubleStream: ...
    @typing.overload
    @staticmethod
    def concat(intStreamArray: typing.List[java.util.stream.IntStream]) -> java.util.stream.IntStream: ...
    @typing.overload
    @staticmethod
    def concat(longStreamArray: typing.List[java.util.stream.LongStream]) -> java.util.stream.LongStream: ...
    @typing.overload
    @staticmethod
    def concat(streamArray: typing.List[java.util.stream.Stream[_concat_3__T]]) -> java.util.stream.Stream[_concat_3__T]: ...
    _findLast_0__T = typing.TypeVar('_findLast_0__T')  # <T>
    @typing.overload
    @staticmethod
    def findLast(stream: java.util.stream.Stream[_findLast_0__T]) -> java.util.Optional[_findLast_0__T]: ...
    @typing.overload
    @staticmethod
    def findLast(doubleStream: java.util.stream.DoubleStream) -> java.util.OptionalDouble: ...
    @typing.overload
    @staticmethod
    def findLast(intStream: java.util.stream.IntStream) -> java.util.OptionalInt: ...
    @typing.overload
    @staticmethod
    def findLast(longStream: java.util.stream.LongStream) -> java.util.OptionalLong: ...
    _forEachPair__A = typing.TypeVar('_forEachPair__A')  # <A>
    _forEachPair__B = typing.TypeVar('_forEachPair__B')  # <B>
    @staticmethod
    def forEachPair(stream: java.util.stream.Stream[_forEachPair__A], stream2: java.util.stream.Stream[_forEachPair__B], biConsumer: typing.Union[java.util.function.BiConsumer[_forEachPair__A, _forEachPair__B], typing.Callable[[_forEachPair__A, _forEachPair__B], None]]) -> None: ...
    _mapWithIndex_0__R = typing.TypeVar('_mapWithIndex_0__R')  # <R>
    _mapWithIndex_1__R = typing.TypeVar('_mapWithIndex_1__R')  # <R>
    _mapWithIndex_2__R = typing.TypeVar('_mapWithIndex_2__R')  # <R>
    _mapWithIndex_3__T = typing.TypeVar('_mapWithIndex_3__T')  # <T>
    _mapWithIndex_3__R = typing.TypeVar('_mapWithIndex_3__R')  # <R>
    @typing.overload
    @staticmethod
    def mapWithIndex(doubleStream: java.util.stream.DoubleStream, doubleFunctionWithIndex: 'Streams.DoubleFunctionWithIndex'[_mapWithIndex_0__R]) -> java.util.stream.Stream[_mapWithIndex_0__R]: ...
    @typing.overload
    @staticmethod
    def mapWithIndex(intStream: java.util.stream.IntStream, intFunctionWithIndex: 'Streams.IntFunctionWithIndex'[_mapWithIndex_1__R]) -> java.util.stream.Stream[_mapWithIndex_1__R]: ...
    @typing.overload
    @staticmethod
    def mapWithIndex(longStream: java.util.stream.LongStream, longFunctionWithIndex: 'Streams.LongFunctionWithIndex'[_mapWithIndex_2__R]) -> java.util.stream.Stream[_mapWithIndex_2__R]: ...
    @typing.overload
    @staticmethod
    def mapWithIndex(stream: java.util.stream.Stream[_mapWithIndex_3__T], functionWithIndex: 'Streams.FunctionWithIndex'[_mapWithIndex_3__T, _mapWithIndex_3__R]) -> java.util.stream.Stream[_mapWithIndex_3__R]: ...
    _stream_3__T = typing.TypeVar('_stream_3__T')  # <T>
    _stream_4__T = typing.TypeVar('_stream_4__T')  # <T>
    _stream_5__T = typing.TypeVar('_stream_5__T')  # <T>
    _stream_6__T = typing.TypeVar('_stream_6__T')  # <T>
    _stream_7__T = typing.TypeVar('_stream_7__T')  # <T>
    @typing.overload
    @staticmethod
    def stream(optionalDouble: java.util.OptionalDouble) -> java.util.stream.DoubleStream: ...
    @typing.overload
    @staticmethod
    def stream(optionalInt: java.util.OptionalInt) -> java.util.stream.IntStream: ...
    @typing.overload
    @staticmethod
    def stream(optionalLong: java.util.OptionalLong) -> java.util.stream.LongStream: ...
    @typing.overload
    @staticmethod
    def stream(optional: com.google.common.base.Optional[_stream_3__T]) -> java.util.stream.Stream[_stream_3__T]: ...
    @typing.overload
    @staticmethod
    def stream(iterable: java.lang.Iterable[_stream_4__T]) -> java.util.stream.Stream[_stream_4__T]: ...
    @typing.overload
    @staticmethod
    def stream(collection: typing.Union[java.util.Collection[_stream_5__T], typing.Sequence[_stream_5__T]]) -> java.util.stream.Stream[_stream_5__T]: ...
    @typing.overload
    @staticmethod
    def stream(iterator: java.util.Iterator[_stream_6__T]) -> java.util.stream.Stream[_stream_6__T]: ...
    @typing.overload
    @staticmethod
    def stream(optional: java.util.Optional[_stream_7__T]) -> java.util.stream.Stream[_stream_7__T]: ...
    _zip__A = typing.TypeVar('_zip__A')  # <A>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__R = typing.TypeVar('_zip__R')  # <R>
    @staticmethod
    def zip(stream: java.util.stream.Stream[_zip__A], stream2: java.util.stream.Stream[_zip__B], biFunction: typing.Union[java.util.function.BiFunction[_zip__A, _zip__B, _zip__R], typing.Callable[[_zip__A, _zip__B], _zip__R]]) -> java.util.stream.Stream[_zip__R]: ...
    class DoubleFunctionWithIndex(typing.Generic[_Streams__DoubleFunctionWithIndex__R]):
        """
        Java class 'com.google.common.collect.Streams$DoubleFunctionWithIndex'
        
        """
        def apply(self, double: float, long: int) -> _Streams__DoubleFunctionWithIndex__R: ...
    class FunctionWithIndex(typing.Generic[_Streams__FunctionWithIndex__T, _Streams__FunctionWithIndex__R]):
        """
        Java class 'com.google.common.collect.Streams$FunctionWithIndex'
        
        """
        def apply(self, t: _Streams__FunctionWithIndex__T, long: int) -> _Streams__FunctionWithIndex__R: ...
    class IntFunctionWithIndex(typing.Generic[_Streams__IntFunctionWithIndex__R]):
        """
        Java class 'com.google.common.collect.Streams$IntFunctionWithIndex'
        
        """
        def apply(self, int: int, long: int) -> _Streams__IntFunctionWithIndex__R: ...
    class LongFunctionWithIndex(typing.Generic[_Streams__LongFunctionWithIndex__R]):
        """
        Java class 'com.google.common.collect.Streams$LongFunctionWithIndex'
        
        """
        def apply(self, long: int, long2: int) -> _Streams__LongFunctionWithIndex__R: ...

_Table__Cell__R = typing.TypeVar('_Table__Cell__R')  # <R>
_Table__Cell__C = typing.TypeVar('_Table__Cell__C')  # <C>
_Table__Cell__V = typing.TypeVar('_Table__Cell__V')  # <V>
_Table__R = typing.TypeVar('_Table__R')  # <R>
_Table__C = typing.TypeVar('_Table__C')  # <C>
_Table__V = typing.TypeVar('_Table__V')  # <V>
class Table(typing.Generic[_Table__R, _Table__C, _Table__V]):
    """
    Java class 'com.google.common.collect.Table'
    
    """
    def cellSet(self) -> java.util.Set['Table.Cell'[_Table__R, _Table__C, _Table__V]]: ...
    def clear(self) -> None: ...
    def column(self, c: _Table__C) -> java.util.Map[_Table__R, _Table__V]: ...
    def columnKeySet(self) -> java.util.Set[_Table__C]: ...
    def columnMap(self) -> java.util.Map[_Table__C, java.util.Map[_Table__R, _Table__V]]: ...
    def contains(self, object: typing.Any, object2: typing.Any) -> bool: ...
    def containsColumn(self, object: typing.Any) -> bool: ...
    def containsRow(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, object: typing.Any, object2: typing.Any) -> _Table__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def put(self, r: _Table__R, c: _Table__C, v: _Table__V) -> _Table__V: ...
    def putAll(self, table: 'Table'[_Table__R, _Table__C, _Table__V]) -> None: ...
    def remove(self, object: typing.Any, object2: typing.Any) -> _Table__V: ...
    def row(self, r: _Table__R) -> java.util.Map[_Table__C, _Table__V]: ...
    def rowKeySet(self) -> java.util.Set[_Table__R]: ...
    def rowMap(self) -> java.util.Map[_Table__R, java.util.Map[_Table__C, _Table__V]]: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Collection[_Table__V]: ...
    class Cell(typing.Generic[_Table__Cell__R, _Table__Cell__C, _Table__Cell__V]):
        """
        Java class 'com.google.common.collect.Table$Cell'
        
        """
        def equals(self, object: typing.Any) -> bool: ...
        def getColumnKey(self) -> _Table__Cell__C: ...
        def getRowKey(self) -> _Table__Cell__R: ...
        def getValue(self) -> _Table__Cell__V: ...
        def hashCode(self) -> int: ...

class Tables:
    """
    Java class 'com.google.common.collect.Tables'
    
        Extends:
            java.lang.Object
    
    """
    _immutableCell__R = typing.TypeVar('_immutableCell__R')  # <R>
    _immutableCell__C = typing.TypeVar('_immutableCell__C')  # <C>
    _immutableCell__V = typing.TypeVar('_immutableCell__V')  # <V>
    @staticmethod
    def immutableCell(r: _immutableCell__R, c: _immutableCell__C, v: _immutableCell__V) -> Table.Cell[_immutableCell__R, _immutableCell__C, _immutableCell__V]: ...
    _newCustomTable__R = typing.TypeVar('_newCustomTable__R')  # <R>
    _newCustomTable__C = typing.TypeVar('_newCustomTable__C')  # <C>
    _newCustomTable__V = typing.TypeVar('_newCustomTable__V')  # <V>
    @staticmethod
    def newCustomTable(map: typing.Union[java.util.Map[_newCustomTable__R, typing.Union[java.util.Map[_newCustomTable__C, _newCustomTable__V], typing.Mapping[_newCustomTable__C, _newCustomTable__V]]], typing.Mapping[_newCustomTable__R, typing.Union[java.util.Map[_newCustomTable__C, _newCustomTable__V], typing.Mapping[_newCustomTable__C, _newCustomTable__V]]]], supplier: typing.Union[com.google.common.base.Supplier[java.util.Map[_newCustomTable__C, _newCustomTable__V]], typing.Callable[[], java.util.Map[_newCustomTable__C, _newCustomTable__V]]]) -> Table[_newCustomTable__R, _newCustomTable__C, _newCustomTable__V]: ...
    _synchronizedTable__R = typing.TypeVar('_synchronizedTable__R')  # <R>
    _synchronizedTable__C = typing.TypeVar('_synchronizedTable__C')  # <C>
    _synchronizedTable__V = typing.TypeVar('_synchronizedTable__V')  # <V>
    @staticmethod
    def synchronizedTable(table: Table[_synchronizedTable__R, _synchronizedTable__C, _synchronizedTable__V]) -> Table[_synchronizedTable__R, _synchronizedTable__C, _synchronizedTable__V]: ...
    _toTable_0__T = typing.TypeVar('_toTable_0__T')  # <T>
    _toTable_0__R = typing.TypeVar('_toTable_0__R')  # <R>
    _toTable_0__C = typing.TypeVar('_toTable_0__C')  # <C>
    _toTable_0__V = typing.TypeVar('_toTable_0__V')  # <V>
    _toTable_0__I = typing.TypeVar('_toTable_0__I', bound=Table)  # <I>
    _toTable_1__T = typing.TypeVar('_toTable_1__T')  # <T>
    _toTable_1__R = typing.TypeVar('_toTable_1__R')  # <R>
    _toTable_1__C = typing.TypeVar('_toTable_1__C')  # <C>
    _toTable_1__V = typing.TypeVar('_toTable_1__V')  # <V>
    _toTable_1__I = typing.TypeVar('_toTable_1__I', bound=Table)  # <I>
    @typing.overload
    @staticmethod
    def toTable(function: typing.Union[java.util.function.Function[_toTable_0__T, _toTable_0__R], typing.Callable[[_toTable_0__T], _toTable_0__R]], function2: typing.Union[java.util.function.Function[_toTable_0__T, _toTable_0__C], typing.Callable[[_toTable_0__T], _toTable_0__C]], function3: typing.Union[java.util.function.Function[_toTable_0__T, _toTable_0__V], typing.Callable[[_toTable_0__T], _toTable_0__V]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_toTable_0__V], typing.Callable], supplier: typing.Union[java.util.function.Supplier[_toTable_0__I], typing.Callable[[], _toTable_0__I]]) -> java.util.stream.Collector[_toTable_0__T, typing.Any, _toTable_0__I]: ...
    @typing.overload
    @staticmethod
    def toTable(function: typing.Union[java.util.function.Function[_toTable_1__T, _toTable_1__R], typing.Callable[[_toTable_1__T], _toTable_1__R]], function2: typing.Union[java.util.function.Function[_toTable_1__T, _toTable_1__C], typing.Callable[[_toTable_1__T], _toTable_1__C]], function3: typing.Union[java.util.function.Function[_toTable_1__T, _toTable_1__V], typing.Callable[[_toTable_1__T], _toTable_1__V]], supplier: typing.Union[java.util.function.Supplier[_toTable_1__I], typing.Callable[[], _toTable_1__I]]) -> java.util.stream.Collector[_toTable_1__T, typing.Any, _toTable_1__I]: ...
    _transformValues__R = typing.TypeVar('_transformValues__R')  # <R>
    _transformValues__C = typing.TypeVar('_transformValues__C')  # <C>
    _transformValues__V1 = typing.TypeVar('_transformValues__V1')  # <V1>
    _transformValues__V2 = typing.TypeVar('_transformValues__V2')  # <V2>
    @staticmethod
    def transformValues(table: Table[_transformValues__R, _transformValues__C, _transformValues__V1], function: typing.Union[com.google.common.base.Function[_transformValues__V1, _transformValues__V2], typing.Callable[[_transformValues__V1], _transformValues__V2]]) -> Table[_transformValues__R, _transformValues__C, _transformValues__V2]: ...
    _transpose__R = typing.TypeVar('_transpose__R')  # <R>
    _transpose__C = typing.TypeVar('_transpose__C')  # <C>
    _transpose__V = typing.TypeVar('_transpose__V')  # <V>
    @staticmethod
    def transpose(table: Table[_transpose__R, _transpose__C, _transpose__V]) -> Table[_transpose__C, _transpose__R, _transpose__V]: ...
    _unmodifiableRowSortedTable__R = typing.TypeVar('_unmodifiableRowSortedTable__R')  # <R>
    _unmodifiableRowSortedTable__C = typing.TypeVar('_unmodifiableRowSortedTable__C')  # <C>
    _unmodifiableRowSortedTable__V = typing.TypeVar('_unmodifiableRowSortedTable__V')  # <V>
    @staticmethod
    def unmodifiableRowSortedTable(rowSortedTable: 'RowSortedTable'[_unmodifiableRowSortedTable__R, _unmodifiableRowSortedTable__C, _unmodifiableRowSortedTable__V]) -> 'RowSortedTable'[_unmodifiableRowSortedTable__R, _unmodifiableRowSortedTable__C, _unmodifiableRowSortedTable__V]: ...
    _unmodifiableTable__R = typing.TypeVar('_unmodifiableTable__R')  # <R>
    _unmodifiableTable__C = typing.TypeVar('_unmodifiableTable__C')  # <C>
    _unmodifiableTable__V = typing.TypeVar('_unmodifiableTable__V')  # <V>
    @staticmethod
    def unmodifiableTable(table: Table[_unmodifiableTable__R, _unmodifiableTable__C, _unmodifiableTable__V]) -> Table[_unmodifiableTable__R, _unmodifiableTable__C, _unmodifiableTable__V]: ...

_TreeTraverser__T = typing.TypeVar('_TreeTraverser__T')  # <T>
class TreeTraverser(typing.Generic[_TreeTraverser__T]):
    """
    Java class 'com.google.common.collect.TreeTraverser'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * TreeTraverser()
    
    """
    def __init__(self): ...
    def breadthFirstTraversal(self, t: _TreeTraverser__T) -> FluentIterable[_TreeTraverser__T]: ...
    def children(self, t: _TreeTraverser__T) -> java.lang.Iterable[_TreeTraverser__T]: ...
    def postOrderTraversal(self, t: _TreeTraverser__T) -> FluentIterable[_TreeTraverser__T]: ...
    def preOrderTraversal(self, t: _TreeTraverser__T) -> FluentIterable[_TreeTraverser__T]: ...
    _using__T = typing.TypeVar('_using__T')  # <T>
    @staticmethod
    def using(function: typing.Union[com.google.common.base.Function[_using__T, java.lang.Iterable[_using__T]], typing.Callable[[_using__T], java.lang.Iterable[_using__T]]]) -> 'TreeTraverser'[_using__T]: ...

_UnmodifiableIterator__E = typing.TypeVar('_UnmodifiableIterator__E')  # <E>
class UnmodifiableIterator(java.util.Iterator[_UnmodifiableIterator__E], typing.Generic[_UnmodifiableIterator__E]):
    """
    Java class 'com.google.common.collect.UnmodifiableIterator'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.Iterator
    
    """
    def remove(self) -> None: ...

_AbstractIterator__T = typing.TypeVar('_AbstractIterator__T')  # <T>
class AbstractIterator(UnmodifiableIterator[_AbstractIterator__T], typing.Generic[_AbstractIterator__T]):
    """
    Java class 'com.google.common.collect.AbstractIterator'
    
        Extends:
            com.google.common.collect.UnmodifiableIterator
    
    """
    def hasNext(self) -> bool: ...
    def next(self) -> _AbstractIterator__T: ...
    def peek(self) -> _AbstractIterator__T: ...

_AbstractSequentialIterator__T = typing.TypeVar('_AbstractSequentialIterator__T')  # <T>
class AbstractSequentialIterator(UnmodifiableIterator[_AbstractSequentialIterator__T], typing.Generic[_AbstractSequentialIterator__T]):
    """
    Java class 'com.google.common.collect.AbstractSequentialIterator'
    
        Extends:
            com.google.common.collect.UnmodifiableIterator
    
    """
    def hasNext(self) -> bool: ...
    def next(self) -> _AbstractSequentialIterator__T: ...

_ForwardingCollection__E = typing.TypeVar('_ForwardingCollection__E')  # <E>
class ForwardingCollection(ForwardingObject, java.util.Collection[_ForwardingCollection__E], typing.Generic[_ForwardingCollection__E]):
    """
    Java class 'com.google.common.collect.ForwardingCollection'
    
        Extends:
            com.google.common.collect.ForwardingObject
    
        Interfaces:
            java.util.Collection
    
    """
    def add(self, e: _ForwardingCollection__E) -> bool: ...
    def addAll(self, collection: typing.Union[java.util.Collection[_ForwardingCollection__E], typing.Sequence[_ForwardingCollection__E]]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_ForwardingCollection__E]: ...
    def remove(self, object: typing.Any) -> bool: ...
    def removeAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def retainAll(self, collection: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[int], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...

_ForwardingIterator__T = typing.TypeVar('_ForwardingIterator__T')  # <T>
class ForwardingIterator(ForwardingObject, java.util.Iterator[_ForwardingIterator__T], typing.Generic[_ForwardingIterator__T]):
    """
    Java class 'com.google.common.collect.ForwardingIterator'
    
        Extends:
            com.google.common.collect.ForwardingObject
    
        Interfaces:
            java.util.Iterator
    
    """
    def hasNext(self) -> bool: ...
    def next(self) -> _ForwardingIterator__T: ...
    def remove(self) -> None: ...

_ForwardingMap__K = typing.TypeVar('_ForwardingMap__K')  # <K>
_ForwardingMap__V = typing.TypeVar('_ForwardingMap__V')  # <V>
class ForwardingMap(ForwardingObject, java.util.Map[_ForwardingMap__K, _ForwardingMap__V], typing.Generic[_ForwardingMap__K, _ForwardingMap__V]):
    """
    Java class 'com.google.common.collect.ForwardingMap'
    
        Extends:
            com.google.common.collect.ForwardingObject
    
        Interfaces:
            java.util.Map
    
    """
    def clear(self) -> None: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[_ForwardingMap__K, _ForwardingMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, object: typing.Any) -> _ForwardingMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.Set[_ForwardingMap__K]: ...
    def put(self, k: _ForwardingMap__K, v: _ForwardingMap__V) -> _ForwardingMap__V: ...
    def putAll(self, map: typing.Union[java.util.Map[_ForwardingMap__K, _ForwardingMap__V], typing.Mapping[_ForwardingMap__K, _ForwardingMap__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _ForwardingMap__V: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Collection[_ForwardingMap__V]: ...

_ForwardingMapEntry__K = typing.TypeVar('_ForwardingMapEntry__K')  # <K>
_ForwardingMapEntry__V = typing.TypeVar('_ForwardingMapEntry__V')  # <V>
class ForwardingMapEntry(ForwardingObject, java.util.Map.Entry[_ForwardingMapEntry__K, _ForwardingMapEntry__V], typing.Generic[_ForwardingMapEntry__K, _ForwardingMapEntry__V]):
    """
    Java class 'com.google.common.collect.ForwardingMapEntry'
    
        Extends:
            com.google.common.collect.ForwardingObject
    
        Interfaces:
            java.util.Map.Entry
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def getKey(self) -> _ForwardingMapEntry__K: ...
    def getValue(self) -> _ForwardingMapEntry__V: ...
    def hashCode(self) -> int: ...
    def setValue(self, v: _ForwardingMapEntry__V) -> _ForwardingMapEntry__V: ...

_ForwardingMultimap__K = typing.TypeVar('_ForwardingMultimap__K')  # <K>
_ForwardingMultimap__V = typing.TypeVar('_ForwardingMultimap__V')  # <V>
class ForwardingMultimap(ForwardingObject, Multimap[_ForwardingMultimap__K, _ForwardingMultimap__V], typing.Generic[_ForwardingMultimap__K, _ForwardingMultimap__V]):
    """
    Java class 'com.google.common.collect.ForwardingMultimap'
    
        Extends:
            com.google.common.collect.ForwardingObject
    
        Interfaces:
            com.google.common.collect.Multimap
    
    """
    def asMap(self) -> java.util.Map[_ForwardingMultimap__K, java.util.Collection[_ForwardingMultimap__V]]: ...
    def clear(self) -> None: ...
    def containsEntry(self, object: typing.Any, object2: typing.Any) -> bool: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entries(self) -> java.util.Collection[java.util.Map.Entry[_ForwardingMultimap__K, _ForwardingMultimap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, k: _ForwardingMultimap__K) -> java.util.Collection[_ForwardingMultimap__V]: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.Set[_ForwardingMultimap__K]: ...
    def keys(self) -> Multiset[_ForwardingMultimap__K]: ...
    def put(self, k: _ForwardingMultimap__K, v: _ForwardingMultimap__V) -> bool: ...
    @typing.overload
    def putAll(self, multimap: Multimap[_ForwardingMultimap__K, _ForwardingMultimap__V]) -> bool: ...
    @typing.overload
    def putAll(self, k: _ForwardingMultimap__K, iterable: java.lang.Iterable[_ForwardingMultimap__V]) -> bool: ...
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    def removeAll(self, object: typing.Any) -> java.util.Collection[_ForwardingMultimap__V]: ...
    def replaceValues(self, k: _ForwardingMultimap__K, iterable: java.lang.Iterable[_ForwardingMultimap__V]) -> java.util.Collection[_ForwardingMultimap__V]: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Collection[_ForwardingMultimap__V]: ...

_ForwardingTable__R = typing.TypeVar('_ForwardingTable__R')  # <R>
_ForwardingTable__C = typing.TypeVar('_ForwardingTable__C')  # <C>
_ForwardingTable__V = typing.TypeVar('_ForwardingTable__V')  # <V>
class ForwardingTable(ForwardingObject, Table[_ForwardingTable__R, _ForwardingTable__C, _ForwardingTable__V], typing.Generic[_ForwardingTable__R, _ForwardingTable__C, _ForwardingTable__V]):
    """
    Java class 'com.google.common.collect.ForwardingTable'
    
        Extends:
            com.google.common.collect.ForwardingObject
    
        Interfaces:
            com.google.common.collect.Table
    
    """
    def cellSet(self) -> java.util.Set[Table.Cell[_ForwardingTable__R, _ForwardingTable__C, _ForwardingTable__V]]: ...
    def clear(self) -> None: ...
    def column(self, c: _ForwardingTable__C) -> java.util.Map[_ForwardingTable__R, _ForwardingTable__V]: ...
    def columnKeySet(self) -> java.util.Set[_ForwardingTable__C]: ...
    def columnMap(self) -> java.util.Map[_ForwardingTable__C, java.util.Map[_ForwardingTable__R, _ForwardingTable__V]]: ...
    def contains(self, object: typing.Any, object2: typing.Any) -> bool: ...
    def containsColumn(self, object: typing.Any) -> bool: ...
    def containsRow(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, object: typing.Any, object2: typing.Any) -> _ForwardingTable__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def put(self, r: _ForwardingTable__R, c: _ForwardingTable__C, v: _ForwardingTable__V) -> _ForwardingTable__V: ...
    def putAll(self, table: Table[_ForwardingTable__R, _ForwardingTable__C, _ForwardingTable__V]) -> None: ...
    def remove(self, object: typing.Any, object2: typing.Any) -> _ForwardingTable__V: ...
    def row(self, r: _ForwardingTable__R) -> java.util.Map[_ForwardingTable__C, _ForwardingTable__V]: ...
    def rowKeySet(self) -> java.util.Set[_ForwardingTable__R]: ...
    def rowMap(self) -> java.util.Map[_ForwardingTable__R, java.util.Map[_ForwardingTable__C, _ForwardingTable__V]]: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Collection[_ForwardingTable__V]: ...

_ImmutableList__Builder__E = typing.TypeVar('_ImmutableList__Builder__E')  # <E>
_ImmutableList__E = typing.TypeVar('_ImmutableList__E')  # <E>
class ImmutableList(ImmutableCollection[_ImmutableList__E], java.util.List[_ImmutableList__E], java.util.RandomAccess, typing.Generic[_ImmutableList__E]):
    """
    Java class 'com.google.common.collect.ImmutableList'
    
        Extends:
            com.google.common.collect.ImmutableCollection
    
        Interfaces:
            java.util.List, java.util.RandomAccess
    
    """
    @typing.overload
    def add(self, e: _ImmutableList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _ImmutableList__E) -> None: ...
    @typing.overload
    def addAll(self, collection: typing.Union[java.util.Collection[_ImmutableList__E], typing.Sequence[_ImmutableList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[java.util.Collection[_ImmutableList__E], typing.Sequence[_ImmutableList__E]]) -> bool: ...
    def asList(self) -> 'ImmutableList'[_ImmutableList__E]: ...
    _builder__E = typing.TypeVar('_builder__E')  # <E>
    @staticmethod
    def builder() -> 'ImmutableList.Builder'[_builder__E]: ...
    _builderWithExpectedSize__E = typing.TypeVar('_builderWithExpectedSize__E')  # <E>
    @staticmethod
    def builderWithExpectedSize(int: int) -> 'ImmutableList.Builder'[_builderWithExpectedSize__E]: ...
    def contains(self, object: typing.Any) -> bool: ...
    _copyOf_0__E = typing.TypeVar('_copyOf_0__E')  # <E>
    _copyOf_1__E = typing.TypeVar('_copyOf_1__E')  # <E>
    _copyOf_2__E = typing.TypeVar('_copyOf_2__E')  # <E>
    _copyOf_3__E = typing.TypeVar('_copyOf_3__E')  # <E>
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[_copyOf_0__E]) -> 'ImmutableList'[_copyOf_0__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(eArray: typing.List[_copyOf_1__E]) -> 'ImmutableList'[_copyOf_1__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(collection: typing.Union[java.util.Collection[_copyOf_2__E], typing.Sequence[_copyOf_2__E]]) -> 'ImmutableList'[_copyOf_2__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterator: java.util.Iterator[_copyOf_3__E]) -> 'ImmutableList'[_copyOf_3__E]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_ImmutableList__E], typing.Callable[[_ImmutableList__E], None]]) -> None: ...
    def hashCode(self) -> int: ...
    def indexOf(self, object: typing.Any) -> int: ...
    def iterator(self) -> UnmodifiableIterator[_ImmutableList__E]: ...
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def listIterator(self) -> 'UnmodifiableListIterator'[_ImmutableList__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> 'UnmodifiableListIterator'[_ImmutableList__E]: ...
    _of_0__E = typing.TypeVar('_of_0__E')  # <E>
    _of_1__E = typing.TypeVar('_of_1__E')  # <E>
    _of_2__E = typing.TypeVar('_of_2__E')  # <E>
    _of_3__E = typing.TypeVar('_of_3__E')  # <E>
    _of_4__E = typing.TypeVar('_of_4__E')  # <E>
    _of_5__E = typing.TypeVar('_of_5__E')  # <E>
    _of_6__E = typing.TypeVar('_of_6__E')  # <E>
    _of_7__E = typing.TypeVar('_of_7__E')  # <E>
    _of_8__E = typing.TypeVar('_of_8__E')  # <E>
    _of_9__E = typing.TypeVar('_of_9__E')  # <E>
    _of_10__E = typing.TypeVar('_of_10__E')  # <E>
    _of_11__E = typing.TypeVar('_of_11__E')  # <E>
    _of_12__E = typing.TypeVar('_of_12__E')  # <E>
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableList'[_of_0__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_1__E) -> 'ImmutableList'[_of_1__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_2__E, e2: _of_2__E) -> 'ImmutableList'[_of_2__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_3__E, e2: _of_3__E, e3: _of_3__E) -> 'ImmutableList'[_of_3__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_4__E, e2: _of_4__E, e3: _of_4__E, e4: _of_4__E) -> 'ImmutableList'[_of_4__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_5__E, e2: _of_5__E, e3: _of_5__E, e4: _of_5__E, e5: _of_5__E) -> 'ImmutableList'[_of_5__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_6__E, e2: _of_6__E, e3: _of_6__E, e4: _of_6__E, e5: _of_6__E, e6: _of_6__E) -> 'ImmutableList'[_of_6__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_7__E, e2: _of_7__E, e3: _of_7__E, e4: _of_7__E, e5: _of_7__E, e6: _of_7__E, e7: _of_7__E) -> 'ImmutableList'[_of_7__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_8__E, e2: _of_8__E, e3: _of_8__E, e4: _of_8__E, e5: _of_8__E, e6: _of_8__E, e7: _of_8__E, e8: _of_8__E) -> 'ImmutableList'[_of_8__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_9__E, e2: _of_9__E, e3: _of_9__E, e4: _of_9__E, e5: _of_9__E, e6: _of_9__E, e7: _of_9__E, e8: _of_9__E, e9: _of_9__E) -> 'ImmutableList'[_of_9__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_10__E, e2: _of_10__E, e3: _of_10__E, e4: _of_10__E, e5: _of_10__E, e6: _of_10__E, e7: _of_10__E, e8: _of_10__E, e9: _of_10__E, e10: _of_10__E) -> 'ImmutableList'[_of_10__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_11__E, e2: _of_11__E, e3: _of_11__E, e4: _of_11__E, e5: _of_11__E, e6: _of_11__E, e7: _of_11__E, e8: _of_11__E, e9: _of_11__E, e10: _of_11__E, e11: _of_11__E) -> 'ImmutableList'[_of_11__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_12__E, e2: _of_12__E, e3: _of_12__E, e4: _of_12__E, e5: _of_12__E, e6: _of_12__E, e7: _of_12__E, e8: _of_12__E, e9: _of_12__E, e10: _of_12__E, e11: _of_12__E, e12: _of_12__E, eArray: typing.List[_of_12__E]) -> 'ImmutableList'[_of_12__E]: ...
    def replaceAll(self, unaryOperator: typing.Union[java.util.function.UnaryOperator[_ImmutableList__E], typing.Callable]) -> None: ...
    def reverse(self) -> 'ImmutableList'[_ImmutableList__E]: ...
    def set(self, int: int, e: _ImmutableList__E) -> _ImmutableList__E: ...
    def sort(self, comparator: typing.Union[java.util.Comparator[_ImmutableList__E], typing.Callable[[_ImmutableList__E, _ImmutableList__E], int]]) -> None: ...
    _sortedCopyOf_0__E = typing.TypeVar('_sortedCopyOf_0__E', bound=java.lang.Comparable)  # <E>
    _sortedCopyOf_1__E = typing.TypeVar('_sortedCopyOf_1__E')  # <E>
    @typing.overload
    @staticmethod
    def sortedCopyOf(iterable: java.lang.Iterable[_sortedCopyOf_0__E]) -> 'ImmutableList'[_sortedCopyOf_0__E]: ...
    @typing.overload
    @staticmethod
    def sortedCopyOf(comparator: typing.Union[java.util.Comparator[_sortedCopyOf_1__E], typing.Callable[[_sortedCopyOf_1__E, _sortedCopyOf_1__E], int]], iterable: java.lang.Iterable[_sortedCopyOf_1__E]) -> 'ImmutableList'[_sortedCopyOf_1__E]: ...
    def spliterator(self) -> java.util.Spliterator[_ImmutableList__E]: ...
    def subList(self, int: int, int2: int) -> 'ImmutableList'[_ImmutableList__E]: ...
    _toImmutableList__E = typing.TypeVar('_toImmutableList__E')  # <E>
    @staticmethod
    def toImmutableList() -> java.util.stream.Collector[_toImmutableList__E, typing.Any, 'ImmutableList'[_toImmutableList__E]]: ...
    class Builder(ImmutableCollection.Builder[_ImmutableList__Builder__E], typing.Generic[_ImmutableList__Builder__E]):
        """
        Java class 'com.google.common.collect.ImmutableList$Builder'
        
            Extends:
                com.google.common.collect.ImmutableCollection$Builder
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        @typing.overload
        def add(self, e: _ImmutableList__Builder__E) -> 'ImmutableList.Builder'[_ImmutableList__Builder__E]: ...
        @typing.overload
        def add(self, eArray: typing.List[_ImmutableList__Builder__E]) -> 'ImmutableList.Builder'[_ImmutableList__Builder__E]: ...
        @typing.overload
        def addAll(self, iterable: java.lang.Iterable[_ImmutableList__Builder__E]) -> 'ImmutableList.Builder'[_ImmutableList__Builder__E]: ...
        @typing.overload
        def addAll(self, iterator: java.util.Iterator[_ImmutableList__Builder__E]) -> 'ImmutableList.Builder'[_ImmutableList__Builder__E]: ...
        def build(self) -> 'ImmutableList'[_ImmutableList__Builder__E]: ...

_ImmutableRangeMap__Builder__K = typing.TypeVar('_ImmutableRangeMap__Builder__K', bound=java.lang.Comparable)  # <K>
_ImmutableRangeMap__Builder__V = typing.TypeVar('_ImmutableRangeMap__Builder__V')  # <V>
_ImmutableRangeMap__K = typing.TypeVar('_ImmutableRangeMap__K', bound=java.lang.Comparable)  # <K>
_ImmutableRangeMap__V = typing.TypeVar('_ImmutableRangeMap__V')  # <V>
class ImmutableRangeMap(RangeMap[_ImmutableRangeMap__K, _ImmutableRangeMap__V], java.io.Serializable, typing.Generic[_ImmutableRangeMap__K, _ImmutableRangeMap__V]):
    """
    Java class 'com.google.common.collect.ImmutableRangeMap'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            com.google.common.collect.RangeMap, java.io.Serializable
    
    """
    def asDescendingMapOfRanges(self) -> ImmutableMap['Range'[_ImmutableRangeMap__K], _ImmutableRangeMap__V]: ...
    def asMapOfRanges(self) -> ImmutableMap['Range'[_ImmutableRangeMap__K], _ImmutableRangeMap__V]: ...
    _builder__K = typing.TypeVar('_builder__K', bound=java.lang.Comparable)  # <K>
    _builder__V = typing.TypeVar('_builder__V')  # <V>
    @staticmethod
    def builder() -> 'ImmutableRangeMap.Builder'[_builder__K, _builder__V]: ...
    def clear(self) -> None: ...
    _copyOf__K = typing.TypeVar('_copyOf__K', bound=java.lang.Comparable)  # <K>
    _copyOf__V = typing.TypeVar('_copyOf__V')  # <V>
    @staticmethod
    def copyOf(rangeMap: RangeMap[_copyOf__K, _copyOf__V]) -> 'ImmutableRangeMap'[_copyOf__K, _copyOf__V]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, k: _ImmutableRangeMap__K) -> _ImmutableRangeMap__V: ...
    def getEntry(self, k: _ImmutableRangeMap__K) -> java.util.Map.Entry['Range'[_ImmutableRangeMap__K], _ImmutableRangeMap__V]: ...
    def hashCode(self) -> int: ...
    def merge(self, range: 'Range'[_ImmutableRangeMap__K], v: _ImmutableRangeMap__V, biFunction: typing.Union[java.util.function.BiFunction[_ImmutableRangeMap__V, _ImmutableRangeMap__V, _ImmutableRangeMap__V], typing.Callable[[_ImmutableRangeMap__V, _ImmutableRangeMap__V], _ImmutableRangeMap__V]]) -> None: ...
    _of_0__K = typing.TypeVar('_of_0__K', bound=java.lang.Comparable)  # <K>
    _of_0__V = typing.TypeVar('_of_0__V')  # <V>
    _of_1__K = typing.TypeVar('_of_1__K', bound=java.lang.Comparable)  # <K>
    _of_1__V = typing.TypeVar('_of_1__V')  # <V>
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableRangeMap'[_of_0__K, _of_0__V]: ...
    @typing.overload
    @staticmethod
    def of(range: 'Range'[_of_1__K], v: _of_1__V) -> 'ImmutableRangeMap'[_of_1__K, _of_1__V]: ...
    def put(self, range: 'Range'[_ImmutableRangeMap__K], v: _ImmutableRangeMap__V) -> None: ...
    def putAll(self, rangeMap: RangeMap[_ImmutableRangeMap__K, _ImmutableRangeMap__V]) -> None: ...
    def putCoalescing(self, range: 'Range'[_ImmutableRangeMap__K], v: _ImmutableRangeMap__V) -> None: ...
    def remove(self, range: 'Range'[_ImmutableRangeMap__K]) -> None: ...
    def span(self) -> 'Range'[_ImmutableRangeMap__K]: ...
    def subRangeMap(self, range: 'Range'[_ImmutableRangeMap__K]) -> 'ImmutableRangeMap'[_ImmutableRangeMap__K, _ImmutableRangeMap__V]: ...
    _toImmutableRangeMap__T = typing.TypeVar('_toImmutableRangeMap__T')  # <T>
    _toImmutableRangeMap__K = typing.TypeVar('_toImmutableRangeMap__K', bound=java.lang.Comparable)  # <K>
    _toImmutableRangeMap__V = typing.TypeVar('_toImmutableRangeMap__V')  # <V>
    @staticmethod
    def toImmutableRangeMap(function: typing.Union[java.util.function.Function[_toImmutableRangeMap__T, 'Range'[_toImmutableRangeMap__K]], typing.Callable[[_toImmutableRangeMap__T], 'Range'[_toImmutableRangeMap__K]]], function2: typing.Union[java.util.function.Function[_toImmutableRangeMap__T, _toImmutableRangeMap__V], typing.Callable[[_toImmutableRangeMap__T], _toImmutableRangeMap__V]]) -> java.util.stream.Collector[_toImmutableRangeMap__T, typing.Any, 'ImmutableRangeMap'[_toImmutableRangeMap__K, _toImmutableRangeMap__V]]: ...
    def toString(self) -> str: ...
    class Builder(typing.Generic[_ImmutableRangeMap__Builder__K, _ImmutableRangeMap__Builder__V]):
        """
        Java class 'com.google.common.collect.ImmutableRangeMap$Builder'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        def build(self) -> 'ImmutableRangeMap'[_ImmutableRangeMap__Builder__K, _ImmutableRangeMap__Builder__V]: ...
        def put(self, range: 'Range'[_ImmutableRangeMap__Builder__K], v: _ImmutableRangeMap__Builder__V) -> 'ImmutableRangeMap.Builder'[_ImmutableRangeMap__Builder__K, _ImmutableRangeMap__Builder__V]: ...
        def putAll(self, rangeMap: RangeMap[_ImmutableRangeMap__Builder__K, _ImmutableRangeMap__Builder__V]) -> 'ImmutableRangeMap.Builder'[_ImmutableRangeMap__Builder__K, _ImmutableRangeMap__Builder__V]: ...

_ImmutableSet__Builder__E = typing.TypeVar('_ImmutableSet__Builder__E')  # <E>
_ImmutableSet__E = typing.TypeVar('_ImmutableSet__E')  # <E>
class ImmutableSet(ImmutableCollection[_ImmutableSet__E], java.util.Set[_ImmutableSet__E], typing.Generic[_ImmutableSet__E]):
    """
    Java class 'com.google.common.collect.ImmutableSet'
    
        Extends:
            com.google.common.collect.ImmutableCollection
    
        Interfaces:
            java.util.Set
    
    """
    def asList(self) -> ImmutableList[_ImmutableSet__E]: ...
    _builder__E = typing.TypeVar('_builder__E')  # <E>
    @staticmethod
    def builder() -> 'ImmutableSet.Builder'[_builder__E]: ...
    _builderWithExpectedSize__E = typing.TypeVar('_builderWithExpectedSize__E')  # <E>
    @staticmethod
    def builderWithExpectedSize(int: int) -> 'ImmutableSet.Builder'[_builderWithExpectedSize__E]: ...
    _copyOf_0__E = typing.TypeVar('_copyOf_0__E')  # <E>
    _copyOf_1__E = typing.TypeVar('_copyOf_1__E')  # <E>
    _copyOf_2__E = typing.TypeVar('_copyOf_2__E')  # <E>
    _copyOf_3__E = typing.TypeVar('_copyOf_3__E')  # <E>
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[_copyOf_0__E]) -> 'ImmutableSet'[_copyOf_0__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(eArray: typing.List[_copyOf_1__E]) -> 'ImmutableSet'[_copyOf_1__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(collection: typing.Union[java.util.Collection[_copyOf_2__E], typing.Sequence[_copyOf_2__E]]) -> 'ImmutableSet'[_copyOf_2__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterator: java.util.Iterator[_copyOf_3__E]) -> 'ImmutableSet'[_copyOf_3__E]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> UnmodifiableIterator[_ImmutableSet__E]: ...
    _of_0__E = typing.TypeVar('_of_0__E')  # <E>
    _of_1__E = typing.TypeVar('_of_1__E')  # <E>
    _of_2__E = typing.TypeVar('_of_2__E')  # <E>
    _of_3__E = typing.TypeVar('_of_3__E')  # <E>
    _of_4__E = typing.TypeVar('_of_4__E')  # <E>
    _of_5__E = typing.TypeVar('_of_5__E')  # <E>
    _of_6__E = typing.TypeVar('_of_6__E')  # <E>
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableSet'[_of_0__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_1__E) -> 'ImmutableSet'[_of_1__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_2__E, e2: _of_2__E) -> 'ImmutableSet'[_of_2__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_3__E, e2: _of_3__E, e3: _of_3__E) -> 'ImmutableSet'[_of_3__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_4__E, e2: _of_4__E, e3: _of_4__E, e4: _of_4__E) -> 'ImmutableSet'[_of_4__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_5__E, e2: _of_5__E, e3: _of_5__E, e4: _of_5__E, e5: _of_5__E) -> 'ImmutableSet'[_of_5__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_6__E, e2: _of_6__E, e3: _of_6__E, e4: _of_6__E, e5: _of_6__E, e6: _of_6__E, eArray: typing.List[_of_6__E]) -> 'ImmutableSet'[_of_6__E]: ...
    _toImmutableSet__E = typing.TypeVar('_toImmutableSet__E')  # <E>
    @staticmethod
    def toImmutableSet() -> java.util.stream.Collector[_toImmutableSet__E, typing.Any, 'ImmutableSet'[_toImmutableSet__E]]: ...
    class Builder(ImmutableCollection.Builder[_ImmutableSet__Builder__E], typing.Generic[_ImmutableSet__Builder__E]):
        """
        Java class 'com.google.common.collect.ImmutableSet$Builder'
        
            Extends:
                com.google.common.collect.ImmutableCollection$Builder
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        @typing.overload
        def add(self, e: _ImmutableSet__Builder__E) -> 'ImmutableSet.Builder'[_ImmutableSet__Builder__E]: ...
        @typing.overload
        def add(self, eArray: typing.List[_ImmutableSet__Builder__E]) -> 'ImmutableSet.Builder'[_ImmutableSet__Builder__E]: ...
        @typing.overload
        def addAll(self, iterable: java.lang.Iterable[_ImmutableSet__Builder__E]) -> 'ImmutableSet.Builder'[_ImmutableSet__Builder__E]: ...
        @typing.overload
        def addAll(self, iterator: java.util.Iterator[_ImmutableSet__Builder__E]) -> 'ImmutableSet.Builder'[_ImmutableSet__Builder__E]: ...
        def build(self) -> 'ImmutableSet'[_ImmutableSet__Builder__E]: ...

_ListMultimap__K = typing.TypeVar('_ListMultimap__K')  # <K>
_ListMultimap__V = typing.TypeVar('_ListMultimap__V')  # <V>
class ListMultimap(Multimap[_ListMultimap__K, _ListMultimap__V], typing.Generic[_ListMultimap__K, _ListMultimap__V]):
    """
    Java class 'com.google.common.collect.ListMultimap'
    
        Interfaces:
            com.google.common.collect.Multimap
    
    """
    def asMap(self) -> java.util.Map[_ListMultimap__K, java.util.Collection[_ListMultimap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, k: _ListMultimap__K) -> java.util.List[_ListMultimap__V]: ...
    def hashCode(self) -> int: ...
    def removeAll(self, object: typing.Any) -> java.util.List[_ListMultimap__V]: ...
    def replaceValues(self, k: _ListMultimap__K, iterable: java.lang.Iterable[_ListMultimap__V]) -> java.util.List[_ListMultimap__V]: ...

_RowSortedTable__R = typing.TypeVar('_RowSortedTable__R')  # <R>
_RowSortedTable__C = typing.TypeVar('_RowSortedTable__C')  # <C>
_RowSortedTable__V = typing.TypeVar('_RowSortedTable__V')  # <V>
class RowSortedTable(Table[_RowSortedTable__R, _RowSortedTable__C, _RowSortedTable__V], typing.Generic[_RowSortedTable__R, _RowSortedTable__C, _RowSortedTable__V]):
    """
    Java class 'com.google.common.collect.RowSortedTable'
    
        Interfaces:
            com.google.common.collect.Table
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def rowKeySet(self) -> java.util.SortedSet[_RowSortedTable__R]: ...
    def rowMap(self) -> java.util.SortedMap[_RowSortedTable__R, java.util.Map[_RowSortedTable__C, _RowSortedTable__V]]: ...

_SetMultimap__K = typing.TypeVar('_SetMultimap__K')  # <K>
_SetMultimap__V = typing.TypeVar('_SetMultimap__V')  # <V>
class SetMultimap(Multimap[_SetMultimap__K, _SetMultimap__V], typing.Generic[_SetMultimap__K, _SetMultimap__V]):
    """
    Java class 'com.google.common.collect.SetMultimap'
    
        Interfaces:
            com.google.common.collect.Multimap
    
    """
    def asMap(self) -> java.util.Map[_SetMultimap__K, java.util.Collection[_SetMultimap__V]]: ...
    def entries(self) -> java.util.Set[java.util.Map.Entry[_SetMultimap__K, _SetMultimap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, k: _SetMultimap__K) -> java.util.Set[_SetMultimap__V]: ...
    def hashCode(self) -> int: ...
    def removeAll(self, object: typing.Any) -> java.util.Set[_SetMultimap__V]: ...
    def replaceValues(self, k: _SetMultimap__K, iterable: java.lang.Iterable[_SetMultimap__V]) -> java.util.Set[_SetMultimap__V]: ...

_SortedMapDifference__K = typing.TypeVar('_SortedMapDifference__K')  # <K>
_SortedMapDifference__V = typing.TypeVar('_SortedMapDifference__V')  # <V>
class SortedMapDifference(MapDifference[_SortedMapDifference__K, _SortedMapDifference__V], typing.Generic[_SortedMapDifference__K, _SortedMapDifference__V]):
    """
    Java class 'com.google.common.collect.SortedMapDifference'
    
        Interfaces:
            com.google.common.collect.MapDifference
    
    """
    def entriesDiffering(self) -> java.util.SortedMap[_SortedMapDifference__K, MapDifference.ValueDifference[_SortedMapDifference__V]]: ...
    def entriesInCommon(self) -> java.util.SortedMap[_SortedMapDifference__K, _SortedMapDifference__V]: ...
    def entriesOnlyOnLeft(self) -> java.util.SortedMap[_SortedMapDifference__K, _SortedMapDifference__V]: ...
    def entriesOnlyOnRight(self) -> java.util.SortedMap[_SortedMapDifference__K, _SortedMapDifference__V]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...

_TreeRangeMap__K = typing.TypeVar('_TreeRangeMap__K', bound=java.lang.Comparable)  # <K>
_TreeRangeMap__V = typing.TypeVar('_TreeRangeMap__V')  # <V>
class TreeRangeMap(RangeMap[_TreeRangeMap__K, _TreeRangeMap__V], typing.Generic[_TreeRangeMap__K, _TreeRangeMap__V]):
    """
    Java class 'com.google.common.collect.TreeRangeMap'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            com.google.common.collect.RangeMap
    
    """
    def asDescendingMapOfRanges(self) -> java.util.Map['Range'[_TreeRangeMap__K], _TreeRangeMap__V]: ...
    def asMapOfRanges(self) -> java.util.Map['Range'[_TreeRangeMap__K], _TreeRangeMap__V]: ...
    def clear(self) -> None: ...
    _create__K = typing.TypeVar('_create__K', bound=java.lang.Comparable)  # <K>
    _create__V = typing.TypeVar('_create__V')  # <V>
    @staticmethod
    def create() -> 'TreeRangeMap'[_create__K, _create__V]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, k: _TreeRangeMap__K) -> _TreeRangeMap__V: ...
    def getEntry(self, k: _TreeRangeMap__K) -> java.util.Map.Entry['Range'[_TreeRangeMap__K], _TreeRangeMap__V]: ...
    def hashCode(self) -> int: ...
    def merge(self, range: 'Range'[_TreeRangeMap__K], v: _TreeRangeMap__V, biFunction: typing.Union[java.util.function.BiFunction[_TreeRangeMap__V, _TreeRangeMap__V, _TreeRangeMap__V], typing.Callable[[_TreeRangeMap__V, _TreeRangeMap__V], _TreeRangeMap__V]]) -> None: ...
    def put(self, range: 'Range'[_TreeRangeMap__K], v: _TreeRangeMap__V) -> None: ...
    def putAll(self, rangeMap: RangeMap[_TreeRangeMap__K, _TreeRangeMap__V]) -> None: ...
    def putCoalescing(self, range: 'Range'[_TreeRangeMap__K], v: _TreeRangeMap__V) -> None: ...
    def remove(self, range: 'Range'[_TreeRangeMap__K]) -> None: ...
    def span(self) -> 'Range'[_TreeRangeMap__K]: ...
    def subRangeMap(self, range: 'Range'[_TreeRangeMap__K]) -> RangeMap[_TreeRangeMap__K, _TreeRangeMap__V]: ...
    def toString(self) -> str: ...

_UnmodifiableListIterator__E = typing.TypeVar('_UnmodifiableListIterator__E')  # <E>
class UnmodifiableListIterator(UnmodifiableIterator[_UnmodifiableListIterator__E], java.util.ListIterator[_UnmodifiableListIterator__E], typing.Generic[_UnmodifiableListIterator__E]):
    """
    Java class 'com.google.common.collect.UnmodifiableListIterator'
    
        Extends:
            com.google.common.collect.UnmodifiableIterator
    
        Interfaces:
            java.util.ListIterator
    
    """
    def add(self, e: _UnmodifiableListIterator__E) -> None: ...
    def set(self, e: _UnmodifiableListIterator__E) -> None: ...

_ForwardingConcurrentMap__K = typing.TypeVar('_ForwardingConcurrentMap__K')  # <K>
_ForwardingConcurrentMap__V = typing.TypeVar('_ForwardingConcurrentMap__V')  # <V>
class ForwardingConcurrentMap(ForwardingMap[_ForwardingConcurrentMap__K, _ForwardingConcurrentMap__V], java.util.concurrent.ConcurrentMap[_ForwardingConcurrentMap__K, _ForwardingConcurrentMap__V], typing.Generic[_ForwardingConcurrentMap__K, _ForwardingConcurrentMap__V]):
    """
    Java class 'com.google.common.collect.ForwardingConcurrentMap'
    
        Extends:
            com.google.common.collect.ForwardingMap
    
        Interfaces:
            java.util.concurrent.ConcurrentMap
    
    """
    def putIfAbsent(self, k: _ForwardingConcurrentMap__K, v: _ForwardingConcurrentMap__V) -> _ForwardingConcurrentMap__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _ForwardingConcurrentMap__V: ...
    @typing.overload
    def replace(self, k: _ForwardingConcurrentMap__K, v: _ForwardingConcurrentMap__V, v2: _ForwardingConcurrentMap__V) -> bool: ...
    @typing.overload
    def replace(self, k: _ForwardingConcurrentMap__K, v: _ForwardingConcurrentMap__V) -> _ForwardingConcurrentMap__V: ...

_ForwardingList__E = typing.TypeVar('_ForwardingList__E')  # <E>
class ForwardingList(ForwardingCollection[_ForwardingList__E], java.util.List[_ForwardingList__E], typing.Generic[_ForwardingList__E]):
    """
    Java class 'com.google.common.collect.ForwardingList'
    
        Extends:
            com.google.common.collect.ForwardingCollection
    
        Interfaces:
            java.util.List
    
    """
    @typing.overload
    def add(self, e: _ForwardingList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _ForwardingList__E) -> None: ...
    @typing.overload
    def addAll(self, collection: typing.Union[java.util.Collection[_ForwardingList__E], typing.Sequence[_ForwardingList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[java.util.Collection[_ForwardingList__E], typing.Sequence[_ForwardingList__E]]) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, int: int) -> _ForwardingList__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, object: typing.Any) -> int: ...
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def listIterator(self) -> java.util.ListIterator[_ForwardingList__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> java.util.ListIterator[_ForwardingList__E]: ...
    def set(self, int: int, e: _ForwardingList__E) -> _ForwardingList__E: ...
    def subList(self, int: int, int2: int) -> java.util.List[_ForwardingList__E]: ...

_ForwardingListIterator__E = typing.TypeVar('_ForwardingListIterator__E')  # <E>
class ForwardingListIterator(ForwardingIterator[_ForwardingListIterator__E], java.util.ListIterator[_ForwardingListIterator__E], typing.Generic[_ForwardingListIterator__E]):
    """
    Java class 'com.google.common.collect.ForwardingListIterator'
    
        Extends:
            com.google.common.collect.ForwardingIterator
    
        Interfaces:
            java.util.ListIterator
    
    """
    def add(self, e: _ForwardingListIterator__E) -> None: ...
    def hasPrevious(self) -> bool: ...
    def nextIndex(self) -> int: ...
    def previous(self) -> _ForwardingListIterator__E: ...
    def previousIndex(self) -> int: ...
    def set(self, e: _ForwardingListIterator__E) -> None: ...

_ForwardingListMultimap__K = typing.TypeVar('_ForwardingListMultimap__K')  # <K>
_ForwardingListMultimap__V = typing.TypeVar('_ForwardingListMultimap__V')  # <V>
class ForwardingListMultimap(ForwardingMultimap[_ForwardingListMultimap__K, _ForwardingListMultimap__V], ListMultimap[_ForwardingListMultimap__K, _ForwardingListMultimap__V], typing.Generic[_ForwardingListMultimap__K, _ForwardingListMultimap__V]):
    """
    Java class 'com.google.common.collect.ForwardingListMultimap'
    
        Extends:
            com.google.common.collect.ForwardingMultimap
    
        Interfaces:
            com.google.common.collect.ListMultimap
    
    """
    def get(self, k: _ForwardingListMultimap__K) -> java.util.List[_ForwardingListMultimap__V]: ...
    def removeAll(self, object: typing.Any) -> java.util.List[_ForwardingListMultimap__V]: ...
    def replaceValues(self, k: _ForwardingListMultimap__K, iterable: java.lang.Iterable[_ForwardingListMultimap__V]) -> java.util.List[_ForwardingListMultimap__V]: ...

_ForwardingMultiset__E = typing.TypeVar('_ForwardingMultiset__E')  # <E>
class ForwardingMultiset(ForwardingCollection[_ForwardingMultiset__E], Multiset[_ForwardingMultiset__E], typing.Generic[_ForwardingMultiset__E]):
    """
    Java class 'com.google.common.collect.ForwardingMultiset'
    
        Extends:
            com.google.common.collect.ForwardingCollection
    
        Interfaces:
            com.google.common.collect.Multiset
    
    """
    @typing.overload
    def add(self, e: _ForwardingMultiset__E) -> bool: ...
    @typing.overload
    def add(self, e: _ForwardingMultiset__E, int: int) -> int: ...
    def count(self, object: typing.Any) -> int: ...
    def elementSet(self) -> java.util.Set[_ForwardingMultiset__E]: ...
    def entrySet(self) -> java.util.Set[Multiset.Entry[_ForwardingMultiset__E]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any, int: int) -> int: ...
    @typing.overload
    def setCount(self, e: _ForwardingMultiset__E, int: int, int2: int) -> bool: ...
    @typing.overload
    def setCount(self, e: _ForwardingMultiset__E, int: int) -> int: ...

_ForwardingQueue__E = typing.TypeVar('_ForwardingQueue__E')  # <E>
class ForwardingQueue(ForwardingCollection[_ForwardingQueue__E], java.util.Queue[_ForwardingQueue__E], typing.Generic[_ForwardingQueue__E]):
    """
    Java class 'com.google.common.collect.ForwardingQueue'
    
        Extends:
            com.google.common.collect.ForwardingCollection
    
        Interfaces:
            java.util.Queue
    
    """
    def element(self) -> _ForwardingQueue__E: ...
    def offer(self, e: _ForwardingQueue__E) -> bool: ...
    def peek(self) -> _ForwardingQueue__E: ...
    def poll(self) -> _ForwardingQueue__E: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _ForwardingQueue__E: ...

_ForwardingSet__E = typing.TypeVar('_ForwardingSet__E')  # <E>
class ForwardingSet(ForwardingCollection[_ForwardingSet__E], java.util.Set[_ForwardingSet__E], typing.Generic[_ForwardingSet__E]):
    """
    Java class 'com.google.common.collect.ForwardingSet'
    
        Extends:
            com.google.common.collect.ForwardingCollection
    
        Interfaces:
            java.util.Set
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...

_ForwardingSetMultimap__K = typing.TypeVar('_ForwardingSetMultimap__K')  # <K>
_ForwardingSetMultimap__V = typing.TypeVar('_ForwardingSetMultimap__V')  # <V>
class ForwardingSetMultimap(ForwardingMultimap[_ForwardingSetMultimap__K, _ForwardingSetMultimap__V], SetMultimap[_ForwardingSetMultimap__K, _ForwardingSetMultimap__V], typing.Generic[_ForwardingSetMultimap__K, _ForwardingSetMultimap__V]):
    """
    Java class 'com.google.common.collect.ForwardingSetMultimap'
    
        Extends:
            com.google.common.collect.ForwardingMultimap
    
        Interfaces:
            com.google.common.collect.SetMultimap
    
      Constructors:
        * ForwardingSetMultimap()
    
    """
    def __init__(self): ...
    def entries(self) -> java.util.Set[java.util.Map.Entry[_ForwardingSetMultimap__K, _ForwardingSetMultimap__V]]: ...
    def get(self, k: _ForwardingSetMultimap__K) -> java.util.Set[_ForwardingSetMultimap__V]: ...
    def removeAll(self, object: typing.Any) -> java.util.Set[_ForwardingSetMultimap__V]: ...
    def replaceValues(self, k: _ForwardingSetMultimap__K, iterable: java.lang.Iterable[_ForwardingSetMultimap__V]) -> java.util.Set[_ForwardingSetMultimap__V]: ...

_ForwardingSortedMap__K = typing.TypeVar('_ForwardingSortedMap__K')  # <K>
_ForwardingSortedMap__V = typing.TypeVar('_ForwardingSortedMap__V')  # <V>
class ForwardingSortedMap(ForwardingMap[_ForwardingSortedMap__K, _ForwardingSortedMap__V], java.util.SortedMap[_ForwardingSortedMap__K, _ForwardingSortedMap__V], typing.Generic[_ForwardingSortedMap__K, _ForwardingSortedMap__V]):
    """
    Java class 'com.google.common.collect.ForwardingSortedMap'
    
        Extends:
            com.google.common.collect.ForwardingMap
    
        Interfaces:
            java.util.SortedMap
    
    """
    def comparator(self) -> java.util.Comparator[_ForwardingSortedMap__K]: ...
    def firstKey(self) -> _ForwardingSortedMap__K: ...
    def headMap(self, k: _ForwardingSortedMap__K) -> java.util.SortedMap[_ForwardingSortedMap__K, _ForwardingSortedMap__V]: ...
    def lastKey(self) -> _ForwardingSortedMap__K: ...
    def subMap(self, k: _ForwardingSortedMap__K, k2: _ForwardingSortedMap__K) -> java.util.SortedMap[_ForwardingSortedMap__K, _ForwardingSortedMap__V]: ...
    def tailMap(self, k: _ForwardingSortedMap__K) -> java.util.SortedMap[_ForwardingSortedMap__K, _ForwardingSortedMap__V]: ...

_ImmutableClassToInstanceMap__Builder__B = typing.TypeVar('_ImmutableClassToInstanceMap__Builder__B')  # <B>
_ImmutableClassToInstanceMap__B = typing.TypeVar('_ImmutableClassToInstanceMap__B')  # <B>
class ImmutableClassToInstanceMap(ForwardingMap[typing.Type[_ImmutableClassToInstanceMap__B], _ImmutableClassToInstanceMap__B], ClassToInstanceMap[_ImmutableClassToInstanceMap__B], java.io.Serializable, typing.Generic[_ImmutableClassToInstanceMap__B]):
    """
    Java class 'com.google.common.collect.ImmutableClassToInstanceMap'
    
        Extends:
            com.google.common.collect.ForwardingMap
    
        Interfaces:
            com.google.common.collect.ClassToInstanceMap,
            java.io.Serializable
    
    """
    _builder__B = typing.TypeVar('_builder__B')  # <B>
    @staticmethod
    def builder() -> 'ImmutableClassToInstanceMap.Builder'[_builder__B]: ...
    _copyOf__B = typing.TypeVar('_copyOf__B')  # <B>
    _copyOf__S = typing.TypeVar('_copyOf__S')  # <S>
    @staticmethod
    def copyOf(map: typing.Union[java.util.Map[typing.Type[_copyOf__S], _copyOf__S], typing.Mapping[typing.Type[_copyOf__S], _copyOf__S]]) -> 'ImmutableClassToInstanceMap'[_copyOf__B]: ...
    _getInstance__T = typing.TypeVar('_getInstance__T')  # <T>
    def getInstance(self, class_: typing.Type[_getInstance__T]) -> _getInstance__T: ...
    _of_0__B = typing.TypeVar('_of_0__B')  # <B>
    _of_1__B = typing.TypeVar('_of_1__B')  # <B>
    _of_1__T = typing.TypeVar('_of_1__T')  # <T>
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableClassToInstanceMap'[_of_0__B]: ...
    @typing.overload
    @staticmethod
    def of(class_: typing.Type[_of_1__T], t: _of_1__T) -> 'ImmutableClassToInstanceMap'[_of_1__B]: ...
    _putInstance__T = typing.TypeVar('_putInstance__T')  # <T>
    def putInstance(self, class_: typing.Type[_putInstance__T], t: _putInstance__T) -> _putInstance__T: ...
    class Builder(typing.Generic[_ImmutableClassToInstanceMap__Builder__B]):
        """
        Java class 'com.google.common.collect.ImmutableClassToInstanceMap$Builder'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        def build(self) -> 'ImmutableClassToInstanceMap'[_ImmutableClassToInstanceMap__Builder__B]: ...
        _put__T = typing.TypeVar('_put__T')  # <T>
        def put(self, class_: typing.Type[_put__T], t: _put__T) -> 'ImmutableClassToInstanceMap.Builder'[_ImmutableClassToInstanceMap__Builder__B]: ...
        _putAll__T = typing.TypeVar('_putAll__T')  # <T>
        def putAll(self, map: typing.Union[java.util.Map[typing.Type[_putAll__T], _putAll__T], typing.Mapping[typing.Type[_putAll__T], _putAll__T]]) -> 'ImmutableClassToInstanceMap.Builder'[_ImmutableClassToInstanceMap__Builder__B]: ...

_MutableClassToInstanceMap__B = typing.TypeVar('_MutableClassToInstanceMap__B')  # <B>
class MutableClassToInstanceMap(ForwardingMap[typing.Type[_MutableClassToInstanceMap__B], _MutableClassToInstanceMap__B], ClassToInstanceMap[_MutableClassToInstanceMap__B], java.io.Serializable, typing.Generic[_MutableClassToInstanceMap__B]):
    """
    Java class 'com.google.common.collect.MutableClassToInstanceMap'
    
        Extends:
            com.google.common.collect.ForwardingMap
    
        Interfaces:
            com.google.common.collect.ClassToInstanceMap,
            java.io.Serializable
    
    """
    _create_0__B = typing.TypeVar('_create_0__B')  # <B>
    _create_1__B = typing.TypeVar('_create_1__B')  # <B>
    @typing.overload
    @staticmethod
    def create() -> 'MutableClassToInstanceMap'[_create_0__B]: ...
    @typing.overload
    @staticmethod
    def create(map: typing.Union[java.util.Map[typing.Type[_create_1__B], _create_1__B], typing.Mapping[typing.Type[_create_1__B], _create_1__B]]) -> 'MutableClassToInstanceMap'[_create_1__B]: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[typing.Type[_MutableClassToInstanceMap__B], _MutableClassToInstanceMap__B]]: ...
    _getInstance__T = typing.TypeVar('_getInstance__T')  # <T>
    def getInstance(self, class_: typing.Type[_getInstance__T]) -> _getInstance__T: ...
    def put(self, class_: typing.Type[_MutableClassToInstanceMap__B], b: _MutableClassToInstanceMap__B) -> _MutableClassToInstanceMap__B: ...
    def putAll(self, map: typing.Union[java.util.Map[typing.Type[_MutableClassToInstanceMap__B], _MutableClassToInstanceMap__B], typing.Mapping[typing.Type[_MutableClassToInstanceMap__B], _MutableClassToInstanceMap__B]]) -> None: ...
    _putInstance__T = typing.TypeVar('_putInstance__T')  # <T>
    def putInstance(self, class_: typing.Type[_putInstance__T], t: _putInstance__T) -> _putInstance__T: ...

_SortedSetMultimap__K = typing.TypeVar('_SortedSetMultimap__K')  # <K>
_SortedSetMultimap__V = typing.TypeVar('_SortedSetMultimap__V')  # <V>
class SortedSetMultimap(SetMultimap[_SortedSetMultimap__K, _SortedSetMultimap__V], typing.Generic[_SortedSetMultimap__K, _SortedSetMultimap__V]):
    """
    Java class 'com.google.common.collect.SortedSetMultimap'
    
        Interfaces:
            com.google.common.collect.SetMultimap
    
    """
    def asMap(self) -> java.util.Map[_SortedSetMultimap__K, java.util.Collection[_SortedSetMultimap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, k: _SortedSetMultimap__K) -> java.util.SortedSet[_SortedSetMultimap__V]: ...
    def hashCode(self) -> int: ...
    def removeAll(self, object: typing.Any) -> java.util.SortedSet[_SortedSetMultimap__V]: ...
    def replaceValues(self, k: _SortedSetMultimap__K, iterable: java.lang.Iterable[_SortedSetMultimap__V]) -> java.util.SortedSet[_SortedSetMultimap__V]: ...
    def valueComparator(self) -> java.util.Comparator[_SortedSetMultimap__V]: ...

_EvictingQueue__E = typing.TypeVar('_EvictingQueue__E')  # <E>
class EvictingQueue(ForwardingQueue[_EvictingQueue__E], java.io.Serializable, typing.Generic[_EvictingQueue__E]):
    """
    Java class 'com.google.common.collect.EvictingQueue'
    
        Extends:
            com.google.common.collect.ForwardingQueue
    
        Interfaces:
            java.io.Serializable
    
    """
    def add(self, e: _EvictingQueue__E) -> bool: ...
    def addAll(self, collection: typing.Union[java.util.Collection[_EvictingQueue__E], typing.Sequence[_EvictingQueue__E]]) -> bool: ...
    def contains(self, object: typing.Any) -> bool: ...
    _create__E = typing.TypeVar('_create__E')  # <E>
    @staticmethod
    def create(int: int) -> 'EvictingQueue'[_create__E]: ...
    def offer(self, e: _EvictingQueue__E) -> bool: ...
    def remainingCapacity(self) -> int: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _EvictingQueue__E: ...

_ForwardingDeque__E = typing.TypeVar('_ForwardingDeque__E')  # <E>
class ForwardingDeque(ForwardingQueue[_ForwardingDeque__E], java.util.Deque[_ForwardingDeque__E], typing.Generic[_ForwardingDeque__E]):
    """
    Java class 'com.google.common.collect.ForwardingDeque'
    
        Extends:
            com.google.common.collect.ForwardingQueue
    
        Interfaces:
            java.util.Deque
    
    """
    def addFirst(self, e: _ForwardingDeque__E) -> None: ...
    def addLast(self, e: _ForwardingDeque__E) -> None: ...
    def descendingIterator(self) -> java.util.Iterator[_ForwardingDeque__E]: ...
    def getFirst(self) -> _ForwardingDeque__E: ...
    def getLast(self) -> _ForwardingDeque__E: ...
    def offerFirst(self, e: _ForwardingDeque__E) -> bool: ...
    def offerLast(self, e: _ForwardingDeque__E) -> bool: ...
    def peekFirst(self) -> _ForwardingDeque__E: ...
    def peekLast(self) -> _ForwardingDeque__E: ...
    def pollFirst(self) -> _ForwardingDeque__E: ...
    def pollLast(self) -> _ForwardingDeque__E: ...
    def pop(self) -> _ForwardingDeque__E: ...
    def push(self, e: _ForwardingDeque__E) -> None: ...
    def removeFirst(self) -> _ForwardingDeque__E: ...
    def removeFirstOccurrence(self, object: typing.Any) -> bool: ...
    def removeLast(self) -> _ForwardingDeque__E: ...
    def removeLastOccurrence(self, object: typing.Any) -> bool: ...

_ForwardingNavigableMap__K = typing.TypeVar('_ForwardingNavigableMap__K')  # <K>
_ForwardingNavigableMap__V = typing.TypeVar('_ForwardingNavigableMap__V')  # <V>
class ForwardingNavigableMap(ForwardingSortedMap[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V], java.util.NavigableMap[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V], typing.Generic[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]):
    """
    Java class 'com.google.common.collect.ForwardingNavigableMap'
    
        Extends:
            com.google.common.collect.ForwardingSortedMap
    
        Interfaces:
            java.util.NavigableMap
    
    """
    def ceilingEntry(self, k: _ForwardingNavigableMap__K) -> java.util.Map.Entry[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    def ceilingKey(self, k: _ForwardingNavigableMap__K) -> _ForwardingNavigableMap__K: ...
    def descendingKeySet(self) -> java.util.NavigableSet[_ForwardingNavigableMap__K]: ...
    def descendingMap(self) -> java.util.NavigableMap[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    def firstEntry(self) -> java.util.Map.Entry[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    def floorEntry(self, k: _ForwardingNavigableMap__K) -> java.util.Map.Entry[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    def floorKey(self, k: _ForwardingNavigableMap__K) -> _ForwardingNavigableMap__K: ...
    @typing.overload
    def headMap(self, k: _ForwardingNavigableMap__K, boolean: bool) -> java.util.NavigableMap[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    @typing.overload
    def headMap(self, k: _ForwardingNavigableMap__K) -> java.util.SortedMap[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    def higherEntry(self, k: _ForwardingNavigableMap__K) -> java.util.Map.Entry[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    def higherKey(self, k: _ForwardingNavigableMap__K) -> _ForwardingNavigableMap__K: ...
    def lastEntry(self) -> java.util.Map.Entry[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    def lowerEntry(self, k: _ForwardingNavigableMap__K) -> java.util.Map.Entry[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    def lowerKey(self, k: _ForwardingNavigableMap__K) -> _ForwardingNavigableMap__K: ...
    def navigableKeySet(self) -> java.util.NavigableSet[_ForwardingNavigableMap__K]: ...
    def pollFirstEntry(self) -> java.util.Map.Entry[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    def pollLastEntry(self) -> java.util.Map.Entry[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    @typing.overload
    def subMap(self, k: _ForwardingNavigableMap__K, boolean: bool, k2: _ForwardingNavigableMap__K, boolean2: bool) -> java.util.NavigableMap[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    @typing.overload
    def subMap(self, k: _ForwardingNavigableMap__K, k2: _ForwardingNavigableMap__K) -> java.util.SortedMap[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    @typing.overload
    def tailMap(self, k: _ForwardingNavigableMap__K, boolean: bool) -> java.util.NavigableMap[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...
    @typing.overload
    def tailMap(self, k: _ForwardingNavigableMap__K) -> java.util.SortedMap[_ForwardingNavigableMap__K, _ForwardingNavigableMap__V]: ...

_ForwardingSortedSet__E = typing.TypeVar('_ForwardingSortedSet__E')  # <E>
class ForwardingSortedSet(ForwardingSet[_ForwardingSortedSet__E], java.util.SortedSet[_ForwardingSortedSet__E], typing.Generic[_ForwardingSortedSet__E]):
    """
    Java class 'com.google.common.collect.ForwardingSortedSet'
    
        Extends:
            com.google.common.collect.ForwardingSet
    
        Interfaces:
            java.util.SortedSet
    
    """
    def comparator(self) -> java.util.Comparator[_ForwardingSortedSet__E]: ...
    def first(self) -> _ForwardingSortedSet__E: ...
    def headSet(self, e: _ForwardingSortedSet__E) -> java.util.SortedSet[_ForwardingSortedSet__E]: ...
    def last(self) -> _ForwardingSortedSet__E: ...
    def subSet(self, e: _ForwardingSortedSet__E, e2: _ForwardingSortedSet__E) -> java.util.SortedSet[_ForwardingSortedSet__E]: ...
    def tailSet(self, e: _ForwardingSortedSet__E) -> java.util.SortedSet[_ForwardingSortedSet__E]: ...

_ForwardingSortedSetMultimap__K = typing.TypeVar('_ForwardingSortedSetMultimap__K')  # <K>
_ForwardingSortedSetMultimap__V = typing.TypeVar('_ForwardingSortedSetMultimap__V')  # <V>
class ForwardingSortedSetMultimap(ForwardingSetMultimap[_ForwardingSortedSetMultimap__K, _ForwardingSortedSetMultimap__V], SortedSetMultimap[_ForwardingSortedSetMultimap__K, _ForwardingSortedSetMultimap__V], typing.Generic[_ForwardingSortedSetMultimap__K, _ForwardingSortedSetMultimap__V]):
    """
    Java class 'com.google.common.collect.ForwardingSortedSetMultimap'
    
        Extends:
            com.google.common.collect.ForwardingSetMultimap
    
        Interfaces:
            com.google.common.collect.SortedSetMultimap
    
    """
    def get(self, k: _ForwardingSortedSetMultimap__K) -> java.util.SortedSet[_ForwardingSortedSetMultimap__V]: ...
    def removeAll(self, object: typing.Any) -> java.util.SortedSet[_ForwardingSortedSetMultimap__V]: ...
    def replaceValues(self, k: _ForwardingSortedSetMultimap__K, iterable: java.lang.Iterable[_ForwardingSortedSetMultimap__V]) -> java.util.SortedSet[_ForwardingSortedSetMultimap__V]: ...
    def valueComparator(self) -> java.util.Comparator[_ForwardingSortedSetMultimap__V]: ...

_ForwardingBlockingDeque__E = typing.TypeVar('_ForwardingBlockingDeque__E')  # <E>
class ForwardingBlockingDeque(ForwardingDeque[_ForwardingBlockingDeque__E], java.util.concurrent.BlockingDeque[_ForwardingBlockingDeque__E], typing.Generic[_ForwardingBlockingDeque__E]):
    """
    Java class 'com.google.common.collect.ForwardingBlockingDeque'
    
        Extends:
            com.google.common.collect.ForwardingDeque
    
        Interfaces:
            java.util.concurrent.BlockingDeque
    
    """
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_ForwardingBlockingDeque__E], typing.Sequence[_ForwardingBlockingDeque__E]]) -> int: ...
    @typing.overload
    def drainTo(self, collection: typing.Union[java.util.Collection[_ForwardingBlockingDeque__E], typing.Sequence[_ForwardingBlockingDeque__E]], int: int) -> int: ...
    @typing.overload
    def offer(self, e: _ForwardingBlockingDeque__E, long: int, timeUnit: java.util.concurrent.TimeUnit) -> bool: ...
    @typing.overload
    def offer(self, e: _ForwardingBlockingDeque__E) -> bool: ...
    @typing.overload
    def offerFirst(self, e: _ForwardingBlockingDeque__E, long: int, timeUnit: java.util.concurrent.TimeUnit) -> bool: ...
    @typing.overload
    def offerFirst(self, e: _ForwardingBlockingDeque__E) -> bool: ...
    @typing.overload
    def offerLast(self, e: _ForwardingBlockingDeque__E, long: int, timeUnit: java.util.concurrent.TimeUnit) -> bool: ...
    @typing.overload
    def offerLast(self, e: _ForwardingBlockingDeque__E) -> bool: ...
    @typing.overload
    def poll(self, long: int, timeUnit: java.util.concurrent.TimeUnit) -> _ForwardingBlockingDeque__E: ...
    @typing.overload
    def poll(self) -> _ForwardingBlockingDeque__E: ...
    @typing.overload
    def pollFirst(self, long: int, timeUnit: java.util.concurrent.TimeUnit) -> _ForwardingBlockingDeque__E: ...
    @typing.overload
    def pollFirst(self) -> _ForwardingBlockingDeque__E: ...
    @typing.overload
    def pollLast(self, long: int, timeUnit: java.util.concurrent.TimeUnit) -> _ForwardingBlockingDeque__E: ...
    @typing.overload
    def pollLast(self) -> _ForwardingBlockingDeque__E: ...
    def put(self, e: _ForwardingBlockingDeque__E) -> None: ...
    def putFirst(self, e: _ForwardingBlockingDeque__E) -> None: ...
    def putLast(self, e: _ForwardingBlockingDeque__E) -> None: ...
    def remainingCapacity(self) -> int: ...
    def take(self) -> _ForwardingBlockingDeque__E: ...
    def takeFirst(self) -> _ForwardingBlockingDeque__E: ...
    def takeLast(self) -> _ForwardingBlockingDeque__E: ...

_ForwardingNavigableSet__E = typing.TypeVar('_ForwardingNavigableSet__E')  # <E>
class ForwardingNavigableSet(ForwardingSortedSet[_ForwardingNavigableSet__E], java.util.NavigableSet[_ForwardingNavigableSet__E], typing.Generic[_ForwardingNavigableSet__E]):
    """
    Java class 'com.google.common.collect.ForwardingNavigableSet'
    
        Extends:
            com.google.common.collect.ForwardingSortedSet
    
        Interfaces:
            java.util.NavigableSet
    
    """
    def ceiling(self, e: _ForwardingNavigableSet__E) -> _ForwardingNavigableSet__E: ...
    def descendingIterator(self) -> java.util.Iterator[_ForwardingNavigableSet__E]: ...
    def descendingSet(self) -> java.util.NavigableSet[_ForwardingNavigableSet__E]: ...
    def floor(self, e: _ForwardingNavigableSet__E) -> _ForwardingNavigableSet__E: ...
    @typing.overload
    def headSet(self, e: _ForwardingNavigableSet__E, boolean: bool) -> java.util.NavigableSet[_ForwardingNavigableSet__E]: ...
    @typing.overload
    def headSet(self, e: _ForwardingNavigableSet__E) -> java.util.SortedSet[_ForwardingNavigableSet__E]: ...
    def higher(self, e: _ForwardingNavigableSet__E) -> _ForwardingNavigableSet__E: ...
    def lower(self, e: _ForwardingNavigableSet__E) -> _ForwardingNavigableSet__E: ...
    def pollFirst(self) -> _ForwardingNavigableSet__E: ...
    def pollLast(self) -> _ForwardingNavigableSet__E: ...
    @typing.overload
    def subSet(self, e: _ForwardingNavigableSet__E, boolean: bool, e2: _ForwardingNavigableSet__E, boolean2: bool) -> java.util.NavigableSet[_ForwardingNavigableSet__E]: ...
    @typing.overload
    def subSet(self, e: _ForwardingNavigableSet__E, e2: _ForwardingNavigableSet__E) -> java.util.SortedSet[_ForwardingNavigableSet__E]: ...
    @typing.overload
    def tailSet(self, e: _ForwardingNavigableSet__E, boolean: bool) -> java.util.NavigableSet[_ForwardingNavigableSet__E]: ...
    @typing.overload
    def tailSet(self, e: _ForwardingNavigableSet__E) -> java.util.SortedSet[_ForwardingNavigableSet__E]: ...

_ArrayListMultimap__K = typing.TypeVar('_ArrayListMultimap__K')  # <K>
_ArrayListMultimap__V = typing.TypeVar('_ArrayListMultimap__V')  # <V>
class ArrayListMultimap(com.google.common.collect.ArrayListMultimapGwtSerializationDependencies[_ArrayListMultimap__K, _ArrayListMultimap__V], typing.Generic[_ArrayListMultimap__K, _ArrayListMultimap__V]):
    """
    Java class 'com.google.common.collect.ArrayListMultimap'
    
        Extends:
            com.google.common.collect.ArrayListMultimapGwtSerializationDependencies
    
    """
    _create_0__K = typing.TypeVar('_create_0__K')  # <K>
    _create_0__V = typing.TypeVar('_create_0__V')  # <V>
    _create_1__K = typing.TypeVar('_create_1__K')  # <K>
    _create_1__V = typing.TypeVar('_create_1__V')  # <V>
    _create_2__K = typing.TypeVar('_create_2__K')  # <K>
    _create_2__V = typing.TypeVar('_create_2__V')  # <V>
    @typing.overload
    @staticmethod
    def create() -> 'ArrayListMultimap'[_create_0__K, _create_0__V]: ...
    @typing.overload
    @staticmethod
    def create(multimap: Multimap[_create_1__K, _create_1__V]) -> 'ArrayListMultimap'[_create_1__K, _create_1__V]: ...
    @typing.overload
    @staticmethod
    def create(int: int, int2: int) -> 'ArrayListMultimap'[_create_2__K, _create_2__V]: ...
    def trimToSize(self) -> None: ...

_ArrayTable__R = typing.TypeVar('_ArrayTable__R')  # <R>
_ArrayTable__C = typing.TypeVar('_ArrayTable__C')  # <C>
_ArrayTable__V = typing.TypeVar('_ArrayTable__V')  # <V>
class ArrayTable(com.google.common.collect.AbstractTable[_ArrayTable__R, _ArrayTable__C, _ArrayTable__V], java.io.Serializable, typing.Generic[_ArrayTable__R, _ArrayTable__C, _ArrayTable__V]):
    """
    Java class 'com.google.common.collect.ArrayTable'
    
        Extends:
            com.google.common.collect.AbstractTable
    
        Interfaces:
            java.io.Serializable
    
    """
    def at(self, int: int, int2: int) -> _ArrayTable__V: ...
    def cellSet(self) -> java.util.Set[Table.Cell[_ArrayTable__R, _ArrayTable__C, _ArrayTable__V]]: ...
    def clear(self) -> None: ...
    def column(self, c: _ArrayTable__C) -> java.util.Map[_ArrayTable__R, _ArrayTable__V]: ...
    def columnKeyList(self) -> ImmutableList[_ArrayTable__C]: ...
    def columnKeySet(self) -> ImmutableSet[_ArrayTable__C]: ...
    def columnMap(self) -> java.util.Map[_ArrayTable__C, java.util.Map[_ArrayTable__R, _ArrayTable__V]]: ...
    def contains(self, object: typing.Any, object2: typing.Any) -> bool: ...
    def containsColumn(self, object: typing.Any) -> bool: ...
    def containsRow(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    _create_0__R = typing.TypeVar('_create_0__R')  # <R>
    _create_0__C = typing.TypeVar('_create_0__C')  # <C>
    _create_0__V = typing.TypeVar('_create_0__V')  # <V>
    _create_1__R = typing.TypeVar('_create_1__R')  # <R>
    _create_1__C = typing.TypeVar('_create_1__C')  # <C>
    _create_1__V = typing.TypeVar('_create_1__V')  # <V>
    @typing.overload
    @staticmethod
    def create(table: Table[_create_0__R, _create_0__C, _create_0__V]) -> 'ArrayTable'[_create_0__R, _create_0__C, _create_0__V]: ...
    @typing.overload
    @staticmethod
    def create(iterable: java.lang.Iterable[_create_1__R], iterable2: java.lang.Iterable[_create_1__C]) -> 'ArrayTable'[_create_1__R, _create_1__C, _create_1__V]: ...
    def erase(self, object: typing.Any, object2: typing.Any) -> _ArrayTable__V: ...
    def eraseAll(self) -> None: ...
    def get(self, object: typing.Any, object2: typing.Any) -> _ArrayTable__V: ...
    def isEmpty(self) -> bool: ...
    def put(self, r: _ArrayTable__R, c: _ArrayTable__C, v: _ArrayTable__V) -> _ArrayTable__V: ...
    def putAll(self, table: Table[_ArrayTable__R, _ArrayTable__C, _ArrayTable__V]) -> None: ...
    def remove(self, object: typing.Any, object2: typing.Any) -> _ArrayTable__V: ...
    def row(self, r: _ArrayTable__R) -> java.util.Map[_ArrayTable__C, _ArrayTable__V]: ...
    def rowKeyList(self) -> ImmutableList[_ArrayTable__R]: ...
    def rowKeySet(self) -> ImmutableSet[_ArrayTable__R]: ...
    def rowMap(self) -> java.util.Map[_ArrayTable__R, java.util.Map[_ArrayTable__C, _ArrayTable__V]]: ...
    def set(self, int: int, int2: int, v: _ArrayTable__V) -> _ArrayTable__V: ...
    def size(self) -> int: ...
    def toArray(self, class_: typing.Type[_ArrayTable__V]) -> typing.List[typing.List[_ArrayTable__V]]: ...
    def values(self) -> java.util.Collection[_ArrayTable__V]: ...

_ConcurrentHashMultiset__E = typing.TypeVar('_ConcurrentHashMultiset__E')  # <E>
class ConcurrentHashMultiset(com.google.common.collect.AbstractMultiset[_ConcurrentHashMultiset__E], java.io.Serializable, typing.Generic[_ConcurrentHashMultiset__E]):
    """
    Java class 'com.google.common.collect.ConcurrentHashMultiset'
    
        Extends:
            com.google.common.collect.AbstractMultiset
    
        Interfaces:
            java.io.Serializable
    
    """
    @typing.overload
    def add(self, e: _ConcurrentHashMultiset__E) -> bool: ...
    @typing.overload
    def add(self, e: _ConcurrentHashMultiset__E, int: int) -> int: ...
    def clear(self) -> None: ...
    def count(self, object: typing.Any) -> int: ...
    _create_0__E = typing.TypeVar('_create_0__E')  # <E>
    _create_1__E = typing.TypeVar('_create_1__E')  # <E>
    _create_2__E = typing.TypeVar('_create_2__E')  # <E>
    @typing.overload
    @staticmethod
    def create() -> 'ConcurrentHashMultiset'[_create_0__E]: ...
    @typing.overload
    @staticmethod
    def create(iterable: java.lang.Iterable[_create_1__E]) -> 'ConcurrentHashMultiset'[_create_1__E]: ...
    @typing.overload
    @staticmethod
    def create(concurrentMap: java.util.concurrent.ConcurrentMap[_create_2__E, java.util.concurrent.atomic.AtomicInteger]) -> 'ConcurrentHashMultiset'[_create_2__E]: ...
    def createEntrySet(self) -> java.util.Set[Multiset.Entry[_ConcurrentHashMultiset__E]]: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_ConcurrentHashMultiset__E]: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any, int: int) -> int: ...
    def removeExactly(self, object: typing.Any, int: int) -> bool: ...
    @typing.overload
    def setCount(self, e: _ConcurrentHashMultiset__E, int: int, int2: int) -> bool: ...
    @typing.overload
    def setCount(self, e: _ConcurrentHashMultiset__E, int: int) -> int: ...
    def size(self) -> int: ...
    _toArray_0__T = typing.TypeVar('_toArray_0__T')  # <T>
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self, intFunction: typing.Union[java.util.function.IntFunction[typing.List[_toArray_0__T]], typing.Callable[[int], typing.List[_toArray_0__T]]]) -> typing.List[_toArray_0__T]: ...
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_2__T]) -> typing.List[_toArray_2__T]: ...

_ContiguousSet__C = typing.TypeVar('_ContiguousSet__C', bound=java.lang.Comparable)  # <C>
class ContiguousSet(com.google.common.collect.ImmutableSortedSet[_ContiguousSet__C], typing.Generic[_ContiguousSet__C]):
    """
    Java class 'com.google.common.collect.ContiguousSet'
    
        Extends:
            com.google.common.collect.ImmutableSortedSet
    
    """
    _builder_0__E = typing.TypeVar('_builder_0__E')  # <E>
    _builder_1__E = typing.TypeVar('_builder_1__E')  # <E>
    @typing.overload
    @staticmethod
    def builder() -> ImmutableSet.Builder[_builder_0__E]: ...
    @typing.overload
    @staticmethod
    def builder() -> 'ImmutableSortedSet.Builder'[_builder_1__E]: ...
    @typing.overload
    @staticmethod
    def closed(int: int, int2: int) -> 'ContiguousSet'[int]: ...
    @typing.overload
    @staticmethod
    def closed(long: int, long2: int) -> 'ContiguousSet'[int]: ...
    @typing.overload
    @staticmethod
    def closedOpen(int: int, int2: int) -> 'ContiguousSet'[int]: ...
    @typing.overload
    @staticmethod
    def closedOpen(long: int, long2: int) -> 'ContiguousSet'[int]: ...
    _create__C = typing.TypeVar('_create__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def create(range: 'Range'[_create__C], discreteDomain: DiscreteDomain[_create__C]) -> 'ContiguousSet'[_create__C]: ...
    @typing.overload
    def headSet(self, c: _ContiguousSet__C) -> 'ContiguousSet'[_ContiguousSet__C]: ...
    @typing.overload
    def headSet(self, c: _ContiguousSet__C, boolean: bool) -> 'ContiguousSet'[_ContiguousSet__C]: ...
    def intersection(self, contiguousSet: 'ContiguousSet'[_ContiguousSet__C]) -> 'ContiguousSet'[_ContiguousSet__C]: ...
    @typing.overload
    def range(self) -> 'Range'[_ContiguousSet__C]: ...
    @typing.overload
    def range(self, boundType: BoundType, boundType2: BoundType) -> 'Range'[_ContiguousSet__C]: ...
    @typing.overload
    def subSet(self, c: _ContiguousSet__C, boolean: bool, c2: _ContiguousSet__C, boolean2: bool) -> 'ContiguousSet'[_ContiguousSet__C]: ...
    @typing.overload
    def subSet(self, c: _ContiguousSet__C, c2: _ContiguousSet__C) -> 'ContiguousSet'[_ContiguousSet__C]: ...
    @typing.overload
    def tailSet(self, c: _ContiguousSet__C) -> 'ContiguousSet'[_ContiguousSet__C]: ...
    @typing.overload
    def tailSet(self, c: _ContiguousSet__C, boolean: bool) -> 'ContiguousSet'[_ContiguousSet__C]: ...
    def toString(self) -> str: ...

_EnumBiMap__K = typing.TypeVar('_EnumBiMap__K', bound=java.lang.Enum)  # <K>
_EnumBiMap__V = typing.TypeVar('_EnumBiMap__V', bound=java.lang.Enum)  # <V>
class EnumBiMap(com.google.common.collect.AbstractBiMap[_EnumBiMap__K, _EnumBiMap__V], typing.Generic[_EnumBiMap__K, _EnumBiMap__V]):
    """
    Java class 'com.google.common.collect.EnumBiMap'
    
        Extends:
            com.google.common.collect.AbstractBiMap
    
    """
    _create_0__K = typing.TypeVar('_create_0__K', bound=java.lang.Enum)  # <K>
    _create_0__V = typing.TypeVar('_create_0__V', bound=java.lang.Enum)  # <V>
    _create_1__K = typing.TypeVar('_create_1__K', bound=java.lang.Enum)  # <K>
    _create_1__V = typing.TypeVar('_create_1__V', bound=java.lang.Enum)  # <V>
    @typing.overload
    @staticmethod
    def create(class_: typing.Type[_create_0__K], class2: typing.Type[_create_0__V]) -> 'EnumBiMap'[_create_0__K, _create_0__V]: ...
    @typing.overload
    @staticmethod
    def create(map: typing.Union[java.util.Map[_create_1__K, _create_1__V], typing.Mapping[_create_1__K, _create_1__V]]) -> 'EnumBiMap'[_create_1__K, _create_1__V]: ...
    def keyType(self) -> typing.Type[_EnumBiMap__K]: ...
    def valueType(self) -> typing.Type[_EnumBiMap__V]: ...

_EnumHashBiMap__K = typing.TypeVar('_EnumHashBiMap__K', bound=java.lang.Enum)  # <K>
_EnumHashBiMap__V = typing.TypeVar('_EnumHashBiMap__V')  # <V>
class EnumHashBiMap(com.google.common.collect.AbstractBiMap[_EnumHashBiMap__K, _EnumHashBiMap__V], typing.Generic[_EnumHashBiMap__K, _EnumHashBiMap__V]):
    """
    Java class 'com.google.common.collect.EnumHashBiMap'
    
        Extends:
            com.google.common.collect.AbstractBiMap
    
    """
    _create_0__K = typing.TypeVar('_create_0__K', bound=java.lang.Enum)  # <K>
    _create_0__V = typing.TypeVar('_create_0__V')  # <V>
    _create_1__K = typing.TypeVar('_create_1__K', bound=java.lang.Enum)  # <K>
    _create_1__V = typing.TypeVar('_create_1__V')  # <V>
    @typing.overload
    @staticmethod
    def create(class_: typing.Type[_create_0__K]) -> 'EnumHashBiMap'[_create_0__K, _create_0__V]: ...
    @typing.overload
    @staticmethod
    def create(map: typing.Union[java.util.Map[_create_1__K, _create_1__V], typing.Mapping[_create_1__K, _create_1__V]]) -> 'EnumHashBiMap'[_create_1__K, _create_1__V]: ...
    def forcePut(self, k: _EnumHashBiMap__K, v: _EnumHashBiMap__V) -> _EnumHashBiMap__V: ...
    def keyType(self) -> typing.Type[_EnumHashBiMap__K]: ...
    def put(self, k: _EnumHashBiMap__K, v: _EnumHashBiMap__V) -> _EnumHashBiMap__V: ...
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...

_EnumMultiset__E = typing.TypeVar('_EnumMultiset__E', bound=java.lang.Enum)  # <E>
class EnumMultiset(com.google.common.collect.AbstractMultiset[_EnumMultiset__E], java.io.Serializable, typing.Generic[_EnumMultiset__E]):
    """
    Java class 'com.google.common.collect.EnumMultiset'
    
        Extends:
            com.google.common.collect.AbstractMultiset
    
        Interfaces:
            java.io.Serializable
    
    """
    @typing.overload
    def add(self, e: _EnumMultiset__E) -> bool: ...
    @typing.overload
    def add(self, e: _EnumMultiset__E, int: int) -> int: ...
    def clear(self) -> None: ...
    def count(self, object: typing.Any) -> int: ...
    _create_0__E = typing.TypeVar('_create_0__E', bound=java.lang.Enum)  # <E>
    _create_1__E = typing.TypeVar('_create_1__E', bound=java.lang.Enum)  # <E>
    _create_2__E = typing.TypeVar('_create_2__E', bound=java.lang.Enum)  # <E>
    @typing.overload
    @staticmethod
    def create(class_: typing.Type[_create_0__E]) -> 'EnumMultiset'[_create_0__E]: ...
    @typing.overload
    @staticmethod
    def create(iterable: java.lang.Iterable[_create_1__E]) -> 'EnumMultiset'[_create_1__E]: ...
    @typing.overload
    @staticmethod
    def create(iterable: java.lang.Iterable[_create_2__E], class_: typing.Type[_create_2__E]) -> 'EnumMultiset'[_create_2__E]: ...
    def forEachEntry(self, objIntConsumer: typing.Union[java.util.function.ObjIntConsumer[_EnumMultiset__E], typing.Callable[[_EnumMultiset__E, int], None]]) -> None: ...
    def iterator(self) -> java.util.Iterator[_EnumMultiset__E]: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any, int: int) -> int: ...
    @typing.overload
    def setCount(self, e: _EnumMultiset__E, int: int, int2: int) -> bool: ...
    @typing.overload
    def setCount(self, e: _EnumMultiset__E, int: int) -> int: ...
    def size(self) -> int: ...

_ForwardingSortedMultiset__E = typing.TypeVar('_ForwardingSortedMultiset__E')  # <E>
class ForwardingSortedMultiset(ForwardingMultiset[_ForwardingSortedMultiset__E], com.google.common.collect.SortedMultiset[_ForwardingSortedMultiset__E], typing.Generic[_ForwardingSortedMultiset__E]):
    """
    Java class 'com.google.common.collect.ForwardingSortedMultiset'
    
        Extends:
            com.google.common.collect.ForwardingMultiset
    
        Interfaces:
            com.google.common.collect.SortedMultiset
    
    """
    def comparator(self) -> java.util.Comparator[_ForwardingSortedMultiset__E]: ...
    def descendingMultiset(self) -> 'SortedMultiset'[_ForwardingSortedMultiset__E]: ...
    def elementSet(self) -> java.util.NavigableSet[_ForwardingSortedMultiset__E]: ...
    def firstEntry(self) -> Multiset.Entry[_ForwardingSortedMultiset__E]: ...
    def headMultiset(self, e: _ForwardingSortedMultiset__E, boundType: BoundType) -> 'SortedMultiset'[_ForwardingSortedMultiset__E]: ...
    def lastEntry(self) -> Multiset.Entry[_ForwardingSortedMultiset__E]: ...
    def pollFirstEntry(self) -> Multiset.Entry[_ForwardingSortedMultiset__E]: ...
    def pollLastEntry(self) -> Multiset.Entry[_ForwardingSortedMultiset__E]: ...
    def subMultiset(self, e: _ForwardingSortedMultiset__E, boundType: BoundType, e2: _ForwardingSortedMultiset__E, boundType2: BoundType) -> 'SortedMultiset'[_ForwardingSortedMultiset__E]: ...
    def tailMultiset(self, e: _ForwardingSortedMultiset__E, boundType: BoundType) -> 'SortedMultiset'[_ForwardingSortedMultiset__E]: ...

_HashBasedTable__R = typing.TypeVar('_HashBasedTable__R')  # <R>
_HashBasedTable__C = typing.TypeVar('_HashBasedTable__C')  # <C>
_HashBasedTable__V = typing.TypeVar('_HashBasedTable__V')  # <V>
class HashBasedTable(com.google.common.collect.StandardTable[_HashBasedTable__R, _HashBasedTable__C, _HashBasedTable__V], typing.Generic[_HashBasedTable__R, _HashBasedTable__C, _HashBasedTable__V]):
    """
    Java class 'com.google.common.collect.HashBasedTable'
    
        Extends:
            com.google.common.collect.StandardTable
    
    """
    def contains(self, object: typing.Any, object2: typing.Any) -> bool: ...
    def containsColumn(self, object: typing.Any) -> bool: ...
    def containsRow(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    _create_0__R = typing.TypeVar('_create_0__R')  # <R>
    _create_0__C = typing.TypeVar('_create_0__C')  # <C>
    _create_0__V = typing.TypeVar('_create_0__V')  # <V>
    _create_1__R = typing.TypeVar('_create_1__R')  # <R>
    _create_1__C = typing.TypeVar('_create_1__C')  # <C>
    _create_1__V = typing.TypeVar('_create_1__V')  # <V>
    _create_2__R = typing.TypeVar('_create_2__R')  # <R>
    _create_2__C = typing.TypeVar('_create_2__C')  # <C>
    _create_2__V = typing.TypeVar('_create_2__V')  # <V>
    @typing.overload
    @staticmethod
    def create() -> 'HashBasedTable'[_create_0__R, _create_0__C, _create_0__V]: ...
    @typing.overload
    @staticmethod
    def create(table: Table[_create_1__R, _create_1__C, _create_1__V]) -> 'HashBasedTable'[_create_1__R, _create_1__C, _create_1__V]: ...
    @typing.overload
    @staticmethod
    def create(int: int, int2: int) -> 'HashBasedTable'[_create_2__R, _create_2__C, _create_2__V]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, object: typing.Any, object2: typing.Any) -> _HashBasedTable__V: ...
    def remove(self, object: typing.Any, object2: typing.Any) -> _HashBasedTable__V: ...

_HashBiMap__K = typing.TypeVar('_HashBiMap__K')  # <K>
_HashBiMap__V = typing.TypeVar('_HashBiMap__V')  # <V>
class HashBiMap(com.google.common.collect.Maps.IteratorBasedAbstractMap[_HashBiMap__K, _HashBiMap__V], BiMap[_HashBiMap__K, _HashBiMap__V], java.io.Serializable, typing.Generic[_HashBiMap__K, _HashBiMap__V]):
    """
    Java class 'com.google.common.collect.HashBiMap'
    
        Extends:
            com.google.common.collect.Maps$IteratorBasedAbstractMap
    
        Interfaces:
            com.google.common.collect.BiMap, java.io.Serializable
    
    """
    def clear(self) -> None: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    _create_0__K = typing.TypeVar('_create_0__K')  # <K>
    _create_0__V = typing.TypeVar('_create_0__V')  # <V>
    _create_1__K = typing.TypeVar('_create_1__K')  # <K>
    _create_1__V = typing.TypeVar('_create_1__V')  # <V>
    _create_2__K = typing.TypeVar('_create_2__K')  # <K>
    _create_2__V = typing.TypeVar('_create_2__V')  # <V>
    @typing.overload
    @staticmethod
    def create() -> 'HashBiMap'[_create_0__K, _create_0__V]: ...
    @typing.overload
    @staticmethod
    def create(int: int) -> 'HashBiMap'[_create_1__K, _create_1__V]: ...
    @typing.overload
    @staticmethod
    def create(map: typing.Union[java.util.Map[_create_2__K, _create_2__V], typing.Mapping[_create_2__K, _create_2__V]]) -> 'HashBiMap'[_create_2__K, _create_2__V]: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_HashBiMap__K, _HashBiMap__V], typing.Callable[[_HashBiMap__K, _HashBiMap__V], None]]) -> None: ...
    def forcePut(self, k: _HashBiMap__K, v: _HashBiMap__V) -> _HashBiMap__V: ...
    def get(self, object: typing.Any) -> _HashBiMap__V: ...
    def inverse(self) -> BiMap[_HashBiMap__V, _HashBiMap__K]: ...
    def keySet(self) -> java.util.Set[_HashBiMap__K]: ...
    def put(self, k: _HashBiMap__K, v: _HashBiMap__V) -> _HashBiMap__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _HashBiMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_HashBiMap__K, _HashBiMap__V, _HashBiMap__V], typing.Callable[[_HashBiMap__K, _HashBiMap__V], _HashBiMap__V]]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Set[_HashBiMap__V]: ...

_HashMultimap__K = typing.TypeVar('_HashMultimap__K')  # <K>
_HashMultimap__V = typing.TypeVar('_HashMultimap__V')  # <V>
class HashMultimap(com.google.common.collect.HashMultimapGwtSerializationDependencies[_HashMultimap__K, _HashMultimap__V], typing.Generic[_HashMultimap__K, _HashMultimap__V]):
    """
    Java class 'com.google.common.collect.HashMultimap'
    
        Extends:
            com.google.common.collect.HashMultimapGwtSerializationDependencies
    
    """
    _create_0__K = typing.TypeVar('_create_0__K')  # <K>
    _create_0__V = typing.TypeVar('_create_0__V')  # <V>
    _create_1__K = typing.TypeVar('_create_1__K')  # <K>
    _create_1__V = typing.TypeVar('_create_1__V')  # <V>
    _create_2__K = typing.TypeVar('_create_2__K')  # <K>
    _create_2__V = typing.TypeVar('_create_2__V')  # <V>
    @typing.overload
    @staticmethod
    def create() -> 'HashMultimap'[_create_0__K, _create_0__V]: ...
    @typing.overload
    @staticmethod
    def create(multimap: Multimap[_create_1__K, _create_1__V]) -> 'HashMultimap'[_create_1__K, _create_1__V]: ...
    @typing.overload
    @staticmethod
    def create(int: int, int2: int) -> 'HashMultimap'[_create_2__K, _create_2__V]: ...

_HashMultiset__E = typing.TypeVar('_HashMultiset__E')  # <E>
class HashMultiset(com.google.common.collect.AbstractMapBasedMultiset[_HashMultiset__E], typing.Generic[_HashMultiset__E]):
    """
    Java class 'com.google.common.collect.HashMultiset'
    
        Extends:
            com.google.common.collect.AbstractMapBasedMultiset
    
    """
    def add(self, e: _HashMultiset__E) -> bool: ...
    _create_0__E = typing.TypeVar('_create_0__E')  # <E>
    _create_1__E = typing.TypeVar('_create_1__E')  # <E>
    _create_2__E = typing.TypeVar('_create_2__E')  # <E>
    @typing.overload
    @staticmethod
    def create() -> 'HashMultiset'[_create_0__E]: ...
    @typing.overload
    @staticmethod
    def create(int: int) -> 'HashMultiset'[_create_1__E]: ...
    @typing.overload
    @staticmethod
    def create(iterable: java.lang.Iterable[_create_2__E]) -> 'HashMultiset'[_create_2__E]: ...
    def remove(self, object: typing.Any) -> bool: ...

_ImmutableBiMap__Builder__K = typing.TypeVar('_ImmutableBiMap__Builder__K')  # <K>
_ImmutableBiMap__Builder__V = typing.TypeVar('_ImmutableBiMap__Builder__V')  # <V>
_ImmutableBiMap__K = typing.TypeVar('_ImmutableBiMap__K')  # <K>
_ImmutableBiMap__V = typing.TypeVar('_ImmutableBiMap__V')  # <V>
class ImmutableBiMap(com.google.common.collect.ImmutableBiMapFauxverideShim[_ImmutableBiMap__K, _ImmutableBiMap__V], BiMap[_ImmutableBiMap__K, _ImmutableBiMap__V], typing.Generic[_ImmutableBiMap__K, _ImmutableBiMap__V]):
    """
    Java class 'com.google.common.collect.ImmutableBiMap'
    
        Extends:
            com.google.common.collect.ImmutableBiMapFauxverideShim
    
        Interfaces:
            com.google.common.collect.BiMap
    
    """
    _builder_0__K = typing.TypeVar('_builder_0__K')  # <K>
    _builder_0__V = typing.TypeVar('_builder_0__V')  # <V>
    _builder_1__K = typing.TypeVar('_builder_1__K')  # <K>
    _builder_1__V = typing.TypeVar('_builder_1__V')  # <V>
    @typing.overload
    @staticmethod
    def builder() -> 'ImmutableBiMap.Builder'[_builder_0__K, _builder_0__V]: ...
    @typing.overload
    @staticmethod
    def builder() -> ImmutableMap.Builder[_builder_1__K, _builder_1__V]: ...
    _builderWithExpectedSize_0__K = typing.TypeVar('_builderWithExpectedSize_0__K')  # <K>
    _builderWithExpectedSize_0__V = typing.TypeVar('_builderWithExpectedSize_0__V')  # <V>
    _builderWithExpectedSize_1__K = typing.TypeVar('_builderWithExpectedSize_1__K')  # <K>
    _builderWithExpectedSize_1__V = typing.TypeVar('_builderWithExpectedSize_1__V')  # <V>
    @typing.overload
    @staticmethod
    def builderWithExpectedSize(int: int) -> 'ImmutableBiMap.Builder'[_builderWithExpectedSize_0__K, _builderWithExpectedSize_0__V]: ...
    @typing.overload
    @staticmethod
    def builderWithExpectedSize(int: int) -> ImmutableMap.Builder[_builderWithExpectedSize_1__K, _builderWithExpectedSize_1__V]: ...
    _copyOf_0__K = typing.TypeVar('_copyOf_0__K')  # <K>
    _copyOf_0__V = typing.TypeVar('_copyOf_0__V')  # <V>
    _copyOf_1__K = typing.TypeVar('_copyOf_1__K')  # <K>
    _copyOf_1__V = typing.TypeVar('_copyOf_1__V')  # <V>
    _copyOf_2__K = typing.TypeVar('_copyOf_2__K')  # <K>
    _copyOf_2__V = typing.TypeVar('_copyOf_2__V')  # <V>
    _copyOf_3__K = typing.TypeVar('_copyOf_3__K')  # <K>
    _copyOf_3__V = typing.TypeVar('_copyOf_3__V')  # <V>
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[java.util.Map.Entry[_copyOf_0__K, _copyOf_0__V]]) -> 'ImmutableBiMap'[_copyOf_0__K, _copyOf_0__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(map: typing.Union[java.util.Map[_copyOf_1__K, _copyOf_1__V], typing.Mapping[_copyOf_1__K, _copyOf_1__V]]) -> 'ImmutableBiMap'[_copyOf_1__K, _copyOf_1__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[java.util.Map.Entry[_copyOf_2__K, _copyOf_2__V]]) -> ImmutableMap[_copyOf_2__K, _copyOf_2__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(map: typing.Union[java.util.Map[_copyOf_3__K, _copyOf_3__V], typing.Mapping[_copyOf_3__K, _copyOf_3__V]]) -> ImmutableMap[_copyOf_3__K, _copyOf_3__V]: ...
    def forcePut(self, k: _ImmutableBiMap__K, v: _ImmutableBiMap__V) -> _ImmutableBiMap__V: ...
    def inverse(self) -> 'ImmutableBiMap'[_ImmutableBiMap__V, _ImmutableBiMap__K]: ...
    _of_0__K = typing.TypeVar('_of_0__K')  # <K>
    _of_0__V = typing.TypeVar('_of_0__V')  # <V>
    _of_1__K = typing.TypeVar('_of_1__K')  # <K>
    _of_1__V = typing.TypeVar('_of_1__V')  # <V>
    _of_2__K = typing.TypeVar('_of_2__K')  # <K>
    _of_2__V = typing.TypeVar('_of_2__V')  # <V>
    _of_3__K = typing.TypeVar('_of_3__K')  # <K>
    _of_3__V = typing.TypeVar('_of_3__V')  # <V>
    _of_4__K = typing.TypeVar('_of_4__K')  # <K>
    _of_4__V = typing.TypeVar('_of_4__V')  # <V>
    _of_5__K = typing.TypeVar('_of_5__K')  # <K>
    _of_5__V = typing.TypeVar('_of_5__V')  # <V>
    _of_6__K = typing.TypeVar('_of_6__K')  # <K>
    _of_6__V = typing.TypeVar('_of_6__V')  # <V>
    _of_7__K = typing.TypeVar('_of_7__K')  # <K>
    _of_7__V = typing.TypeVar('_of_7__V')  # <V>
    _of_8__K = typing.TypeVar('_of_8__K')  # <K>
    _of_8__V = typing.TypeVar('_of_8__V')  # <V>
    _of_9__K = typing.TypeVar('_of_9__K')  # <K>
    _of_9__V = typing.TypeVar('_of_9__V')  # <V>
    _of_10__K = typing.TypeVar('_of_10__K')  # <K>
    _of_10__V = typing.TypeVar('_of_10__V')  # <V>
    _of_11__K = typing.TypeVar('_of_11__K')  # <K>
    _of_11__V = typing.TypeVar('_of_11__V')  # <V>
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableBiMap'[_of_0__K, _of_0__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_1__K, v: _of_1__V) -> 'ImmutableBiMap'[_of_1__K, _of_1__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_2__K, v: _of_2__V, k2: _of_2__K, v2: _of_2__V) -> 'ImmutableBiMap'[_of_2__K, _of_2__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_3__K, v: _of_3__V, k2: _of_3__K, v2: _of_3__V, k3: _of_3__K, v3: _of_3__V) -> 'ImmutableBiMap'[_of_3__K, _of_3__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_4__K, v: _of_4__V, k2: _of_4__K, v2: _of_4__V, k3: _of_4__K, v3: _of_4__V, k4: _of_4__K, v4: _of_4__V) -> 'ImmutableBiMap'[_of_4__K, _of_4__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_5__K, v: _of_5__V, k2: _of_5__K, v2: _of_5__V, k3: _of_5__K, v3: _of_5__V, k4: _of_5__K, v4: _of_5__V, k5: _of_5__K, v5: _of_5__V) -> 'ImmutableBiMap'[_of_5__K, _of_5__V]: ...
    @typing.overload
    @staticmethod
    def of() -> ImmutableMap[_of_6__K, _of_6__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_7__K, v: _of_7__V) -> ImmutableMap[_of_7__K, _of_7__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_8__K, v: _of_8__V, k2: _of_8__K, v2: _of_8__V) -> ImmutableMap[_of_8__K, _of_8__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_9__K, v: _of_9__V, k2: _of_9__K, v2: _of_9__V, k3: _of_9__K, v3: _of_9__V) -> ImmutableMap[_of_9__K, _of_9__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_10__K, v: _of_10__V, k2: _of_10__K, v2: _of_10__V, k3: _of_10__K, v3: _of_10__V, k4: _of_10__K, v4: _of_10__V) -> ImmutableMap[_of_10__K, _of_10__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_11__K, v: _of_11__V, k2: _of_11__K, v2: _of_11__V, k3: _of_11__K, v3: _of_11__V, k4: _of_11__K, v4: _of_11__V, k5: _of_11__K, v5: _of_11__V) -> ImmutableMap[_of_11__K, _of_11__V]: ...
    _toImmutableBiMap__T = typing.TypeVar('_toImmutableBiMap__T')  # <T>
    _toImmutableBiMap__K = typing.TypeVar('_toImmutableBiMap__K')  # <K>
    _toImmutableBiMap__V = typing.TypeVar('_toImmutableBiMap__V')  # <V>
    @staticmethod
    def toImmutableBiMap(function: typing.Union[java.util.function.Function[_toImmutableBiMap__T, _toImmutableBiMap__K], typing.Callable[[_toImmutableBiMap__T], _toImmutableBiMap__K]], function2: typing.Union[java.util.function.Function[_toImmutableBiMap__T, _toImmutableBiMap__V], typing.Callable[[_toImmutableBiMap__T], _toImmutableBiMap__V]]) -> java.util.stream.Collector[_toImmutableBiMap__T, typing.Any, 'ImmutableBiMap'[_toImmutableBiMap__K, _toImmutableBiMap__V]]: ...
    def values(self) -> ImmutableSet[_ImmutableBiMap__V]: ...
    class Builder(ImmutableMap.Builder[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V], typing.Generic[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V]):
        """
        Java class 'com.google.common.collect.ImmutableBiMap$Builder'
        
            Extends:
                com.google.common.collect.ImmutableMap$Builder
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        def build(self) -> 'ImmutableBiMap'[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V]: ...
        def orderEntriesByValue(self, comparator: typing.Union[java.util.Comparator[_ImmutableBiMap__Builder__V], typing.Callable[[_ImmutableBiMap__Builder__V, _ImmutableBiMap__Builder__V], int]]) -> 'ImmutableBiMap.Builder'[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V]: ...
        @typing.overload
        def put(self, k: _ImmutableBiMap__Builder__K, v: _ImmutableBiMap__Builder__V) -> 'ImmutableBiMap.Builder'[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V]: ...
        @typing.overload
        def put(self, entry: java.util.Map.Entry[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V]) -> 'ImmutableBiMap.Builder'[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V]: ...
        @typing.overload
        def putAll(self, iterable: java.lang.Iterable[java.util.Map.Entry[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V]]) -> 'ImmutableBiMap.Builder'[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V]: ...
        @typing.overload
        def putAll(self, map: typing.Union[java.util.Map[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V], typing.Mapping[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V]]) -> 'ImmutableBiMap.Builder'[_ImmutableBiMap__Builder__K, _ImmutableBiMap__Builder__V]: ...

_ImmutableListMultimap__Builder__K = typing.TypeVar('_ImmutableListMultimap__Builder__K')  # <K>
_ImmutableListMultimap__Builder__V = typing.TypeVar('_ImmutableListMultimap__Builder__V')  # <V>
_ImmutableListMultimap__K = typing.TypeVar('_ImmutableListMultimap__K')  # <K>
_ImmutableListMultimap__V = typing.TypeVar('_ImmutableListMultimap__V')  # <V>
class ImmutableListMultimap(com.google.common.collect.ImmutableMultimap[_ImmutableListMultimap__K, _ImmutableListMultimap__V], ListMultimap[_ImmutableListMultimap__K, _ImmutableListMultimap__V], typing.Generic[_ImmutableListMultimap__K, _ImmutableListMultimap__V]):
    """
    Java class 'com.google.common.collect.ImmutableListMultimap'
    
        Extends:
            com.google.common.collect.ImmutableMultimap
    
        Interfaces:
            com.google.common.collect.ListMultimap
    
    """
    _builder_0__K = typing.TypeVar('_builder_0__K')  # <K>
    _builder_0__V = typing.TypeVar('_builder_0__V')  # <V>
    _builder_1__K = typing.TypeVar('_builder_1__K')  # <K>
    _builder_1__V = typing.TypeVar('_builder_1__V')  # <V>
    @typing.overload
    @staticmethod
    def builder() -> 'ImmutableListMultimap.Builder'[_builder_0__K, _builder_0__V]: ...
    @typing.overload
    @staticmethod
    def builder() -> 'ImmutableMultimap.Builder'[_builder_1__K, _builder_1__V]: ...
    _copyOf_0__K = typing.TypeVar('_copyOf_0__K')  # <K>
    _copyOf_0__V = typing.TypeVar('_copyOf_0__V')  # <V>
    _copyOf_1__K = typing.TypeVar('_copyOf_1__K')  # <K>
    _copyOf_1__V = typing.TypeVar('_copyOf_1__V')  # <V>
    _copyOf_2__K = typing.TypeVar('_copyOf_2__K')  # <K>
    _copyOf_2__V = typing.TypeVar('_copyOf_2__V')  # <V>
    _copyOf_3__K = typing.TypeVar('_copyOf_3__K')  # <K>
    _copyOf_3__V = typing.TypeVar('_copyOf_3__V')  # <V>
    @typing.overload
    @staticmethod
    def copyOf(multimap: Multimap[_copyOf_0__K, _copyOf_0__V]) -> 'ImmutableListMultimap'[_copyOf_0__K, _copyOf_0__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[java.util.Map.Entry[_copyOf_1__K, _copyOf_1__V]]) -> 'ImmutableListMultimap'[_copyOf_1__K, _copyOf_1__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(multimap: Multimap[_copyOf_2__K, _copyOf_2__V]) -> 'ImmutableMultimap'[_copyOf_2__K, _copyOf_2__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[java.util.Map.Entry[_copyOf_3__K, _copyOf_3__V]]) -> 'ImmutableMultimap'[_copyOf_3__K, _copyOf_3__V]: ...
    _flatteningToImmutableListMultimap__T = typing.TypeVar('_flatteningToImmutableListMultimap__T')  # <T>
    _flatteningToImmutableListMultimap__K = typing.TypeVar('_flatteningToImmutableListMultimap__K')  # <K>
    _flatteningToImmutableListMultimap__V = typing.TypeVar('_flatteningToImmutableListMultimap__V')  # <V>
    @staticmethod
    def flatteningToImmutableListMultimap(function: typing.Union[java.util.function.Function[_flatteningToImmutableListMultimap__T, _flatteningToImmutableListMultimap__K], typing.Callable[[_flatteningToImmutableListMultimap__T], _flatteningToImmutableListMultimap__K]], function2: typing.Union[java.util.function.Function[_flatteningToImmutableListMultimap__T, java.util.stream.Stream[_flatteningToImmutableListMultimap__V]], typing.Callable[[_flatteningToImmutableListMultimap__T], java.util.stream.Stream[_flatteningToImmutableListMultimap__V]]]) -> java.util.stream.Collector[_flatteningToImmutableListMultimap__T, typing.Any, 'ImmutableListMultimap'[_flatteningToImmutableListMultimap__K, _flatteningToImmutableListMultimap__V]]: ...
    def get(self, k: _ImmutableListMultimap__K) -> ImmutableList[_ImmutableListMultimap__V]: ...
    def inverse(self) -> 'ImmutableListMultimap'[_ImmutableListMultimap__V, _ImmutableListMultimap__K]: ...
    _of_0__K = typing.TypeVar('_of_0__K')  # <K>
    _of_0__V = typing.TypeVar('_of_0__V')  # <V>
    _of_1__K = typing.TypeVar('_of_1__K')  # <K>
    _of_1__V = typing.TypeVar('_of_1__V')  # <V>
    _of_2__K = typing.TypeVar('_of_2__K')  # <K>
    _of_2__V = typing.TypeVar('_of_2__V')  # <V>
    _of_3__K = typing.TypeVar('_of_3__K')  # <K>
    _of_3__V = typing.TypeVar('_of_3__V')  # <V>
    _of_4__K = typing.TypeVar('_of_4__K')  # <K>
    _of_4__V = typing.TypeVar('_of_4__V')  # <V>
    _of_5__K = typing.TypeVar('_of_5__K')  # <K>
    _of_5__V = typing.TypeVar('_of_5__V')  # <V>
    _of_6__K = typing.TypeVar('_of_6__K')  # <K>
    _of_6__V = typing.TypeVar('_of_6__V')  # <V>
    _of_7__K = typing.TypeVar('_of_7__K')  # <K>
    _of_7__V = typing.TypeVar('_of_7__V')  # <V>
    _of_8__K = typing.TypeVar('_of_8__K')  # <K>
    _of_8__V = typing.TypeVar('_of_8__V')  # <V>
    _of_9__K = typing.TypeVar('_of_9__K')  # <K>
    _of_9__V = typing.TypeVar('_of_9__V')  # <V>
    _of_10__K = typing.TypeVar('_of_10__K')  # <K>
    _of_10__V = typing.TypeVar('_of_10__V')  # <V>
    _of_11__K = typing.TypeVar('_of_11__K')  # <K>
    _of_11__V = typing.TypeVar('_of_11__V')  # <V>
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableListMultimap'[_of_0__K, _of_0__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_1__K, v: _of_1__V) -> 'ImmutableListMultimap'[_of_1__K, _of_1__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_2__K, v: _of_2__V, k2: _of_2__K, v2: _of_2__V) -> 'ImmutableListMultimap'[_of_2__K, _of_2__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_3__K, v: _of_3__V, k2: _of_3__K, v2: _of_3__V, k3: _of_3__K, v3: _of_3__V) -> 'ImmutableListMultimap'[_of_3__K, _of_3__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_4__K, v: _of_4__V, k2: _of_4__K, v2: _of_4__V, k3: _of_4__K, v3: _of_4__V, k4: _of_4__K, v4: _of_4__V) -> 'ImmutableListMultimap'[_of_4__K, _of_4__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_5__K, v: _of_5__V, k2: _of_5__K, v2: _of_5__V, k3: _of_5__K, v3: _of_5__V, k4: _of_5__K, v4: _of_5__V, k5: _of_5__K, v5: _of_5__V) -> 'ImmutableListMultimap'[_of_5__K, _of_5__V]: ...
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableMultimap'[_of_6__K, _of_6__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_7__K, v: _of_7__V) -> 'ImmutableMultimap'[_of_7__K, _of_7__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_8__K, v: _of_8__V, k2: _of_8__K, v2: _of_8__V) -> 'ImmutableMultimap'[_of_8__K, _of_8__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_9__K, v: _of_9__V, k2: _of_9__K, v2: _of_9__V, k3: _of_9__K, v3: _of_9__V) -> 'ImmutableMultimap'[_of_9__K, _of_9__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_10__K, v: _of_10__V, k2: _of_10__K, v2: _of_10__V, k3: _of_10__K, v3: _of_10__V, k4: _of_10__K, v4: _of_10__V) -> 'ImmutableMultimap'[_of_10__K, _of_10__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_11__K, v: _of_11__V, k2: _of_11__K, v2: _of_11__V, k3: _of_11__K, v3: _of_11__V, k4: _of_11__K, v4: _of_11__V, k5: _of_11__K, v5: _of_11__V) -> 'ImmutableMultimap'[_of_11__K, _of_11__V]: ...
    def removeAll(self, object: typing.Any) -> ImmutableList[_ImmutableListMultimap__V]: ...
    def replaceValues(self, k: _ImmutableListMultimap__K, iterable: java.lang.Iterable[_ImmutableListMultimap__V]) -> ImmutableList[_ImmutableListMultimap__V]: ...
    _toImmutableListMultimap__T = typing.TypeVar('_toImmutableListMultimap__T')  # <T>
    _toImmutableListMultimap__K = typing.TypeVar('_toImmutableListMultimap__K')  # <K>
    _toImmutableListMultimap__V = typing.TypeVar('_toImmutableListMultimap__V')  # <V>
    @staticmethod
    def toImmutableListMultimap(function: typing.Union[java.util.function.Function[_toImmutableListMultimap__T, _toImmutableListMultimap__K], typing.Callable[[_toImmutableListMultimap__T], _toImmutableListMultimap__K]], function2: typing.Union[java.util.function.Function[_toImmutableListMultimap__T, _toImmutableListMultimap__V], typing.Callable[[_toImmutableListMultimap__T], _toImmutableListMultimap__V]]) -> java.util.stream.Collector[_toImmutableListMultimap__T, typing.Any, 'ImmutableListMultimap'[_toImmutableListMultimap__K, _toImmutableListMultimap__V]]: ...
    class Builder(com.google.common.collect.ImmutableMultimap.Builder[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V], typing.Generic[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]):
        """
        Java class 'com.google.common.collect.ImmutableListMultimap$Builder'
        
            Extends:
                com.google.common.collect.ImmutableMultimap$Builder
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        def build(self) -> 'ImmutableListMultimap'[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]: ...
        def orderKeysBy(self, comparator: typing.Union[java.util.Comparator[_ImmutableListMultimap__Builder__K], typing.Callable[[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__K], int]]) -> 'ImmutableListMultimap.Builder'[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]: ...
        def orderValuesBy(self, comparator: typing.Union[java.util.Comparator[_ImmutableListMultimap__Builder__V], typing.Callable[[_ImmutableListMultimap__Builder__V, _ImmutableListMultimap__Builder__V], int]]) -> 'ImmutableListMultimap.Builder'[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]: ...
        @typing.overload
        def put(self, k: _ImmutableListMultimap__Builder__K, v: _ImmutableListMultimap__Builder__V) -> 'ImmutableListMultimap.Builder'[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]: ...
        @typing.overload
        def put(self, entry: java.util.Map.Entry[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]) -> 'ImmutableListMultimap.Builder'[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, multimap: Multimap[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]) -> 'ImmutableListMultimap.Builder'[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, iterable: java.lang.Iterable[java.util.Map.Entry[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]]) -> 'ImmutableListMultimap.Builder'[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, k: _ImmutableListMultimap__Builder__K, iterable: java.lang.Iterable[_ImmutableListMultimap__Builder__V]) -> 'ImmutableListMultimap.Builder'[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, k: _ImmutableListMultimap__Builder__K, vArray: typing.List[_ImmutableListMultimap__Builder__V]) -> 'ImmutableListMultimap.Builder'[_ImmutableListMultimap__Builder__K, _ImmutableListMultimap__Builder__V]: ...

_ImmutableMultimap__Builder__K = typing.TypeVar('_ImmutableMultimap__Builder__K')  # <K>
_ImmutableMultimap__Builder__V = typing.TypeVar('_ImmutableMultimap__Builder__V')  # <V>
_ImmutableMultimap__K = typing.TypeVar('_ImmutableMultimap__K')  # <K>
_ImmutableMultimap__V = typing.TypeVar('_ImmutableMultimap__V')  # <V>
class ImmutableMultimap(com.google.common.collect.BaseImmutableMultimap[_ImmutableMultimap__K, _ImmutableMultimap__V], java.io.Serializable, typing.Generic[_ImmutableMultimap__K, _ImmutableMultimap__V]):
    """
    Java class 'com.google.common.collect.ImmutableMultimap'
    
        Extends:
            com.google.common.collect.BaseImmutableMultimap
    
        Interfaces:
            java.io.Serializable
    
    """
    def asMap(self) -> ImmutableMap[_ImmutableMultimap__K, java.util.Collection[_ImmutableMultimap__V]]: ...
    _builder__K = typing.TypeVar('_builder__K')  # <K>
    _builder__V = typing.TypeVar('_builder__V')  # <V>
    @staticmethod
    def builder() -> 'ImmutableMultimap.Builder'[_builder__K, _builder__V]: ...
    def clear(self) -> None: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    _copyOf_0__K = typing.TypeVar('_copyOf_0__K')  # <K>
    _copyOf_0__V = typing.TypeVar('_copyOf_0__V')  # <V>
    _copyOf_1__K = typing.TypeVar('_copyOf_1__K')  # <K>
    _copyOf_1__V = typing.TypeVar('_copyOf_1__V')  # <V>
    @typing.overload
    @staticmethod
    def copyOf(multimap: Multimap[_copyOf_0__K, _copyOf_0__V]) -> 'ImmutableMultimap'[_copyOf_0__K, _copyOf_0__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[java.util.Map.Entry[_copyOf_1__K, _copyOf_1__V]]) -> 'ImmutableMultimap'[_copyOf_1__K, _copyOf_1__V]: ...
    def entries(self) -> ImmutableCollection[java.util.Map.Entry[_ImmutableMultimap__K, _ImmutableMultimap__V]]: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_ImmutableMultimap__K, _ImmutableMultimap__V], typing.Callable[[_ImmutableMultimap__K, _ImmutableMultimap__V], None]]) -> None: ...
    def get(self, k: _ImmutableMultimap__K) -> ImmutableCollection[_ImmutableMultimap__V]: ...
    def inverse(self) -> 'ImmutableMultimap'[_ImmutableMultimap__V, _ImmutableMultimap__K]: ...
    def keySet(self) -> ImmutableSet[_ImmutableMultimap__K]: ...
    def keys(self) -> 'ImmutableMultiset'[_ImmutableMultimap__K]: ...
    _of_0__K = typing.TypeVar('_of_0__K')  # <K>
    _of_0__V = typing.TypeVar('_of_0__V')  # <V>
    _of_1__K = typing.TypeVar('_of_1__K')  # <K>
    _of_1__V = typing.TypeVar('_of_1__V')  # <V>
    _of_2__K = typing.TypeVar('_of_2__K')  # <K>
    _of_2__V = typing.TypeVar('_of_2__V')  # <V>
    _of_3__K = typing.TypeVar('_of_3__K')  # <K>
    _of_3__V = typing.TypeVar('_of_3__V')  # <V>
    _of_4__K = typing.TypeVar('_of_4__K')  # <K>
    _of_4__V = typing.TypeVar('_of_4__V')  # <V>
    _of_5__K = typing.TypeVar('_of_5__K')  # <K>
    _of_5__V = typing.TypeVar('_of_5__V')  # <V>
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableMultimap'[_of_0__K, _of_0__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_1__K, v: _of_1__V) -> 'ImmutableMultimap'[_of_1__K, _of_1__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_2__K, v: _of_2__V, k2: _of_2__K, v2: _of_2__V) -> 'ImmutableMultimap'[_of_2__K, _of_2__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_3__K, v: _of_3__V, k2: _of_3__K, v2: _of_3__V, k3: _of_3__K, v3: _of_3__V) -> 'ImmutableMultimap'[_of_3__K, _of_3__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_4__K, v: _of_4__V, k2: _of_4__K, v2: _of_4__V, k3: _of_4__K, v3: _of_4__V, k4: _of_4__K, v4: _of_4__V) -> 'ImmutableMultimap'[_of_4__K, _of_4__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_5__K, v: _of_5__V, k2: _of_5__K, v2: _of_5__V, k3: _of_5__K, v3: _of_5__V, k4: _of_5__K, v4: _of_5__V, k5: _of_5__K, v5: _of_5__V) -> 'ImmutableMultimap'[_of_5__K, _of_5__V]: ...
    def put(self, k: _ImmutableMultimap__K, v: _ImmutableMultimap__V) -> bool: ...
    @typing.overload
    def putAll(self, multimap: Multimap[_ImmutableMultimap__K, _ImmutableMultimap__V]) -> bool: ...
    @typing.overload
    def putAll(self, k: _ImmutableMultimap__K, iterable: java.lang.Iterable[_ImmutableMultimap__V]) -> bool: ...
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    def removeAll(self, object: typing.Any) -> ImmutableCollection[_ImmutableMultimap__V]: ...
    def replaceValues(self, k: _ImmutableMultimap__K, iterable: java.lang.Iterable[_ImmutableMultimap__V]) -> ImmutableCollection[_ImmutableMultimap__V]: ...
    def size(self) -> int: ...
    def values(self) -> ImmutableCollection[_ImmutableMultimap__V]: ...
    class Builder(typing.Generic[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]):
        """
        Java class 'com.google.common.collect.ImmutableMultimap$Builder'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        def build(self) -> 'ImmutableMultimap'[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]: ...
        def orderKeysBy(self, comparator: typing.Union[java.util.Comparator[_ImmutableMultimap__Builder__K], typing.Callable[[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__K], int]]) -> 'ImmutableMultimap.Builder'[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]: ...
        def orderValuesBy(self, comparator: typing.Union[java.util.Comparator[_ImmutableMultimap__Builder__V], typing.Callable[[_ImmutableMultimap__Builder__V, _ImmutableMultimap__Builder__V], int]]) -> 'ImmutableMultimap.Builder'[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]: ...
        @typing.overload
        def put(self, k: _ImmutableMultimap__Builder__K, v: _ImmutableMultimap__Builder__V) -> 'ImmutableMultimap.Builder'[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]: ...
        @typing.overload
        def put(self, entry: java.util.Map.Entry[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]) -> 'ImmutableMultimap.Builder'[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, multimap: Multimap[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]) -> 'ImmutableMultimap.Builder'[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, iterable: java.lang.Iterable[java.util.Map.Entry[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]]) -> 'ImmutableMultimap.Builder'[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, k: _ImmutableMultimap__Builder__K, iterable: java.lang.Iterable[_ImmutableMultimap__Builder__V]) -> 'ImmutableMultimap.Builder'[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, k: _ImmutableMultimap__Builder__K, vArray: typing.List[_ImmutableMultimap__Builder__V]) -> 'ImmutableMultimap.Builder'[_ImmutableMultimap__Builder__K, _ImmutableMultimap__Builder__V]: ...

_ImmutableMultiset__Builder__E = typing.TypeVar('_ImmutableMultiset__Builder__E')  # <E>
_ImmutableMultiset__E = typing.TypeVar('_ImmutableMultiset__E')  # <E>
class ImmutableMultiset(com.google.common.collect.ImmutableMultisetGwtSerializationDependencies[_ImmutableMultiset__E], Multiset[_ImmutableMultiset__E], typing.Generic[_ImmutableMultiset__E]):
    """
    Java class 'com.google.common.collect.ImmutableMultiset'
    
        Extends:
            com.google.common.collect.ImmutableMultisetGwtSerializationDependencies
    
        Interfaces:
            com.google.common.collect.Multiset
    
    """
    @typing.overload
    def add(self, e: _ImmutableMultiset__E) -> bool: ...
    @typing.overload
    def add(self, e: _ImmutableMultiset__E, int: int) -> int: ...
    def asList(self) -> ImmutableList[_ImmutableMultiset__E]: ...
    _builder__E = typing.TypeVar('_builder__E')  # <E>
    @staticmethod
    def builder() -> 'ImmutableMultiset.Builder'[_builder__E]: ...
    def contains(self, object: typing.Any) -> bool: ...
    _copyOf_0__E = typing.TypeVar('_copyOf_0__E')  # <E>
    _copyOf_1__E = typing.TypeVar('_copyOf_1__E')  # <E>
    _copyOf_2__E = typing.TypeVar('_copyOf_2__E')  # <E>
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[_copyOf_0__E]) -> 'ImmutableMultiset'[_copyOf_0__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(eArray: typing.List[_copyOf_1__E]) -> 'ImmutableMultiset'[_copyOf_1__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterator: java.util.Iterator[_copyOf_2__E]) -> 'ImmutableMultiset'[_copyOf_2__E]: ...
    def elementSet(self) -> ImmutableSet[_ImmutableMultiset__E]: ...
    def entrySet(self) -> ImmutableSet[Multiset.Entry[_ImmutableMultiset__E]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> UnmodifiableIterator[_ImmutableMultiset__E]: ...
    _of_0__E = typing.TypeVar('_of_0__E')  # <E>
    _of_1__E = typing.TypeVar('_of_1__E')  # <E>
    _of_2__E = typing.TypeVar('_of_2__E')  # <E>
    _of_3__E = typing.TypeVar('_of_3__E')  # <E>
    _of_4__E = typing.TypeVar('_of_4__E')  # <E>
    _of_5__E = typing.TypeVar('_of_5__E')  # <E>
    _of_6__E = typing.TypeVar('_of_6__E')  # <E>
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableMultiset'[_of_0__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_1__E) -> 'ImmutableMultiset'[_of_1__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_2__E, e2: _of_2__E) -> 'ImmutableMultiset'[_of_2__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_3__E, e2: _of_3__E, e3: _of_3__E) -> 'ImmutableMultiset'[_of_3__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_4__E, e2: _of_4__E, e3: _of_4__E, e4: _of_4__E) -> 'ImmutableMultiset'[_of_4__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_5__E, e2: _of_5__E, e3: _of_5__E, e4: _of_5__E, e5: _of_5__E) -> 'ImmutableMultiset'[_of_5__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_6__E, e2: _of_6__E, e3: _of_6__E, e4: _of_6__E, e5: _of_6__E, e6: _of_6__E, eArray: typing.List[_of_6__E]) -> 'ImmutableMultiset'[_of_6__E]: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any, int: int) -> int: ...
    @typing.overload
    def setCount(self, e: _ImmutableMultiset__E, int: int, int2: int) -> bool: ...
    @typing.overload
    def setCount(self, e: _ImmutableMultiset__E, int: int) -> int: ...
    _toImmutableMultiset_0__E = typing.TypeVar('_toImmutableMultiset_0__E')  # <E>
    _toImmutableMultiset_1__T = typing.TypeVar('_toImmutableMultiset_1__T')  # <T>
    _toImmutableMultiset_1__E = typing.TypeVar('_toImmutableMultiset_1__E')  # <E>
    @typing.overload
    @staticmethod
    def toImmutableMultiset() -> java.util.stream.Collector[_toImmutableMultiset_0__E, typing.Any, 'ImmutableMultiset'[_toImmutableMultiset_0__E]]: ...
    @typing.overload
    @staticmethod
    def toImmutableMultiset(function: typing.Union[java.util.function.Function[_toImmutableMultiset_1__T, _toImmutableMultiset_1__E], typing.Callable[[_toImmutableMultiset_1__T], _toImmutableMultiset_1__E]], toIntFunction: typing.Union[java.util.function.ToIntFunction[_toImmutableMultiset_1__T], typing.Callable[[_toImmutableMultiset_1__T], int]]) -> java.util.stream.Collector[_toImmutableMultiset_1__T, typing.Any, 'ImmutableMultiset'[_toImmutableMultiset_1__E]]: ...
    def toString(self) -> str: ...
    class Builder(ImmutableCollection.Builder[_ImmutableMultiset__Builder__E], typing.Generic[_ImmutableMultiset__Builder__E]):
        """
        Java class 'com.google.common.collect.ImmutableMultiset$Builder'
        
            Extends:
                com.google.common.collect.ImmutableCollection$Builder
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        @typing.overload
        def add(self, e: _ImmutableMultiset__Builder__E) -> 'ImmutableMultiset.Builder'[_ImmutableMultiset__Builder__E]: ...
        @typing.overload
        def add(self, eArray: typing.List[_ImmutableMultiset__Builder__E]) -> 'ImmutableMultiset.Builder'[_ImmutableMultiset__Builder__E]: ...
        @typing.overload
        def addAll(self, iterable: java.lang.Iterable[_ImmutableMultiset__Builder__E]) -> 'ImmutableMultiset.Builder'[_ImmutableMultiset__Builder__E]: ...
        @typing.overload
        def addAll(self, iterator: java.util.Iterator[_ImmutableMultiset__Builder__E]) -> 'ImmutableMultiset.Builder'[_ImmutableMultiset__Builder__E]: ...
        def addCopies(self, e: _ImmutableMultiset__Builder__E, int: int) -> 'ImmutableMultiset.Builder'[_ImmutableMultiset__Builder__E]: ...
        def build(self) -> 'ImmutableMultiset'[_ImmutableMultiset__Builder__E]: ...
        def setCount(self, e: _ImmutableMultiset__Builder__E, int: int) -> 'ImmutableMultiset.Builder'[_ImmutableMultiset__Builder__E]: ...

_ImmutableRangeSet__Builder__C = typing.TypeVar('_ImmutableRangeSet__Builder__C', bound=java.lang.Comparable)  # <C>
_ImmutableRangeSet__C = typing.TypeVar('_ImmutableRangeSet__C', bound=java.lang.Comparable)  # <C>
class ImmutableRangeSet(com.google.common.collect.AbstractRangeSet[_ImmutableRangeSet__C], java.io.Serializable, typing.Generic[_ImmutableRangeSet__C]):
    """
    Java class 'com.google.common.collect.ImmutableRangeSet'
    
        Extends:
            com.google.common.collect.AbstractRangeSet
    
        Interfaces:
            java.io.Serializable
    
    """
    def add(self, range: 'Range'[_ImmutableRangeSet__C]) -> None: ...
    @typing.overload
    def addAll(self, rangeSet: RangeSet[_ImmutableRangeSet__C]) -> None: ...
    @typing.overload
    def addAll(self, iterable: java.lang.Iterable['Range'[_ImmutableRangeSet__C]]) -> None: ...
    def asDescendingSetOfRanges(self) -> ImmutableSet['Range'[_ImmutableRangeSet__C]]: ...
    def asRanges(self) -> ImmutableSet['Range'[_ImmutableRangeSet__C]]: ...
    def asSet(self, discreteDomain: DiscreteDomain[_ImmutableRangeSet__C]) -> 'ImmutableSortedSet'[_ImmutableRangeSet__C]: ...
    _builder__C = typing.TypeVar('_builder__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def builder() -> 'ImmutableRangeSet.Builder'[_builder__C]: ...
    def complement(self) -> 'ImmutableRangeSet'[_ImmutableRangeSet__C]: ...
    _copyOf_0__C = typing.TypeVar('_copyOf_0__C', bound=java.lang.Comparable)  # <C>
    _copyOf_1__C = typing.TypeVar('_copyOf_1__C', bound=java.lang.Comparable)  # <C>
    @typing.overload
    @staticmethod
    def copyOf(rangeSet: RangeSet[_copyOf_0__C]) -> 'ImmutableRangeSet'[_copyOf_0__C]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable['Range'[_copyOf_1__C]]) -> 'ImmutableRangeSet'[_copyOf_1__C]: ...
    def difference(self, rangeSet: RangeSet[_ImmutableRangeSet__C]) -> 'ImmutableRangeSet'[_ImmutableRangeSet__C]: ...
    def encloses(self, range: 'Range'[_ImmutableRangeSet__C]) -> bool: ...
    def enclosesAll(self, iterable: java.lang.Iterable['Range'[_ImmutableRangeSet__C]]) -> bool: ...
    def intersection(self, rangeSet: RangeSet[_ImmutableRangeSet__C]) -> 'ImmutableRangeSet'[_ImmutableRangeSet__C]: ...
    def intersects(self, range: 'Range'[_ImmutableRangeSet__C]) -> bool: ...
    def isEmpty(self) -> bool: ...
    _of_0__C = typing.TypeVar('_of_0__C', bound=java.lang.Comparable)  # <C>
    _of_1__C = typing.TypeVar('_of_1__C', bound=java.lang.Comparable)  # <C>
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableRangeSet'[_of_0__C]: ...
    @typing.overload
    @staticmethod
    def of(range: 'Range'[_of_1__C]) -> 'ImmutableRangeSet'[_of_1__C]: ...
    def rangeContaining(self, c: _ImmutableRangeSet__C) -> 'Range'[_ImmutableRangeSet__C]: ...
    def remove(self, range: 'Range'[_ImmutableRangeSet__C]) -> None: ...
    @typing.overload
    def removeAll(self, rangeSet: RangeSet[_ImmutableRangeSet__C]) -> None: ...
    @typing.overload
    def removeAll(self, iterable: java.lang.Iterable['Range'[_ImmutableRangeSet__C]]) -> None: ...
    def span(self) -> 'Range'[_ImmutableRangeSet__C]: ...
    def subRangeSet(self, range: 'Range'[_ImmutableRangeSet__C]) -> 'ImmutableRangeSet'[_ImmutableRangeSet__C]: ...
    _toImmutableRangeSet__E = typing.TypeVar('_toImmutableRangeSet__E', bound=java.lang.Comparable)  # <E>
    @staticmethod
    def toImmutableRangeSet() -> java.util.stream.Collector['Range'[_toImmutableRangeSet__E], typing.Any, 'ImmutableRangeSet'[_toImmutableRangeSet__E]]: ...
    def union(self, rangeSet: RangeSet[_ImmutableRangeSet__C]) -> 'ImmutableRangeSet'[_ImmutableRangeSet__C]: ...
    _unionOf__C = typing.TypeVar('_unionOf__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def unionOf(iterable: java.lang.Iterable['Range'[_unionOf__C]]) -> 'ImmutableRangeSet'[_unionOf__C]: ...
    class Builder(typing.Generic[_ImmutableRangeSet__Builder__C]):
        """
        Java class 'com.google.common.collect.ImmutableRangeSet$Builder'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        def add(self, range: 'Range'[_ImmutableRangeSet__Builder__C]) -> 'ImmutableRangeSet.Builder'[_ImmutableRangeSet__Builder__C]: ...
        @typing.overload
        def addAll(self, rangeSet: RangeSet[_ImmutableRangeSet__Builder__C]) -> 'ImmutableRangeSet.Builder'[_ImmutableRangeSet__Builder__C]: ...
        @typing.overload
        def addAll(self, iterable: java.lang.Iterable['Range'[_ImmutableRangeSet__Builder__C]]) -> 'ImmutableRangeSet.Builder'[_ImmutableRangeSet__Builder__C]: ...
        def build(self) -> 'ImmutableRangeSet'[_ImmutableRangeSet__Builder__C]: ...

_ImmutableSetMultimap__Builder__K = typing.TypeVar('_ImmutableSetMultimap__Builder__K')  # <K>
_ImmutableSetMultimap__Builder__V = typing.TypeVar('_ImmutableSetMultimap__Builder__V')  # <V>
_ImmutableSetMultimap__K = typing.TypeVar('_ImmutableSetMultimap__K')  # <K>
_ImmutableSetMultimap__V = typing.TypeVar('_ImmutableSetMultimap__V')  # <V>
class ImmutableSetMultimap(ImmutableMultimap[_ImmutableSetMultimap__K, _ImmutableSetMultimap__V], SetMultimap[_ImmutableSetMultimap__K, _ImmutableSetMultimap__V], typing.Generic[_ImmutableSetMultimap__K, _ImmutableSetMultimap__V]):
    """
    Java class 'com.google.common.collect.ImmutableSetMultimap'
    
        Extends:
            com.google.common.collect.ImmutableMultimap
    
        Interfaces:
            com.google.common.collect.SetMultimap
    
    """
    _builder_0__K = typing.TypeVar('_builder_0__K')  # <K>
    _builder_0__V = typing.TypeVar('_builder_0__V')  # <V>
    _builder_1__K = typing.TypeVar('_builder_1__K')  # <K>
    _builder_1__V = typing.TypeVar('_builder_1__V')  # <V>
    @typing.overload
    @staticmethod
    def builder() -> ImmutableMultimap.Builder[_builder_0__K, _builder_0__V]: ...
    @typing.overload
    @staticmethod
    def builder() -> 'ImmutableSetMultimap.Builder'[_builder_1__K, _builder_1__V]: ...
    _copyOf_0__K = typing.TypeVar('_copyOf_0__K')  # <K>
    _copyOf_0__V = typing.TypeVar('_copyOf_0__V')  # <V>
    _copyOf_1__K = typing.TypeVar('_copyOf_1__K')  # <K>
    _copyOf_1__V = typing.TypeVar('_copyOf_1__V')  # <V>
    _copyOf_2__K = typing.TypeVar('_copyOf_2__K')  # <K>
    _copyOf_2__V = typing.TypeVar('_copyOf_2__V')  # <V>
    _copyOf_3__K = typing.TypeVar('_copyOf_3__K')  # <K>
    _copyOf_3__V = typing.TypeVar('_copyOf_3__V')  # <V>
    @typing.overload
    @staticmethod
    def copyOf(multimap: Multimap[_copyOf_0__K, _copyOf_0__V]) -> ImmutableMultimap[_copyOf_0__K, _copyOf_0__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[java.util.Map.Entry[_copyOf_1__K, _copyOf_1__V]]) -> ImmutableMultimap[_copyOf_1__K, _copyOf_1__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(multimap: Multimap[_copyOf_2__K, _copyOf_2__V]) -> 'ImmutableSetMultimap'[_copyOf_2__K, _copyOf_2__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[java.util.Map.Entry[_copyOf_3__K, _copyOf_3__V]]) -> 'ImmutableSetMultimap'[_copyOf_3__K, _copyOf_3__V]: ...
    def entries(self) -> ImmutableSet[java.util.Map.Entry[_ImmutableSetMultimap__K, _ImmutableSetMultimap__V]]: ...
    _flatteningToImmutableSetMultimap__T = typing.TypeVar('_flatteningToImmutableSetMultimap__T')  # <T>
    _flatteningToImmutableSetMultimap__K = typing.TypeVar('_flatteningToImmutableSetMultimap__K')  # <K>
    _flatteningToImmutableSetMultimap__V = typing.TypeVar('_flatteningToImmutableSetMultimap__V')  # <V>
    @staticmethod
    def flatteningToImmutableSetMultimap(function: typing.Union[java.util.function.Function[_flatteningToImmutableSetMultimap__T, _flatteningToImmutableSetMultimap__K], typing.Callable[[_flatteningToImmutableSetMultimap__T], _flatteningToImmutableSetMultimap__K]], function2: typing.Union[java.util.function.Function[_flatteningToImmutableSetMultimap__T, java.util.stream.Stream[_flatteningToImmutableSetMultimap__V]], typing.Callable[[_flatteningToImmutableSetMultimap__T], java.util.stream.Stream[_flatteningToImmutableSetMultimap__V]]]) -> java.util.stream.Collector[_flatteningToImmutableSetMultimap__T, typing.Any, 'ImmutableSetMultimap'[_flatteningToImmutableSetMultimap__K, _flatteningToImmutableSetMultimap__V]]: ...
    def get(self, k: _ImmutableSetMultimap__K) -> ImmutableSet[_ImmutableSetMultimap__V]: ...
    def inverse(self) -> 'ImmutableSetMultimap'[_ImmutableSetMultimap__V, _ImmutableSetMultimap__K]: ...
    _of_0__K = typing.TypeVar('_of_0__K')  # <K>
    _of_0__V = typing.TypeVar('_of_0__V')  # <V>
    _of_1__K = typing.TypeVar('_of_1__K')  # <K>
    _of_1__V = typing.TypeVar('_of_1__V')  # <V>
    _of_2__K = typing.TypeVar('_of_2__K')  # <K>
    _of_2__V = typing.TypeVar('_of_2__V')  # <V>
    _of_3__K = typing.TypeVar('_of_3__K')  # <K>
    _of_3__V = typing.TypeVar('_of_3__V')  # <V>
    _of_4__K = typing.TypeVar('_of_4__K')  # <K>
    _of_4__V = typing.TypeVar('_of_4__V')  # <V>
    _of_5__K = typing.TypeVar('_of_5__K')  # <K>
    _of_5__V = typing.TypeVar('_of_5__V')  # <V>
    _of_6__K = typing.TypeVar('_of_6__K')  # <K>
    _of_6__V = typing.TypeVar('_of_6__V')  # <V>
    _of_7__K = typing.TypeVar('_of_7__K')  # <K>
    _of_7__V = typing.TypeVar('_of_7__V')  # <V>
    _of_8__K = typing.TypeVar('_of_8__K')  # <K>
    _of_8__V = typing.TypeVar('_of_8__V')  # <V>
    _of_9__K = typing.TypeVar('_of_9__K')  # <K>
    _of_9__V = typing.TypeVar('_of_9__V')  # <V>
    _of_10__K = typing.TypeVar('_of_10__K')  # <K>
    _of_10__V = typing.TypeVar('_of_10__V')  # <V>
    _of_11__K = typing.TypeVar('_of_11__K')  # <K>
    _of_11__V = typing.TypeVar('_of_11__V')  # <V>
    @typing.overload
    @staticmethod
    def of() -> ImmutableMultimap[_of_0__K, _of_0__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_1__K, v: _of_1__V) -> ImmutableMultimap[_of_1__K, _of_1__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_2__K, v: _of_2__V, k2: _of_2__K, v2: _of_2__V) -> ImmutableMultimap[_of_2__K, _of_2__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_3__K, v: _of_3__V, k2: _of_3__K, v2: _of_3__V, k3: _of_3__K, v3: _of_3__V) -> ImmutableMultimap[_of_3__K, _of_3__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_4__K, v: _of_4__V, k2: _of_4__K, v2: _of_4__V, k3: _of_4__K, v3: _of_4__V, k4: _of_4__K, v4: _of_4__V) -> ImmutableMultimap[_of_4__K, _of_4__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_5__K, v: _of_5__V, k2: _of_5__K, v2: _of_5__V, k3: _of_5__K, v3: _of_5__V, k4: _of_5__K, v4: _of_5__V, k5: _of_5__K, v5: _of_5__V) -> ImmutableMultimap[_of_5__K, _of_5__V]: ...
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableSetMultimap'[_of_6__K, _of_6__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_7__K, v: _of_7__V) -> 'ImmutableSetMultimap'[_of_7__K, _of_7__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_8__K, v: _of_8__V, k2: _of_8__K, v2: _of_8__V) -> 'ImmutableSetMultimap'[_of_8__K, _of_8__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_9__K, v: _of_9__V, k2: _of_9__K, v2: _of_9__V, k3: _of_9__K, v3: _of_9__V) -> 'ImmutableSetMultimap'[_of_9__K, _of_9__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_10__K, v: _of_10__V, k2: _of_10__K, v2: _of_10__V, k3: _of_10__K, v3: _of_10__V, k4: _of_10__K, v4: _of_10__V) -> 'ImmutableSetMultimap'[_of_10__K, _of_10__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_11__K, v: _of_11__V, k2: _of_11__K, v2: _of_11__V, k3: _of_11__K, v3: _of_11__V, k4: _of_11__K, v4: _of_11__V, k5: _of_11__K, v5: _of_11__V) -> 'ImmutableSetMultimap'[_of_11__K, _of_11__V]: ...
    def removeAll(self, object: typing.Any) -> ImmutableSet[_ImmutableSetMultimap__V]: ...
    def replaceValues(self, k: _ImmutableSetMultimap__K, iterable: java.lang.Iterable[_ImmutableSetMultimap__V]) -> ImmutableSet[_ImmutableSetMultimap__V]: ...
    _toImmutableSetMultimap__T = typing.TypeVar('_toImmutableSetMultimap__T')  # <T>
    _toImmutableSetMultimap__K = typing.TypeVar('_toImmutableSetMultimap__K')  # <K>
    _toImmutableSetMultimap__V = typing.TypeVar('_toImmutableSetMultimap__V')  # <V>
    @staticmethod
    def toImmutableSetMultimap(function: typing.Union[java.util.function.Function[_toImmutableSetMultimap__T, _toImmutableSetMultimap__K], typing.Callable[[_toImmutableSetMultimap__T], _toImmutableSetMultimap__K]], function2: typing.Union[java.util.function.Function[_toImmutableSetMultimap__T, _toImmutableSetMultimap__V], typing.Callable[[_toImmutableSetMultimap__T], _toImmutableSetMultimap__V]]) -> java.util.stream.Collector[_toImmutableSetMultimap__T, typing.Any, 'ImmutableSetMultimap'[_toImmutableSetMultimap__K, _toImmutableSetMultimap__V]]: ...
    class Builder(ImmutableMultimap.Builder[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V], typing.Generic[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]):
        """
        Java class 'com.google.common.collect.ImmutableSetMultimap$Builder'
        
            Extends:
                com.google.common.collect.ImmutableMultimap$Builder
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        def build(self) -> 'ImmutableSetMultimap'[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]: ...
        def orderKeysBy(self, comparator: typing.Union[java.util.Comparator[_ImmutableSetMultimap__Builder__K], typing.Callable[[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__K], int]]) -> 'ImmutableSetMultimap.Builder'[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]: ...
        def orderValuesBy(self, comparator: typing.Union[java.util.Comparator[_ImmutableSetMultimap__Builder__V], typing.Callable[[_ImmutableSetMultimap__Builder__V, _ImmutableSetMultimap__Builder__V], int]]) -> 'ImmutableSetMultimap.Builder'[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]: ...
        @typing.overload
        def put(self, k: _ImmutableSetMultimap__Builder__K, v: _ImmutableSetMultimap__Builder__V) -> 'ImmutableSetMultimap.Builder'[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]: ...
        @typing.overload
        def put(self, entry: java.util.Map.Entry[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]) -> 'ImmutableSetMultimap.Builder'[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, multimap: Multimap[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]) -> 'ImmutableSetMultimap.Builder'[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, iterable: java.lang.Iterable[java.util.Map.Entry[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]]) -> 'ImmutableSetMultimap.Builder'[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, k: _ImmutableSetMultimap__Builder__K, iterable: java.lang.Iterable[_ImmutableSetMultimap__Builder__V]) -> 'ImmutableSetMultimap.Builder'[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]: ...
        @typing.overload
        def putAll(self, k: _ImmutableSetMultimap__Builder__K, vArray: typing.List[_ImmutableSetMultimap__Builder__V]) -> 'ImmutableSetMultimap.Builder'[_ImmutableSetMultimap__Builder__K, _ImmutableSetMultimap__Builder__V]: ...

_ImmutableSortedMap__Builder__K = typing.TypeVar('_ImmutableSortedMap__Builder__K')  # <K>
_ImmutableSortedMap__Builder__V = typing.TypeVar('_ImmutableSortedMap__Builder__V')  # <V>
_ImmutableSortedMap__K = typing.TypeVar('_ImmutableSortedMap__K')  # <K>
_ImmutableSortedMap__V = typing.TypeVar('_ImmutableSortedMap__V')  # <V>
class ImmutableSortedMap(com.google.common.collect.ImmutableSortedMapFauxverideShim[_ImmutableSortedMap__K, _ImmutableSortedMap__V], java.util.NavigableMap[_ImmutableSortedMap__K, _ImmutableSortedMap__V], typing.Generic[_ImmutableSortedMap__K, _ImmutableSortedMap__V]):
    """
    Java class 'com.google.common.collect.ImmutableSortedMap'
    
        Extends:
            com.google.common.collect.ImmutableSortedMapFauxverideShim
    
        Interfaces:
            java.util.NavigableMap
    
    """
    def ceilingEntry(self, k: _ImmutableSortedMap__K) -> java.util.Map.Entry[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    def ceilingKey(self, k: _ImmutableSortedMap__K) -> _ImmutableSortedMap__K: ...
    def comparator(self) -> java.util.Comparator[_ImmutableSortedMap__K]: ...
    _copyOf_0__K = typing.TypeVar('_copyOf_0__K')  # <K>
    _copyOf_0__V = typing.TypeVar('_copyOf_0__V')  # <V>
    _copyOf_1__K = typing.TypeVar('_copyOf_1__K')  # <K>
    _copyOf_1__V = typing.TypeVar('_copyOf_1__V')  # <V>
    _copyOf_2__K = typing.TypeVar('_copyOf_2__K')  # <K>
    _copyOf_2__V = typing.TypeVar('_copyOf_2__V')  # <V>
    _copyOf_3__K = typing.TypeVar('_copyOf_3__K')  # <K>
    _copyOf_3__V = typing.TypeVar('_copyOf_3__V')  # <V>
    _copyOf_4__K = typing.TypeVar('_copyOf_4__K')  # <K>
    _copyOf_4__V = typing.TypeVar('_copyOf_4__V')  # <V>
    _copyOf_5__K = typing.TypeVar('_copyOf_5__K')  # <K>
    _copyOf_5__V = typing.TypeVar('_copyOf_5__V')  # <V>
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[java.util.Map.Entry[_copyOf_0__K, _copyOf_0__V]]) -> ImmutableMap[_copyOf_0__K, _copyOf_0__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(map: typing.Union[java.util.Map[_copyOf_1__K, _copyOf_1__V], typing.Mapping[_copyOf_1__K, _copyOf_1__V]]) -> ImmutableMap[_copyOf_1__K, _copyOf_1__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[java.util.Map.Entry[_copyOf_2__K, _copyOf_2__V]]) -> 'ImmutableSortedMap'[_copyOf_2__K, _copyOf_2__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[java.util.Map.Entry[_copyOf_3__K, _copyOf_3__V]], comparator: typing.Union[java.util.Comparator[_copyOf_3__K], typing.Callable[[_copyOf_3__K, _copyOf_3__K], int]]) -> 'ImmutableSortedMap'[_copyOf_3__K, _copyOf_3__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(map: typing.Union[java.util.Map[_copyOf_4__K, _copyOf_4__V], typing.Mapping[_copyOf_4__K, _copyOf_4__V]]) -> 'ImmutableSortedMap'[_copyOf_4__K, _copyOf_4__V]: ...
    @typing.overload
    @staticmethod
    def copyOf(map: typing.Union[java.util.Map[_copyOf_5__K, _copyOf_5__V], typing.Mapping[_copyOf_5__K, _copyOf_5__V]], comparator: typing.Union[java.util.Comparator[_copyOf_5__K], typing.Callable[[_copyOf_5__K, _copyOf_5__K], int]]) -> 'ImmutableSortedMap'[_copyOf_5__K, _copyOf_5__V]: ...
    _copyOfSorted__K = typing.TypeVar('_copyOfSorted__K')  # <K>
    _copyOfSorted__V = typing.TypeVar('_copyOfSorted__V')  # <V>
    @staticmethod
    def copyOfSorted(sortedMap: java.util.SortedMap[_copyOfSorted__K, _copyOfSorted__V]) -> 'ImmutableSortedMap'[_copyOfSorted__K, _copyOfSorted__V]: ...
    def descendingKeySet(self) -> 'ImmutableSortedSet'[_ImmutableSortedMap__K]: ...
    def descendingMap(self) -> 'ImmutableSortedMap'[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    def entrySet(self) -> ImmutableSet[java.util.Map.Entry[_ImmutableSortedMap__K, _ImmutableSortedMap__V]]: ...
    def firstEntry(self) -> java.util.Map.Entry[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    def firstKey(self) -> _ImmutableSortedMap__K: ...
    def floorEntry(self, k: _ImmutableSortedMap__K) -> java.util.Map.Entry[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    def floorKey(self, k: _ImmutableSortedMap__K) -> _ImmutableSortedMap__K: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_ImmutableSortedMap__K, _ImmutableSortedMap__V], typing.Callable[[_ImmutableSortedMap__K, _ImmutableSortedMap__V], None]]) -> None: ...
    def get(self, object: typing.Any) -> _ImmutableSortedMap__V: ...
    @typing.overload
    def headMap(self, k: _ImmutableSortedMap__K) -> 'ImmutableSortedMap'[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    @typing.overload
    def headMap(self, k: _ImmutableSortedMap__K, boolean: bool) -> 'ImmutableSortedMap'[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    def higherEntry(self, k: _ImmutableSortedMap__K) -> java.util.Map.Entry[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    def higherKey(self, k: _ImmutableSortedMap__K) -> _ImmutableSortedMap__K: ...
    def keySet(self) -> 'ImmutableSortedSet'[_ImmutableSortedMap__K]: ...
    def lastEntry(self) -> java.util.Map.Entry[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    def lastKey(self) -> _ImmutableSortedMap__K: ...
    def lowerEntry(self, k: _ImmutableSortedMap__K) -> java.util.Map.Entry[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    def lowerKey(self, k: _ImmutableSortedMap__K) -> _ImmutableSortedMap__K: ...
    _naturalOrder__K = typing.TypeVar('_naturalOrder__K', bound=java.lang.Comparable)  # <K>
    _naturalOrder__V = typing.TypeVar('_naturalOrder__V')  # <V>
    @staticmethod
    def naturalOrder() -> 'ImmutableSortedMap.Builder'[_naturalOrder__K, _naturalOrder__V]: ...
    def navigableKeySet(self) -> 'ImmutableSortedSet'[_ImmutableSortedMap__K]: ...
    _of_0__K = typing.TypeVar('_of_0__K')  # <K>
    _of_0__V = typing.TypeVar('_of_0__V')  # <V>
    _of_1__K = typing.TypeVar('_of_1__K')  # <K>
    _of_1__V = typing.TypeVar('_of_1__V')  # <V>
    _of_2__K = typing.TypeVar('_of_2__K')  # <K>
    _of_2__V = typing.TypeVar('_of_2__V')  # <V>
    _of_3__K = typing.TypeVar('_of_3__K')  # <K>
    _of_3__V = typing.TypeVar('_of_3__V')  # <V>
    _of_4__K = typing.TypeVar('_of_4__K')  # <K>
    _of_4__V = typing.TypeVar('_of_4__V')  # <V>
    _of_5__K = typing.TypeVar('_of_5__K')  # <K>
    _of_5__V = typing.TypeVar('_of_5__V')  # <V>
    _of_6__K = typing.TypeVar('_of_6__K')  # <K>
    _of_6__V = typing.TypeVar('_of_6__V')  # <V>
    _of_7__K = typing.TypeVar('_of_7__K', bound=java.lang.Comparable)  # <K>
    _of_7__V = typing.TypeVar('_of_7__V')  # <V>
    _of_8__K = typing.TypeVar('_of_8__K', bound=java.lang.Comparable)  # <K>
    _of_8__V = typing.TypeVar('_of_8__V')  # <V>
    _of_9__K = typing.TypeVar('_of_9__K', bound=java.lang.Comparable)  # <K>
    _of_9__V = typing.TypeVar('_of_9__V')  # <V>
    _of_10__K = typing.TypeVar('_of_10__K', bound=java.lang.Comparable)  # <K>
    _of_10__V = typing.TypeVar('_of_10__V')  # <V>
    _of_11__K = typing.TypeVar('_of_11__K', bound=java.lang.Comparable)  # <K>
    _of_11__V = typing.TypeVar('_of_11__V')  # <V>
    _of_12__K = typing.TypeVar('_of_12__K')  # <K>
    _of_12__V = typing.TypeVar('_of_12__V')  # <V>
    _of_13__K = typing.TypeVar('_of_13__K')  # <K>
    _of_13__V = typing.TypeVar('_of_13__V')  # <V>
    _of_14__K = typing.TypeVar('_of_14__K')  # <K>
    _of_14__V = typing.TypeVar('_of_14__V')  # <V>
    _of_15__K = typing.TypeVar('_of_15__K')  # <K>
    _of_15__V = typing.TypeVar('_of_15__V')  # <V>
    _of_16__K = typing.TypeVar('_of_16__K')  # <K>
    _of_16__V = typing.TypeVar('_of_16__V')  # <V>
    @typing.overload
    @staticmethod
    def of() -> ImmutableMap[_of_0__K, _of_0__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_1__K, v: _of_1__V) -> ImmutableMap[_of_1__K, _of_1__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_2__K, v: _of_2__V, k2: _of_2__K, v2: _of_2__V) -> ImmutableMap[_of_2__K, _of_2__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_3__K, v: _of_3__V, k2: _of_3__K, v2: _of_3__V, k3: _of_3__K, v3: _of_3__V) -> ImmutableMap[_of_3__K, _of_3__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_4__K, v: _of_4__V, k2: _of_4__K, v2: _of_4__V, k3: _of_4__K, v3: _of_4__V, k4: _of_4__K, v4: _of_4__V) -> ImmutableMap[_of_4__K, _of_4__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_5__K, v: _of_5__V, k2: _of_5__K, v2: _of_5__V, k3: _of_5__K, v3: _of_5__V, k4: _of_5__K, v4: _of_5__V, k5: _of_5__K, v5: _of_5__V) -> ImmutableMap[_of_5__K, _of_5__V]: ...
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableSortedMap'[_of_6__K, _of_6__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_7__K, v: _of_7__V) -> 'ImmutableSortedMap'[_of_7__K, _of_7__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_8__K, v: _of_8__V, k2: _of_8__K, v2: _of_8__V) -> 'ImmutableSortedMap'[_of_8__K, _of_8__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_9__K, v: _of_9__V, k2: _of_9__K, v2: _of_9__V, k3: _of_9__K, v3: _of_9__V) -> 'ImmutableSortedMap'[_of_9__K, _of_9__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_10__K, v: _of_10__V, k2: _of_10__K, v2: _of_10__V, k3: _of_10__K, v3: _of_10__V, k4: _of_10__K, v4: _of_10__V) -> 'ImmutableSortedMap'[_of_10__K, _of_10__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_11__K, v: _of_11__V, k2: _of_11__K, v2: _of_11__V, k3: _of_11__K, v3: _of_11__V, k4: _of_11__K, v4: _of_11__V, k5: _of_11__K, v5: _of_11__V) -> 'ImmutableSortedMap'[_of_11__K, _of_11__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_12__K, v: _of_12__V) -> 'ImmutableSortedMap'[_of_12__K, _of_12__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_13__K, v: _of_13__V, k2: _of_13__K, v2: _of_13__V) -> 'ImmutableSortedMap'[_of_13__K, _of_13__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_14__K, v: _of_14__V, k2: _of_14__K, v2: _of_14__V, k3: _of_14__K, v3: _of_14__V) -> 'ImmutableSortedMap'[_of_14__K, _of_14__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_15__K, v: _of_15__V, k2: _of_15__K, v2: _of_15__V, k3: _of_15__K, v3: _of_15__V, k4: _of_15__K, v4: _of_15__V) -> 'ImmutableSortedMap'[_of_15__K, _of_15__V]: ...
    @typing.overload
    @staticmethod
    def of(k: _of_16__K, v: _of_16__V, k2: _of_16__K, v2: _of_16__V, k3: _of_16__K, v3: _of_16__V, k4: _of_16__K, v4: _of_16__V, k5: _of_16__K, v5: _of_16__V) -> 'ImmutableSortedMap'[_of_16__K, _of_16__V]: ...
    _orderedBy__K = typing.TypeVar('_orderedBy__K')  # <K>
    _orderedBy__V = typing.TypeVar('_orderedBy__V')  # <V>
    @staticmethod
    def orderedBy(comparator: typing.Union[java.util.Comparator[_orderedBy__K], typing.Callable[[_orderedBy__K, _orderedBy__K], int]]) -> 'ImmutableSortedMap.Builder'[_orderedBy__K, _orderedBy__V]: ...
    def pollFirstEntry(self) -> java.util.Map.Entry[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    def pollLastEntry(self) -> java.util.Map.Entry[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    _reverseOrder__K = typing.TypeVar('_reverseOrder__K', bound=java.lang.Comparable)  # <K>
    _reverseOrder__V = typing.TypeVar('_reverseOrder__V')  # <V>
    @staticmethod
    def reverseOrder() -> 'ImmutableSortedMap.Builder'[_reverseOrder__K, _reverseOrder__V]: ...
    def size(self) -> int: ...
    @typing.overload
    def subMap(self, k: _ImmutableSortedMap__K, boolean: bool, k2: _ImmutableSortedMap__K, boolean2: bool) -> 'ImmutableSortedMap'[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    @typing.overload
    def subMap(self, k: _ImmutableSortedMap__K, k2: _ImmutableSortedMap__K) -> 'ImmutableSortedMap'[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    @typing.overload
    def tailMap(self, k: _ImmutableSortedMap__K) -> 'ImmutableSortedMap'[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    @typing.overload
    def tailMap(self, k: _ImmutableSortedMap__K, boolean: bool) -> 'ImmutableSortedMap'[_ImmutableSortedMap__K, _ImmutableSortedMap__V]: ...
    _toImmutableSortedMap_0__T = typing.TypeVar('_toImmutableSortedMap_0__T')  # <T>
    _toImmutableSortedMap_0__K = typing.TypeVar('_toImmutableSortedMap_0__K')  # <K>
    _toImmutableSortedMap_0__V = typing.TypeVar('_toImmutableSortedMap_0__V')  # <V>
    _toImmutableSortedMap_1__T = typing.TypeVar('_toImmutableSortedMap_1__T')  # <T>
    _toImmutableSortedMap_1__K = typing.TypeVar('_toImmutableSortedMap_1__K')  # <K>
    _toImmutableSortedMap_1__V = typing.TypeVar('_toImmutableSortedMap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def toImmutableSortedMap(comparator: typing.Union[java.util.Comparator[_toImmutableSortedMap_0__K], typing.Callable[[_toImmutableSortedMap_0__K, _toImmutableSortedMap_0__K], int]], function: typing.Union[java.util.function.Function[_toImmutableSortedMap_0__T, _toImmutableSortedMap_0__K], typing.Callable[[_toImmutableSortedMap_0__T], _toImmutableSortedMap_0__K]], function2: typing.Union[java.util.function.Function[_toImmutableSortedMap_0__T, _toImmutableSortedMap_0__V], typing.Callable[[_toImmutableSortedMap_0__T], _toImmutableSortedMap_0__V]]) -> java.util.stream.Collector[_toImmutableSortedMap_0__T, typing.Any, 'ImmutableSortedMap'[_toImmutableSortedMap_0__K, _toImmutableSortedMap_0__V]]: ...
    @typing.overload
    @staticmethod
    def toImmutableSortedMap(comparator: typing.Union[java.util.Comparator[_toImmutableSortedMap_1__K], typing.Callable[[_toImmutableSortedMap_1__K, _toImmutableSortedMap_1__K], int]], function: typing.Union[java.util.function.Function[_toImmutableSortedMap_1__T, _toImmutableSortedMap_1__K], typing.Callable[[_toImmutableSortedMap_1__T], _toImmutableSortedMap_1__K]], function2: typing.Union[java.util.function.Function[_toImmutableSortedMap_1__T, _toImmutableSortedMap_1__V], typing.Callable[[_toImmutableSortedMap_1__T], _toImmutableSortedMap_1__V]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_toImmutableSortedMap_1__V], typing.Callable]) -> java.util.stream.Collector[_toImmutableSortedMap_1__T, typing.Any, 'ImmutableSortedMap'[_toImmutableSortedMap_1__K, _toImmutableSortedMap_1__V]]: ...
    def values(self) -> ImmutableCollection[_ImmutableSortedMap__V]: ...
    class Builder(ImmutableMap.Builder[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V], typing.Generic[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V]):
        """
        Java class 'com.google.common.collect.ImmutableSortedMap$Builder'
        
            Extends:
                com.google.common.collect.ImmutableMap$Builder
        
          Constructors:
            * Builder(java.util.Comparator)
        
        """
        def __init__(self, comparator: typing.Union[java.util.Comparator[_ImmutableSortedMap__Builder__K], typing.Callable[[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__K], int]]): ...
        def build(self) -> 'ImmutableSortedMap'[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V]: ...
        def orderEntriesByValue(self, comparator: typing.Union[java.util.Comparator[_ImmutableSortedMap__Builder__V], typing.Callable[[_ImmutableSortedMap__Builder__V, _ImmutableSortedMap__Builder__V], int]]) -> 'ImmutableSortedMap.Builder'[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V]: ...
        @typing.overload
        def put(self, k: _ImmutableSortedMap__Builder__K, v: _ImmutableSortedMap__Builder__V) -> 'ImmutableSortedMap.Builder'[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V]: ...
        @typing.overload
        def put(self, entry: java.util.Map.Entry[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V]) -> 'ImmutableSortedMap.Builder'[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V]: ...
        @typing.overload
        def putAll(self, iterable: java.lang.Iterable[java.util.Map.Entry[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V]]) -> 'ImmutableSortedMap.Builder'[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V]: ...
        @typing.overload
        def putAll(self, map: typing.Union[java.util.Map[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V], typing.Mapping[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V]]) -> 'ImmutableSortedMap.Builder'[_ImmutableSortedMap__Builder__K, _ImmutableSortedMap__Builder__V]: ...

_ImmutableSortedMultiset__Builder__E = typing.TypeVar('_ImmutableSortedMultiset__Builder__E')  # <E>
_ImmutableSortedMultiset__E = typing.TypeVar('_ImmutableSortedMultiset__E')  # <E>
class ImmutableSortedMultiset(com.google.common.collect.ImmutableSortedMultisetFauxverideShim[_ImmutableSortedMultiset__E], com.google.common.collect.SortedMultiset[_ImmutableSortedMultiset__E], typing.Generic[_ImmutableSortedMultiset__E]):
    """
    Java class 'com.google.common.collect.ImmutableSortedMultiset'
    
        Extends:
            com.google.common.collect.ImmutableSortedMultisetFauxverideShim
    
        Interfaces:
            com.google.common.collect.SortedMultiset
    
    """
    def comparator(self) -> java.util.Comparator[_ImmutableSortedMultiset__E]: ...
    _copyOf_0__E = typing.TypeVar('_copyOf_0__E')  # <E>
    _copyOf_1__E = typing.TypeVar('_copyOf_1__E')  # <E>
    _copyOf_2__E = typing.TypeVar('_copyOf_2__E')  # <E>
    _copyOf_3__E = typing.TypeVar('_copyOf_3__E', bound=java.lang.Comparable)  # <E>
    _copyOf_4__E = typing.TypeVar('_copyOf_4__E')  # <E>
    _copyOf_5__E = typing.TypeVar('_copyOf_5__E')  # <E>
    _copyOf_6__E = typing.TypeVar('_copyOf_6__E')  # <E>
    _copyOf_7__E = typing.TypeVar('_copyOf_7__E')  # <E>
    _copyOf_8__E = typing.TypeVar('_copyOf_8__E')  # <E>
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[_copyOf_0__E]) -> ImmutableMultiset[_copyOf_0__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(eArray: typing.List[_copyOf_1__E]) -> ImmutableMultiset[_copyOf_1__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterator: java.util.Iterator[_copyOf_2__E]) -> ImmutableMultiset[_copyOf_2__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(eArray: typing.List[_copyOf_3__E]) -> 'ImmutableSortedMultiset'[_copyOf_3__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[_copyOf_4__E]) -> 'ImmutableSortedMultiset'[_copyOf_4__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(comparator: typing.Union[java.util.Comparator[_copyOf_5__E], typing.Callable[[_copyOf_5__E, _copyOf_5__E], int]], iterable: java.lang.Iterable[_copyOf_5__E]) -> 'ImmutableSortedMultiset'[_copyOf_5__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(comparator: typing.Union[java.util.Comparator[_copyOf_6__E], typing.Callable[[_copyOf_6__E, _copyOf_6__E], int]], iterator: java.util.Iterator[_copyOf_6__E]) -> 'ImmutableSortedMultiset'[_copyOf_6__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterator: java.util.Iterator[_copyOf_7__E]) -> 'ImmutableSortedMultiset'[_copyOf_7__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(eArray: typing.List[_copyOf_8__E]) -> 'ImmutableSortedMultiset'[_copyOf_8__E]: ...
    _copyOfSorted__E = typing.TypeVar('_copyOfSorted__E')  # <E>
    @staticmethod
    def copyOfSorted(sortedMultiset: 'SortedMultiset'[_copyOfSorted__E]) -> 'ImmutableSortedMultiset'[_copyOfSorted__E]: ...
    def descendingMultiset(self) -> 'ImmutableSortedMultiset'[_ImmutableSortedMultiset__E]: ...
    def elementSet(self) -> 'ImmutableSortedSet'[_ImmutableSortedMultiset__E]: ...
    def headMultiset(self, e: _ImmutableSortedMultiset__E, boundType: BoundType) -> 'ImmutableSortedMultiset'[_ImmutableSortedMultiset__E]: ...
    _naturalOrder__E = typing.TypeVar('_naturalOrder__E', bound=java.lang.Comparable)  # <E>
    @staticmethod
    def naturalOrder() -> 'ImmutableSortedMultiset.Builder'[_naturalOrder__E]: ...
    _of_0__E = typing.TypeVar('_of_0__E')  # <E>
    _of_1__E = typing.TypeVar('_of_1__E')  # <E>
    _of_2__E = typing.TypeVar('_of_2__E')  # <E>
    _of_3__E = typing.TypeVar('_of_3__E')  # <E>
    _of_4__E = typing.TypeVar('_of_4__E')  # <E>
    _of_5__E = typing.TypeVar('_of_5__E')  # <E>
    _of_6__E = typing.TypeVar('_of_6__E')  # <E>
    _of_7__E = typing.TypeVar('_of_7__E')  # <E>
    _of_8__E = typing.TypeVar('_of_8__E', bound=java.lang.Comparable)  # <E>
    _of_9__E = typing.TypeVar('_of_9__E', bound=java.lang.Comparable)  # <E>
    _of_10__E = typing.TypeVar('_of_10__E', bound=java.lang.Comparable)  # <E>
    _of_11__E = typing.TypeVar('_of_11__E', bound=java.lang.Comparable)  # <E>
    _of_12__E = typing.TypeVar('_of_12__E', bound=java.lang.Comparable)  # <E>
    _of_13__E = typing.TypeVar('_of_13__E', bound=java.lang.Comparable)  # <E>
    _of_14__E = typing.TypeVar('_of_14__E')  # <E>
    _of_15__E = typing.TypeVar('_of_15__E')  # <E>
    _of_16__E = typing.TypeVar('_of_16__E')  # <E>
    _of_17__E = typing.TypeVar('_of_17__E')  # <E>
    _of_18__E = typing.TypeVar('_of_18__E')  # <E>
    _of_19__E = typing.TypeVar('_of_19__E')  # <E>
    @typing.overload
    @staticmethod
    def of() -> ImmutableMultiset[_of_0__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_1__E) -> ImmutableMultiset[_of_1__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_2__E, e2: _of_2__E) -> ImmutableMultiset[_of_2__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_3__E, e2: _of_3__E, e3: _of_3__E) -> ImmutableMultiset[_of_3__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_4__E, e2: _of_4__E, e3: _of_4__E, e4: _of_4__E) -> ImmutableMultiset[_of_4__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_5__E, e2: _of_5__E, e3: _of_5__E, e4: _of_5__E, e5: _of_5__E) -> ImmutableMultiset[_of_5__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_6__E, e2: _of_6__E, e3: _of_6__E, e4: _of_6__E, e5: _of_6__E, e6: _of_6__E, eArray: typing.List[_of_6__E]) -> ImmutableMultiset[_of_6__E]: ...
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableSortedMultiset'[_of_7__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_8__E) -> 'ImmutableSortedMultiset'[_of_8__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_9__E, e2: _of_9__E) -> 'ImmutableSortedMultiset'[_of_9__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_10__E, e2: _of_10__E, e3: _of_10__E) -> 'ImmutableSortedMultiset'[_of_10__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_11__E, e2: _of_11__E, e3: _of_11__E, e4: _of_11__E) -> 'ImmutableSortedMultiset'[_of_11__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_12__E, e2: _of_12__E, e3: _of_12__E, e4: _of_12__E, e5: _of_12__E) -> 'ImmutableSortedMultiset'[_of_12__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_13__E, e2: _of_13__E, e3: _of_13__E, e4: _of_13__E, e5: _of_13__E, e6: _of_13__E, eArray: typing.List[_of_13__E]) -> 'ImmutableSortedMultiset'[_of_13__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_14__E) -> 'ImmutableSortedMultiset'[_of_14__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_15__E, e2: _of_15__E) -> 'ImmutableSortedMultiset'[_of_15__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_16__E, e2: _of_16__E, e3: _of_16__E) -> 'ImmutableSortedMultiset'[_of_16__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_17__E, e2: _of_17__E, e3: _of_17__E, e4: _of_17__E) -> 'ImmutableSortedMultiset'[_of_17__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_18__E, e2: _of_18__E, e3: _of_18__E, e4: _of_18__E, e5: _of_18__E) -> 'ImmutableSortedMultiset'[_of_18__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_19__E, e2: _of_19__E, e3: _of_19__E, e4: _of_19__E, e5: _of_19__E, e6: _of_19__E, eArray: typing.List[_of_19__E]) -> 'ImmutableSortedMultiset'[_of_19__E]: ...
    _orderedBy__E = typing.TypeVar('_orderedBy__E')  # <E>
    @staticmethod
    def orderedBy(comparator: typing.Union[java.util.Comparator[_orderedBy__E], typing.Callable[[_orderedBy__E, _orderedBy__E], int]]) -> 'ImmutableSortedMultiset.Builder'[_orderedBy__E]: ...
    def pollFirstEntry(self) -> Multiset.Entry[_ImmutableSortedMultiset__E]: ...
    def pollLastEntry(self) -> Multiset.Entry[_ImmutableSortedMultiset__E]: ...
    _reverseOrder__E = typing.TypeVar('_reverseOrder__E', bound=java.lang.Comparable)  # <E>
    @staticmethod
    def reverseOrder() -> 'ImmutableSortedMultiset.Builder'[_reverseOrder__E]: ...
    def subMultiset(self, e: _ImmutableSortedMultiset__E, boundType: BoundType, e2: _ImmutableSortedMultiset__E, boundType2: BoundType) -> 'ImmutableSortedMultiset'[_ImmutableSortedMultiset__E]: ...
    def tailMultiset(self, e: _ImmutableSortedMultiset__E, boundType: BoundType) -> 'ImmutableSortedMultiset'[_ImmutableSortedMultiset__E]: ...
    _toImmutableSortedMultiset_0__E = typing.TypeVar('_toImmutableSortedMultiset_0__E')  # <E>
    _toImmutableSortedMultiset_1__T = typing.TypeVar('_toImmutableSortedMultiset_1__T')  # <T>
    _toImmutableSortedMultiset_1__E = typing.TypeVar('_toImmutableSortedMultiset_1__E')  # <E>
    @typing.overload
    @staticmethod
    def toImmutableSortedMultiset(comparator: typing.Union[java.util.Comparator[_toImmutableSortedMultiset_0__E], typing.Callable[[_toImmutableSortedMultiset_0__E, _toImmutableSortedMultiset_0__E], int]]) -> java.util.stream.Collector[_toImmutableSortedMultiset_0__E, typing.Any, 'ImmutableSortedMultiset'[_toImmutableSortedMultiset_0__E]]: ...
    @typing.overload
    @staticmethod
    def toImmutableSortedMultiset(comparator: typing.Union[java.util.Comparator[_toImmutableSortedMultiset_1__E], typing.Callable[[_toImmutableSortedMultiset_1__E, _toImmutableSortedMultiset_1__E], int]], function: typing.Union[java.util.function.Function[_toImmutableSortedMultiset_1__T, _toImmutableSortedMultiset_1__E], typing.Callable[[_toImmutableSortedMultiset_1__T], _toImmutableSortedMultiset_1__E]], toIntFunction: typing.Union[java.util.function.ToIntFunction[_toImmutableSortedMultiset_1__T], typing.Callable[[_toImmutableSortedMultiset_1__T], int]]) -> java.util.stream.Collector[_toImmutableSortedMultiset_1__T, typing.Any, 'ImmutableSortedMultiset'[_toImmutableSortedMultiset_1__E]]: ...
    class Builder(ImmutableMultiset.Builder[_ImmutableSortedMultiset__Builder__E], typing.Generic[_ImmutableSortedMultiset__Builder__E]):
        """
        Java class 'com.google.common.collect.ImmutableSortedMultiset$Builder'
        
            Extends:
                com.google.common.collect.ImmutableMultiset$Builder
        
          Constructors:
            * Builder(java.util.Comparator)
        
        """
        def __init__(self, comparator: typing.Union[java.util.Comparator[_ImmutableSortedMultiset__Builder__E], typing.Callable[[_ImmutableSortedMultiset__Builder__E, _ImmutableSortedMultiset__Builder__E], int]]): ...
        @typing.overload
        def add(self, e: _ImmutableSortedMultiset__Builder__E) -> 'ImmutableSortedMultiset.Builder'[_ImmutableSortedMultiset__Builder__E]: ...
        @typing.overload
        def add(self, eArray: typing.List[_ImmutableSortedMultiset__Builder__E]) -> 'ImmutableSortedMultiset.Builder'[_ImmutableSortedMultiset__Builder__E]: ...
        @typing.overload
        def addAll(self, iterable: java.lang.Iterable[_ImmutableSortedMultiset__Builder__E]) -> 'ImmutableSortedMultiset.Builder'[_ImmutableSortedMultiset__Builder__E]: ...
        @typing.overload
        def addAll(self, iterator: java.util.Iterator[_ImmutableSortedMultiset__Builder__E]) -> 'ImmutableSortedMultiset.Builder'[_ImmutableSortedMultiset__Builder__E]: ...
        def addCopies(self, e: _ImmutableSortedMultiset__Builder__E, int: int) -> 'ImmutableSortedMultiset.Builder'[_ImmutableSortedMultiset__Builder__E]: ...
        def build(self) -> 'ImmutableSortedMultiset'[_ImmutableSortedMultiset__Builder__E]: ...
        def setCount(self, e: _ImmutableSortedMultiset__Builder__E, int: int) -> 'ImmutableSortedMultiset.Builder'[_ImmutableSortedMultiset__Builder__E]: ...

_ImmutableSortedSet__Builder__E = typing.TypeVar('_ImmutableSortedSet__Builder__E')  # <E>
_ImmutableSortedSet__E = typing.TypeVar('_ImmutableSortedSet__E')  # <E>
class ImmutableSortedSet(com.google.common.collect.ImmutableSortedSetFauxverideShim[_ImmutableSortedSet__E], java.util.NavigableSet[_ImmutableSortedSet__E], com.google.common.collect.SortedIterable[_ImmutableSortedSet__E], typing.Generic[_ImmutableSortedSet__E]):
    """
    Java class 'com.google.common.collect.ImmutableSortedSet'
    
        Extends:
            com.google.common.collect.ImmutableSortedSetFauxverideShim
    
        Interfaces:
            java.util.NavigableSet,
            com.google.common.collect.SortedIterable
    
    """
    def ceiling(self, e: _ImmutableSortedSet__E) -> _ImmutableSortedSet__E: ...
    def comparator(self) -> java.util.Comparator[_ImmutableSortedSet__E]: ...
    _copyOf_0__E = typing.TypeVar('_copyOf_0__E')  # <E>
    _copyOf_1__E = typing.TypeVar('_copyOf_1__E')  # <E>
    _copyOf_2__E = typing.TypeVar('_copyOf_2__E')  # <E>
    _copyOf_3__E = typing.TypeVar('_copyOf_3__E')  # <E>
    _copyOf_4__E = typing.TypeVar('_copyOf_4__E', bound=java.lang.Comparable)  # <E>
    _copyOf_5__E = typing.TypeVar('_copyOf_5__E')  # <E>
    _copyOf_6__E = typing.TypeVar('_copyOf_6__E')  # <E>
    _copyOf_7__E = typing.TypeVar('_copyOf_7__E')  # <E>
    _copyOf_8__E = typing.TypeVar('_copyOf_8__E')  # <E>
    _copyOf_9__E = typing.TypeVar('_copyOf_9__E')  # <E>
    _copyOf_10__E = typing.TypeVar('_copyOf_10__E')  # <E>
    _copyOf_11__E = typing.TypeVar('_copyOf_11__E')  # <E>
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[_copyOf_0__E]) -> ImmutableSet[_copyOf_0__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(eArray: typing.List[_copyOf_1__E]) -> ImmutableSet[_copyOf_1__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(collection: typing.Union[java.util.Collection[_copyOf_2__E], typing.Sequence[_copyOf_2__E]]) -> ImmutableSet[_copyOf_2__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterator: java.util.Iterator[_copyOf_3__E]) -> ImmutableSet[_copyOf_3__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(eArray: typing.List[_copyOf_4__E]) -> 'ImmutableSortedSet'[_copyOf_4__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterable: java.lang.Iterable[_copyOf_5__E]) -> 'ImmutableSortedSet'[_copyOf_5__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(collection: typing.Union[java.util.Collection[_copyOf_6__E], typing.Sequence[_copyOf_6__E]]) -> 'ImmutableSortedSet'[_copyOf_6__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(comparator: typing.Union[java.util.Comparator[_copyOf_7__E], typing.Callable[[_copyOf_7__E, _copyOf_7__E], int]], iterable: java.lang.Iterable[_copyOf_7__E]) -> 'ImmutableSortedSet'[_copyOf_7__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(comparator: typing.Union[java.util.Comparator[_copyOf_8__E], typing.Callable[[_copyOf_8__E, _copyOf_8__E], int]], collection: typing.Union[java.util.Collection[_copyOf_8__E], typing.Sequence[_copyOf_8__E]]) -> 'ImmutableSortedSet'[_copyOf_8__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(comparator: typing.Union[java.util.Comparator[_copyOf_9__E], typing.Callable[[_copyOf_9__E, _copyOf_9__E], int]], iterator: java.util.Iterator[_copyOf_9__E]) -> 'ImmutableSortedSet'[_copyOf_9__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(iterator: java.util.Iterator[_copyOf_10__E]) -> 'ImmutableSortedSet'[_copyOf_10__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(eArray: typing.List[_copyOf_11__E]) -> 'ImmutableSortedSet'[_copyOf_11__E]: ...
    _copyOfSorted__E = typing.TypeVar('_copyOfSorted__E')  # <E>
    @staticmethod
    def copyOfSorted(sortedSet: java.util.SortedSet[_copyOfSorted__E]) -> 'ImmutableSortedSet'[_copyOfSorted__E]: ...
    def descendingIterator(self) -> UnmodifiableIterator[_ImmutableSortedSet__E]: ...
    def descendingSet(self) -> 'ImmutableSortedSet'[_ImmutableSortedSet__E]: ...
    def first(self) -> _ImmutableSortedSet__E: ...
    def floor(self, e: _ImmutableSortedSet__E) -> _ImmutableSortedSet__E: ...
    @typing.overload
    def headSet(self, e: _ImmutableSortedSet__E) -> 'ImmutableSortedSet'[_ImmutableSortedSet__E]: ...
    @typing.overload
    def headSet(self, e: _ImmutableSortedSet__E, boolean: bool) -> 'ImmutableSortedSet'[_ImmutableSortedSet__E]: ...
    def higher(self, e: _ImmutableSortedSet__E) -> _ImmutableSortedSet__E: ...
    def iterator(self) -> UnmodifiableIterator[_ImmutableSortedSet__E]: ...
    def last(self) -> _ImmutableSortedSet__E: ...
    def lower(self, e: _ImmutableSortedSet__E) -> _ImmutableSortedSet__E: ...
    _naturalOrder__E = typing.TypeVar('_naturalOrder__E', bound=java.lang.Comparable)  # <E>
    @staticmethod
    def naturalOrder() -> 'ImmutableSortedSet.Builder'[_naturalOrder__E]: ...
    _of_0__E = typing.TypeVar('_of_0__E')  # <E>
    _of_1__E = typing.TypeVar('_of_1__E')  # <E>
    _of_2__E = typing.TypeVar('_of_2__E')  # <E>
    _of_3__E = typing.TypeVar('_of_3__E')  # <E>
    _of_4__E = typing.TypeVar('_of_4__E')  # <E>
    _of_5__E = typing.TypeVar('_of_5__E')  # <E>
    _of_6__E = typing.TypeVar('_of_6__E')  # <E>
    _of_7__E = typing.TypeVar('_of_7__E')  # <E>
    _of_8__E = typing.TypeVar('_of_8__E', bound=java.lang.Comparable)  # <E>
    _of_9__E = typing.TypeVar('_of_9__E', bound=java.lang.Comparable)  # <E>
    _of_10__E = typing.TypeVar('_of_10__E', bound=java.lang.Comparable)  # <E>
    _of_11__E = typing.TypeVar('_of_11__E', bound=java.lang.Comparable)  # <E>
    _of_12__E = typing.TypeVar('_of_12__E', bound=java.lang.Comparable)  # <E>
    _of_13__E = typing.TypeVar('_of_13__E', bound=java.lang.Comparable)  # <E>
    _of_14__E = typing.TypeVar('_of_14__E')  # <E>
    _of_15__E = typing.TypeVar('_of_15__E')  # <E>
    _of_16__E = typing.TypeVar('_of_16__E')  # <E>
    _of_17__E = typing.TypeVar('_of_17__E')  # <E>
    _of_18__E = typing.TypeVar('_of_18__E')  # <E>
    _of_19__E = typing.TypeVar('_of_19__E')  # <E>
    @typing.overload
    @staticmethod
    def of() -> ImmutableSet[_of_0__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_1__E) -> ImmutableSet[_of_1__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_2__E, e2: _of_2__E) -> ImmutableSet[_of_2__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_3__E, e2: _of_3__E, e3: _of_3__E) -> ImmutableSet[_of_3__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_4__E, e2: _of_4__E, e3: _of_4__E, e4: _of_4__E) -> ImmutableSet[_of_4__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_5__E, e2: _of_5__E, e3: _of_5__E, e4: _of_5__E, e5: _of_5__E) -> ImmutableSet[_of_5__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_6__E, e2: _of_6__E, e3: _of_6__E, e4: _of_6__E, e5: _of_6__E, e6: _of_6__E, eArray: typing.List[_of_6__E]) -> ImmutableSet[_of_6__E]: ...
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableSortedSet'[_of_7__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_8__E) -> 'ImmutableSortedSet'[_of_8__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_9__E, e2: _of_9__E) -> 'ImmutableSortedSet'[_of_9__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_10__E, e2: _of_10__E, e3: _of_10__E) -> 'ImmutableSortedSet'[_of_10__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_11__E, e2: _of_11__E, e3: _of_11__E, e4: _of_11__E) -> 'ImmutableSortedSet'[_of_11__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_12__E, e2: _of_12__E, e3: _of_12__E, e4: _of_12__E, e5: _of_12__E) -> 'ImmutableSortedSet'[_of_12__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_13__E, e2: _of_13__E, e3: _of_13__E, e4: _of_13__E, e5: _of_13__E, e6: _of_13__E, eArray: typing.List[_of_13__E]) -> 'ImmutableSortedSet'[_of_13__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_14__E) -> 'ImmutableSortedSet'[_of_14__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_15__E, e2: _of_15__E) -> 'ImmutableSortedSet'[_of_15__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_16__E, e2: _of_16__E, e3: _of_16__E) -> 'ImmutableSortedSet'[_of_16__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_17__E, e2: _of_17__E, e3: _of_17__E, e4: _of_17__E) -> 'ImmutableSortedSet'[_of_17__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_18__E, e2: _of_18__E, e3: _of_18__E, e4: _of_18__E, e5: _of_18__E) -> 'ImmutableSortedSet'[_of_18__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_19__E, e2: _of_19__E, e3: _of_19__E, e4: _of_19__E, e5: _of_19__E, e6: _of_19__E, eArray: typing.List[_of_19__E]) -> 'ImmutableSortedSet'[_of_19__E]: ...
    _orderedBy__E = typing.TypeVar('_orderedBy__E')  # <E>
    @staticmethod
    def orderedBy(comparator: typing.Union[java.util.Comparator[_orderedBy__E], typing.Callable[[_orderedBy__E, _orderedBy__E], int]]) -> 'ImmutableSortedSet.Builder'[_orderedBy__E]: ...
    def pollFirst(self) -> _ImmutableSortedSet__E: ...
    def pollLast(self) -> _ImmutableSortedSet__E: ...
    _reverseOrder__E = typing.TypeVar('_reverseOrder__E', bound=java.lang.Comparable)  # <E>
    @staticmethod
    def reverseOrder() -> 'ImmutableSortedSet.Builder'[_reverseOrder__E]: ...
    def spliterator(self) -> java.util.Spliterator[_ImmutableSortedSet__E]: ...
    @typing.overload
    def subSet(self, e: _ImmutableSortedSet__E, boolean: bool, e2: _ImmutableSortedSet__E, boolean2: bool) -> 'ImmutableSortedSet'[_ImmutableSortedSet__E]: ...
    @typing.overload
    def subSet(self, e: _ImmutableSortedSet__E, e2: _ImmutableSortedSet__E) -> 'ImmutableSortedSet'[_ImmutableSortedSet__E]: ...
    @typing.overload
    def tailSet(self, e: _ImmutableSortedSet__E) -> 'ImmutableSortedSet'[_ImmutableSortedSet__E]: ...
    @typing.overload
    def tailSet(self, e: _ImmutableSortedSet__E, boolean: bool) -> 'ImmutableSortedSet'[_ImmutableSortedSet__E]: ...
    _toImmutableSortedSet__E = typing.TypeVar('_toImmutableSortedSet__E')  # <E>
    @staticmethod
    def toImmutableSortedSet(comparator: typing.Union[java.util.Comparator[_toImmutableSortedSet__E], typing.Callable[[_toImmutableSortedSet__E, _toImmutableSortedSet__E], int]]) -> java.util.stream.Collector[_toImmutableSortedSet__E, typing.Any, 'ImmutableSortedSet'[_toImmutableSortedSet__E]]: ...
    class Builder(ImmutableSet.Builder[_ImmutableSortedSet__Builder__E], typing.Generic[_ImmutableSortedSet__Builder__E]):
        """
        Java class 'com.google.common.collect.ImmutableSortedSet$Builder'
        
            Extends:
                com.google.common.collect.ImmutableSet$Builder
        
          Constructors:
            * Builder(java.util.Comparator)
        
        """
        def __init__(self, comparator: typing.Union[java.util.Comparator[_ImmutableSortedSet__Builder__E], typing.Callable[[_ImmutableSortedSet__Builder__E, _ImmutableSortedSet__Builder__E], int]]): ...
        @typing.overload
        def add(self, e: _ImmutableSortedSet__Builder__E) -> 'ImmutableSortedSet.Builder'[_ImmutableSortedSet__Builder__E]: ...
        @typing.overload
        def add(self, eArray: typing.List[_ImmutableSortedSet__Builder__E]) -> 'ImmutableSortedSet.Builder'[_ImmutableSortedSet__Builder__E]: ...
        @typing.overload
        def addAll(self, iterable: java.lang.Iterable[_ImmutableSortedSet__Builder__E]) -> 'ImmutableSortedSet.Builder'[_ImmutableSortedSet__Builder__E]: ...
        @typing.overload
        def addAll(self, iterator: java.util.Iterator[_ImmutableSortedSet__Builder__E]) -> 'ImmutableSortedSet.Builder'[_ImmutableSortedSet__Builder__E]: ...
        def build(self) -> 'ImmutableSortedSet'[_ImmutableSortedSet__Builder__E]: ...

_ImmutableTable__Builder__R = typing.TypeVar('_ImmutableTable__Builder__R')  # <R>
_ImmutableTable__Builder__C = typing.TypeVar('_ImmutableTable__Builder__C')  # <C>
_ImmutableTable__Builder__V = typing.TypeVar('_ImmutableTable__Builder__V')  # <V>
_ImmutableTable__R = typing.TypeVar('_ImmutableTable__R')  # <R>
_ImmutableTable__C = typing.TypeVar('_ImmutableTable__C')  # <C>
_ImmutableTable__V = typing.TypeVar('_ImmutableTable__V')  # <V>
class ImmutableTable(com.google.common.collect.AbstractTable[_ImmutableTable__R, _ImmutableTable__C, _ImmutableTable__V], java.io.Serializable, typing.Generic[_ImmutableTable__R, _ImmutableTable__C, _ImmutableTable__V]):
    """
    Java class 'com.google.common.collect.ImmutableTable'
    
        Extends:
            com.google.common.collect.AbstractTable
    
        Interfaces:
            java.io.Serializable
    
    """
    _builder__R = typing.TypeVar('_builder__R')  # <R>
    _builder__C = typing.TypeVar('_builder__C')  # <C>
    _builder__V = typing.TypeVar('_builder__V')  # <V>
    @staticmethod
    def builder() -> 'ImmutableTable.Builder'[_builder__R, _builder__C, _builder__V]: ...
    def cellSet(self) -> ImmutableSet[Table.Cell[_ImmutableTable__R, _ImmutableTable__C, _ImmutableTable__V]]: ...
    def clear(self) -> None: ...
    def column(self, c: _ImmutableTable__C) -> ImmutableMap[_ImmutableTable__R, _ImmutableTable__V]: ...
    def columnKeySet(self) -> ImmutableSet[_ImmutableTable__C]: ...
    def columnMap(self) -> ImmutableMap[_ImmutableTable__C, java.util.Map[_ImmutableTable__R, _ImmutableTable__V]]: ...
    def contains(self, object: typing.Any, object2: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    _copyOf__R = typing.TypeVar('_copyOf__R')  # <R>
    _copyOf__C = typing.TypeVar('_copyOf__C')  # <C>
    _copyOf__V = typing.TypeVar('_copyOf__V')  # <V>
    @staticmethod
    def copyOf(table: Table[_copyOf__R, _copyOf__C, _copyOf__V]) -> 'ImmutableTable'[_copyOf__R, _copyOf__C, _copyOf__V]: ...
    _of_0__R = typing.TypeVar('_of_0__R')  # <R>
    _of_0__C = typing.TypeVar('_of_0__C')  # <C>
    _of_0__V = typing.TypeVar('_of_0__V')  # <V>
    _of_1__R = typing.TypeVar('_of_1__R')  # <R>
    _of_1__C = typing.TypeVar('_of_1__C')  # <C>
    _of_1__V = typing.TypeVar('_of_1__V')  # <V>
    @typing.overload
    @staticmethod
    def of() -> 'ImmutableTable'[_of_0__R, _of_0__C, _of_0__V]: ...
    @typing.overload
    @staticmethod
    def of(r: _of_1__R, c: _of_1__C, v: _of_1__V) -> 'ImmutableTable'[_of_1__R, _of_1__C, _of_1__V]: ...
    def put(self, r: _ImmutableTable__R, c: _ImmutableTable__C, v: _ImmutableTable__V) -> _ImmutableTable__V: ...
    def putAll(self, table: Table[_ImmutableTable__R, _ImmutableTable__C, _ImmutableTable__V]) -> None: ...
    def remove(self, object: typing.Any, object2: typing.Any) -> _ImmutableTable__V: ...
    def row(self, r: _ImmutableTable__R) -> ImmutableMap[_ImmutableTable__C, _ImmutableTable__V]: ...
    def rowKeySet(self) -> ImmutableSet[_ImmutableTable__R]: ...
    def rowMap(self) -> ImmutableMap[_ImmutableTable__R, java.util.Map[_ImmutableTable__C, _ImmutableTable__V]]: ...
    _toImmutableTable_0__T = typing.TypeVar('_toImmutableTable_0__T')  # <T>
    _toImmutableTable_0__R = typing.TypeVar('_toImmutableTable_0__R')  # <R>
    _toImmutableTable_0__C = typing.TypeVar('_toImmutableTable_0__C')  # <C>
    _toImmutableTable_0__V = typing.TypeVar('_toImmutableTable_0__V')  # <V>
    _toImmutableTable_1__T = typing.TypeVar('_toImmutableTable_1__T')  # <T>
    _toImmutableTable_1__R = typing.TypeVar('_toImmutableTable_1__R')  # <R>
    _toImmutableTable_1__C = typing.TypeVar('_toImmutableTable_1__C')  # <C>
    _toImmutableTable_1__V = typing.TypeVar('_toImmutableTable_1__V')  # <V>
    @typing.overload
    @staticmethod
    def toImmutableTable(function: typing.Union[java.util.function.Function[_toImmutableTable_0__T, _toImmutableTable_0__R], typing.Callable[[_toImmutableTable_0__T], _toImmutableTable_0__R]], function2: typing.Union[java.util.function.Function[_toImmutableTable_0__T, _toImmutableTable_0__C], typing.Callable[[_toImmutableTable_0__T], _toImmutableTable_0__C]], function3: typing.Union[java.util.function.Function[_toImmutableTable_0__T, _toImmutableTable_0__V], typing.Callable[[_toImmutableTable_0__T], _toImmutableTable_0__V]]) -> java.util.stream.Collector[_toImmutableTable_0__T, typing.Any, 'ImmutableTable'[_toImmutableTable_0__R, _toImmutableTable_0__C, _toImmutableTable_0__V]]: ...
    @typing.overload
    @staticmethod
    def toImmutableTable(function: typing.Union[java.util.function.Function[_toImmutableTable_1__T, _toImmutableTable_1__R], typing.Callable[[_toImmutableTable_1__T], _toImmutableTable_1__R]], function2: typing.Union[java.util.function.Function[_toImmutableTable_1__T, _toImmutableTable_1__C], typing.Callable[[_toImmutableTable_1__T], _toImmutableTable_1__C]], function3: typing.Union[java.util.function.Function[_toImmutableTable_1__T, _toImmutableTable_1__V], typing.Callable[[_toImmutableTable_1__T], _toImmutableTable_1__V]], binaryOperator: typing.Union[java.util.function.BinaryOperator[_toImmutableTable_1__V], typing.Callable]) -> java.util.stream.Collector[_toImmutableTable_1__T, typing.Any, 'ImmutableTable'[_toImmutableTable_1__R, _toImmutableTable_1__C, _toImmutableTable_1__V]]: ...
    def values(self) -> ImmutableCollection[_ImmutableTable__V]: ...
    class Builder(typing.Generic[_ImmutableTable__Builder__R, _ImmutableTable__Builder__C, _ImmutableTable__Builder__V]):
        """
        Java class 'com.google.common.collect.ImmutableTable$Builder'
        
            Extends:
                java.lang.Object
        
          Constructors:
            * Builder()
        
        """
        def __init__(self): ...
        def build(self) -> 'ImmutableTable'[_ImmutableTable__Builder__R, _ImmutableTable__Builder__C, _ImmutableTable__Builder__V]: ...
        def orderColumnsBy(self, comparator: typing.Union[java.util.Comparator[_ImmutableTable__Builder__C], typing.Callable[[_ImmutableTable__Builder__C, _ImmutableTable__Builder__C], int]]) -> 'ImmutableTable.Builder'[_ImmutableTable__Builder__R, _ImmutableTable__Builder__C, _ImmutableTable__Builder__V]: ...
        def orderRowsBy(self, comparator: typing.Union[java.util.Comparator[_ImmutableTable__Builder__R], typing.Callable[[_ImmutableTable__Builder__R, _ImmutableTable__Builder__R], int]]) -> 'ImmutableTable.Builder'[_ImmutableTable__Builder__R, _ImmutableTable__Builder__C, _ImmutableTable__Builder__V]: ...
        @typing.overload
        def put(self, cell: Table.Cell[_ImmutableTable__Builder__R, _ImmutableTable__Builder__C, _ImmutableTable__Builder__V]) -> 'ImmutableTable.Builder'[_ImmutableTable__Builder__R, _ImmutableTable__Builder__C, _ImmutableTable__Builder__V]: ...
        @typing.overload
        def put(self, r: _ImmutableTable__Builder__R, c: _ImmutableTable__Builder__C, v: _ImmutableTable__Builder__V) -> 'ImmutableTable.Builder'[_ImmutableTable__Builder__R, _ImmutableTable__Builder__C, _ImmutableTable__Builder__V]: ...
        def putAll(self, table: Table[_ImmutableTable__Builder__R, _ImmutableTable__Builder__C, _ImmutableTable__Builder__V]) -> 'ImmutableTable.Builder'[_ImmutableTable__Builder__R, _ImmutableTable__Builder__C, _ImmutableTable__Builder__V]: ...

_LinkedHashMultimap__K = typing.TypeVar('_LinkedHashMultimap__K')  # <K>
_LinkedHashMultimap__V = typing.TypeVar('_LinkedHashMultimap__V')  # <V>
class LinkedHashMultimap(com.google.common.collect.LinkedHashMultimapGwtSerializationDependencies[_LinkedHashMultimap__K, _LinkedHashMultimap__V], typing.Generic[_LinkedHashMultimap__K, _LinkedHashMultimap__V]):
    """
    Java class 'com.google.common.collect.LinkedHashMultimap'
    
        Extends:
            com.google.common.collect.LinkedHashMultimapGwtSerializationDependencies
    
    """
    def clear(self) -> None: ...
    _create_0__K = typing.TypeVar('_create_0__K')  # <K>
    _create_0__V = typing.TypeVar('_create_0__V')  # <V>
    _create_1__K = typing.TypeVar('_create_1__K')  # <K>
    _create_1__V = typing.TypeVar('_create_1__V')  # <V>
    _create_2__K = typing.TypeVar('_create_2__K')  # <K>
    _create_2__V = typing.TypeVar('_create_2__V')  # <V>
    @typing.overload
    @staticmethod
    def create() -> 'LinkedHashMultimap'[_create_0__K, _create_0__V]: ...
    @typing.overload
    @staticmethod
    def create(multimap: Multimap[_create_1__K, _create_1__V]) -> 'LinkedHashMultimap'[_create_1__K, _create_1__V]: ...
    @typing.overload
    @staticmethod
    def create(int: int, int2: int) -> 'LinkedHashMultimap'[_create_2__K, _create_2__V]: ...
    def entries(self) -> java.util.Set[java.util.Map.Entry[_LinkedHashMultimap__K, _LinkedHashMultimap__V]]: ...
    def keySet(self) -> java.util.Set[_LinkedHashMultimap__K]: ...
    def replaceValues(self, k: _LinkedHashMultimap__K, iterable: java.lang.Iterable[_LinkedHashMultimap__V]) -> java.util.Set[_LinkedHashMultimap__V]: ...
    def values(self) -> java.util.Collection[_LinkedHashMultimap__V]: ...

_LinkedHashMultiset__E = typing.TypeVar('_LinkedHashMultiset__E')  # <E>
class LinkedHashMultiset(com.google.common.collect.AbstractMapBasedMultiset[_LinkedHashMultiset__E], typing.Generic[_LinkedHashMultiset__E]):
    """
    Java class 'com.google.common.collect.LinkedHashMultiset'
    
        Extends:
            com.google.common.collect.AbstractMapBasedMultiset
    
    """
    def add(self, e: _LinkedHashMultiset__E) -> bool: ...
    _create_0__E = typing.TypeVar('_create_0__E')  # <E>
    _create_1__E = typing.TypeVar('_create_1__E')  # <E>
    _create_2__E = typing.TypeVar('_create_2__E')  # <E>
    @typing.overload
    @staticmethod
    def create() -> 'LinkedHashMultiset'[_create_0__E]: ...
    @typing.overload
    @staticmethod
    def create(int: int) -> 'LinkedHashMultiset'[_create_1__E]: ...
    @typing.overload
    @staticmethod
    def create(iterable: java.lang.Iterable[_create_2__E]) -> 'LinkedHashMultiset'[_create_2__E]: ...
    def remove(self, object: typing.Any) -> bool: ...

_LinkedListMultimap__K = typing.TypeVar('_LinkedListMultimap__K')  # <K>
_LinkedListMultimap__V = typing.TypeVar('_LinkedListMultimap__V')  # <V>
class LinkedListMultimap(com.google.common.collect.AbstractMultimap[_LinkedListMultimap__K, _LinkedListMultimap__V], ListMultimap[_LinkedListMultimap__K, _LinkedListMultimap__V], java.io.Serializable, typing.Generic[_LinkedListMultimap__K, _LinkedListMultimap__V]):
    """
    Java class 'com.google.common.collect.LinkedListMultimap'
    
        Extends:
            com.google.common.collect.AbstractMultimap
    
        Interfaces:
            com.google.common.collect.ListMultimap, java.io.Serializable
    
    """
    def clear(self) -> None: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    _create_0__K = typing.TypeVar('_create_0__K')  # <K>
    _create_0__V = typing.TypeVar('_create_0__V')  # <V>
    _create_1__K = typing.TypeVar('_create_1__K')  # <K>
    _create_1__V = typing.TypeVar('_create_1__V')  # <V>
    _create_2__K = typing.TypeVar('_create_2__K')  # <K>
    _create_2__V = typing.TypeVar('_create_2__V')  # <V>
    @typing.overload
    @staticmethod
    def create() -> 'LinkedListMultimap'[_create_0__K, _create_0__V]: ...
    @typing.overload
    @staticmethod
    def create(multimap: Multimap[_create_1__K, _create_1__V]) -> 'LinkedListMultimap'[_create_1__K, _create_1__V]: ...
    @typing.overload
    @staticmethod
    def create(int: int) -> 'LinkedListMultimap'[_create_2__K, _create_2__V]: ...
    def entries(self) -> java.util.List[java.util.Map.Entry[_LinkedListMultimap__K, _LinkedListMultimap__V]]: ...
    def get(self, k: _LinkedListMultimap__K) -> java.util.List[_LinkedListMultimap__V]: ...
    def isEmpty(self) -> bool: ...
    def put(self, k: _LinkedListMultimap__K, v: _LinkedListMultimap__V) -> bool: ...
    def removeAll(self, object: typing.Any) -> java.util.List[_LinkedListMultimap__V]: ...
    def replaceValues(self, k: _LinkedListMultimap__K, iterable: java.lang.Iterable[_LinkedListMultimap__V]) -> java.util.List[_LinkedListMultimap__V]: ...
    def size(self) -> int: ...
    def values(self) -> java.util.List[_LinkedListMultimap__V]: ...

_MultimapBuilder__ListMultimapBuilder__K0 = typing.TypeVar('_MultimapBuilder__ListMultimapBuilder__K0')  # <K0>
_MultimapBuilder__ListMultimapBuilder__V0 = typing.TypeVar('_MultimapBuilder__ListMultimapBuilder__V0')  # <V0>
_MultimapBuilder__MultimapBuilderWithKeys__K0 = typing.TypeVar('_MultimapBuilder__MultimapBuilderWithKeys__K0')  # <K0>
_MultimapBuilder__SetMultimapBuilder__K0 = typing.TypeVar('_MultimapBuilder__SetMultimapBuilder__K0')  # <K0>
_MultimapBuilder__SetMultimapBuilder__V0 = typing.TypeVar('_MultimapBuilder__SetMultimapBuilder__V0')  # <V0>
_MultimapBuilder__SortedSetMultimapBuilder__K0 = typing.TypeVar('_MultimapBuilder__SortedSetMultimapBuilder__K0')  # <K0>
_MultimapBuilder__SortedSetMultimapBuilder__V0 = typing.TypeVar('_MultimapBuilder__SortedSetMultimapBuilder__V0')  # <V0>
_MultimapBuilder__K0 = typing.TypeVar('_MultimapBuilder__K0')  # <K0>
_MultimapBuilder__V0 = typing.TypeVar('_MultimapBuilder__V0')  # <V0>
class MultimapBuilder(typing.Generic[_MultimapBuilder__K0, _MultimapBuilder__V0]):
    """
    Java class 'com.google.common.collect.MultimapBuilder'
    
        Extends:
            java.lang.Object
    
    """
    _build_0__K = typing.TypeVar('_build_0__K')  # <K>
    _build_0__V = typing.TypeVar('_build_0__V')  # <V>
    _build_1__K = typing.TypeVar('_build_1__K')  # <K>
    _build_1__V = typing.TypeVar('_build_1__V')  # <V>
    @typing.overload
    def build(self) -> Multimap[_build_0__K, _build_0__V]: ...
    @typing.overload
    def build(self, multimap: Multimap[_build_1__K, _build_1__V]) -> Multimap[_build_1__K, _build_1__V]: ...
    _enumKeys__K0 = typing.TypeVar('_enumKeys__K0', bound=java.lang.Enum)  # <K0>
    @staticmethod
    def enumKeys(class_: typing.Type[_enumKeys__K0]) -> 'MultimapBuilder.MultimapBuilderWithKeys'[_enumKeys__K0]: ...
    @typing.overload
    @staticmethod
    def hashKeys() -> 'MultimapBuilder.MultimapBuilderWithKeys'[typing.Any]: ...
    @typing.overload
    @staticmethod
    def hashKeys(int: int) -> 'MultimapBuilder.MultimapBuilderWithKeys'[typing.Any]: ...
    @typing.overload
    @staticmethod
    def linkedHashKeys() -> 'MultimapBuilder.MultimapBuilderWithKeys'[typing.Any]: ...
    @typing.overload
    @staticmethod
    def linkedHashKeys(int: int) -> 'MultimapBuilder.MultimapBuilderWithKeys'[typing.Any]: ...
    _treeKeys_1__K0 = typing.TypeVar('_treeKeys_1__K0')  # <K0>
    @typing.overload
    @staticmethod
    def treeKeys() -> 'MultimapBuilder.MultimapBuilderWithKeys'[java.lang.Comparable]: ...
    @typing.overload
    @staticmethod
    def treeKeys(comparator: typing.Union[java.util.Comparator[_treeKeys_1__K0], typing.Callable[[_treeKeys_1__K0, _treeKeys_1__K0], int]]) -> 'MultimapBuilder.MultimapBuilderWithKeys'[_treeKeys_1__K0]: ...
    class ListMultimapBuilder(com.google.common.collect.MultimapBuilder[_MultimapBuilder__ListMultimapBuilder__K0, _MultimapBuilder__ListMultimapBuilder__V0], typing.Generic[_MultimapBuilder__ListMultimapBuilder__K0, _MultimapBuilder__ListMultimapBuilder__V0]):
        """
        Java class 'com.google.common.collect.MultimapBuilder$ListMultimapBuilder'
        
            Extends:
                com.google.common.collect.MultimapBuilder
        
        """
        _build_0__K = typing.TypeVar('_build_0__K')  # <K>
        _build_0__V = typing.TypeVar('_build_0__V')  # <V>
        _build_1__K = typing.TypeVar('_build_1__K')  # <K>
        _build_1__V = typing.TypeVar('_build_1__V')  # <V>
        @typing.overload
        def build(self) -> ListMultimap[_build_0__K, _build_0__V]: ...
        @typing.overload
        def build(self, multimap: Multimap[_build_1__K, _build_1__V]) -> ListMultimap[_build_1__K, _build_1__V]: ...
    class MultimapBuilderWithKeys(typing.Generic[_MultimapBuilder__MultimapBuilderWithKeys__K0]):
        """
        Java class 'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys'
        
            Extends:
                java.lang.Object
        
        """
        @typing.overload
        def arrayListValues(self) -> 'MultimapBuilder.ListMultimapBuilder'[_MultimapBuilder__MultimapBuilderWithKeys__K0, typing.Any]: ...
        @typing.overload
        def arrayListValues(self, int: int) -> 'MultimapBuilder.ListMultimapBuilder'[_MultimapBuilder__MultimapBuilderWithKeys__K0, typing.Any]: ...
        _enumSetValues__V0 = typing.TypeVar('_enumSetValues__V0', bound=java.lang.Enum)  # <V0>
        def enumSetValues(self, class_: typing.Type[_enumSetValues__V0]) -> 'MultimapBuilder.SetMultimapBuilder'[_MultimapBuilder__MultimapBuilderWithKeys__K0, _enumSetValues__V0]: ...
        @typing.overload
        def hashSetValues(self) -> 'MultimapBuilder.SetMultimapBuilder'[_MultimapBuilder__MultimapBuilderWithKeys__K0, typing.Any]: ...
        @typing.overload
        def hashSetValues(self, int: int) -> 'MultimapBuilder.SetMultimapBuilder'[_MultimapBuilder__MultimapBuilderWithKeys__K0, typing.Any]: ...
        @typing.overload
        def linkedHashSetValues(self) -> 'MultimapBuilder.SetMultimapBuilder'[_MultimapBuilder__MultimapBuilderWithKeys__K0, typing.Any]: ...
        @typing.overload
        def linkedHashSetValues(self, int: int) -> 'MultimapBuilder.SetMultimapBuilder'[_MultimapBuilder__MultimapBuilderWithKeys__K0, typing.Any]: ...
        def linkedListValues(self) -> 'MultimapBuilder.ListMultimapBuilder'[_MultimapBuilder__MultimapBuilderWithKeys__K0, typing.Any]: ...
        _treeSetValues_1__V0 = typing.TypeVar('_treeSetValues_1__V0')  # <V0>
        @typing.overload
        def treeSetValues(self) -> 'MultimapBuilder.SortedSetMultimapBuilder'[_MultimapBuilder__MultimapBuilderWithKeys__K0, java.lang.Comparable]: ...
        @typing.overload
        def treeSetValues(self, comparator: typing.Union[java.util.Comparator[_treeSetValues_1__V0], typing.Callable[[_treeSetValues_1__V0, _treeSetValues_1__V0], int]]) -> 'MultimapBuilder.SortedSetMultimapBuilder'[_MultimapBuilder__MultimapBuilderWithKeys__K0, _treeSetValues_1__V0]: ...
    class SetMultimapBuilder(com.google.common.collect.MultimapBuilder[_MultimapBuilder__SetMultimapBuilder__K0, _MultimapBuilder__SetMultimapBuilder__V0], typing.Generic[_MultimapBuilder__SetMultimapBuilder__K0, _MultimapBuilder__SetMultimapBuilder__V0]):
        """
        Java class 'com.google.common.collect.MultimapBuilder$SetMultimapBuilder'
        
            Extends:
                com.google.common.collect.MultimapBuilder
        
        """
        _build_0__K = typing.TypeVar('_build_0__K')  # <K>
        _build_0__V = typing.TypeVar('_build_0__V')  # <V>
        _build_1__K = typing.TypeVar('_build_1__K')  # <K>
        _build_1__V = typing.TypeVar('_build_1__V')  # <V>
        @typing.overload
        def build(self) -> SetMultimap[_build_0__K, _build_0__V]: ...
        @typing.overload
        def build(self, multimap: Multimap[_build_1__K, _build_1__V]) -> SetMultimap[_build_1__K, _build_1__V]: ...
    class SortedSetMultimapBuilder(com.google.common.collect.MultimapBuilder.SetMultimapBuilder[_MultimapBuilder__SortedSetMultimapBuilder__K0, _MultimapBuilder__SortedSetMultimapBuilder__V0], typing.Generic[_MultimapBuilder__SortedSetMultimapBuilder__K0, _MultimapBuilder__SortedSetMultimapBuilder__V0]):
        """
        Java class 'com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder'
        
            Extends:
                com.google.common.collect.MultimapBuilder$SetMultimapBuilder
        
        """
        _build_0__K = typing.TypeVar('_build_0__K')  # <K>
        _build_0__V = typing.TypeVar('_build_0__V')  # <V>
        _build_1__K = typing.TypeVar('_build_1__K')  # <K>
        _build_1__V = typing.TypeVar('_build_1__V')  # <V>
        @typing.overload
        def build(self) -> SortedSetMultimap[_build_0__K, _build_0__V]: ...
        @typing.overload
        def build(self, multimap: Multimap[_build_1__K, _build_1__V]) -> SortedSetMultimap[_build_1__K, _build_1__V]: ...

_Range__C = typing.TypeVar('_Range__C', bound=java.lang.Comparable)  # <C>
class Range(com.google.common.collect.RangeGwtSerializationDependencies, com.google.common.base.Predicate[_Range__C], java.io.Serializable, typing.Generic[_Range__C]):
    """
    Java class 'com.google.common.collect.Range'
    
        Extends:
            com.google.common.collect.RangeGwtSerializationDependencies
    
        Interfaces:
            com.google.common.base.Predicate, java.io.Serializable
    
    """
    _all__C = typing.TypeVar('_all__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def all() -> 'Range'[_all__C]: ...
    def apply(self, c: _Range__C) -> bool: ...
    _atLeast__C = typing.TypeVar('_atLeast__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def atLeast(c: _atLeast__C) -> 'Range'[_atLeast__C]: ...
    _atMost__C = typing.TypeVar('_atMost__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def atMost(c: _atMost__C) -> 'Range'[_atMost__C]: ...
    def canonical(self, discreteDomain: DiscreteDomain[_Range__C]) -> 'Range'[_Range__C]: ...
    _closed__C = typing.TypeVar('_closed__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def closed(c: _closed__C, c2: _closed__C) -> 'Range'[_closed__C]: ...
    _closedOpen__C = typing.TypeVar('_closedOpen__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def closedOpen(c: _closedOpen__C, c2: _closedOpen__C) -> 'Range'[_closedOpen__C]: ...
    def contains(self, c: _Range__C) -> bool: ...
    def containsAll(self, iterable: java.lang.Iterable[_Range__C]) -> bool: ...
    _downTo__C = typing.TypeVar('_downTo__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def downTo(c: _downTo__C, boundType: BoundType) -> 'Range'[_downTo__C]: ...
    _encloseAll__C = typing.TypeVar('_encloseAll__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def encloseAll(iterable: java.lang.Iterable[_encloseAll__C]) -> 'Range'[_encloseAll__C]: ...
    def encloses(self, range: 'Range'[_Range__C]) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def gap(self, range: 'Range'[_Range__C]) -> 'Range'[_Range__C]: ...
    _greaterThan__C = typing.TypeVar('_greaterThan__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def greaterThan(c: _greaterThan__C) -> 'Range'[_greaterThan__C]: ...
    def hasLowerBound(self) -> bool: ...
    def hasUpperBound(self) -> bool: ...
    def hashCode(self) -> int: ...
    def intersection(self, range: 'Range'[_Range__C]) -> 'Range'[_Range__C]: ...
    def isConnected(self, range: 'Range'[_Range__C]) -> bool: ...
    def isEmpty(self) -> bool: ...
    _lessThan__C = typing.TypeVar('_lessThan__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def lessThan(c: _lessThan__C) -> 'Range'[_lessThan__C]: ...
    def lowerBoundType(self) -> BoundType: ...
    def lowerEndpoint(self) -> _Range__C: ...
    _open__C = typing.TypeVar('_open__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def open(c: _open__C, c2: _open__C) -> 'Range'[_open__C]: ...
    _openClosed__C = typing.TypeVar('_openClosed__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def openClosed(c: _openClosed__C, c2: _openClosed__C) -> 'Range'[_openClosed__C]: ...
    _range__C = typing.TypeVar('_range__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def range(c: _range__C, boundType: BoundType, c2: _range__C, boundType2: BoundType) -> 'Range'[_range__C]: ...
    _singleton__C = typing.TypeVar('_singleton__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def singleton(c: _singleton__C) -> 'Range'[_singleton__C]: ...
    def span(self, range: 'Range'[_Range__C]) -> 'Range'[_Range__C]: ...
    def toString(self) -> str: ...
    _upTo__C = typing.TypeVar('_upTo__C', bound=java.lang.Comparable)  # <C>
    @staticmethod
    def upTo(c: _upTo__C, boundType: BoundType) -> 'Range'[_upTo__C]: ...
    def upperBoundType(self) -> BoundType: ...
    def upperEndpoint(self) -> _Range__C: ...

_SortedMultiset__E = typing.TypeVar('_SortedMultiset__E')  # <E>
class SortedMultiset(com.google.common.collect.SortedMultisetBridge[_SortedMultiset__E], com.google.common.collect.SortedIterable[_SortedMultiset__E], typing.Generic[_SortedMultiset__E]):
    """
    Java class 'com.google.common.collect.SortedMultiset'
    
        Interfaces:
            com.google.common.collect.SortedMultisetBridge,
            com.google.common.collect.SortedIterable
    
    """
    def comparator(self) -> java.util.Comparator[_SortedMultiset__E]: ...
    def descendingMultiset(self) -> 'SortedMultiset'[_SortedMultiset__E]: ...
    def elementSet(self) -> java.util.NavigableSet[_SortedMultiset__E]: ...
    def entrySet(self) -> java.util.Set[Multiset.Entry[_SortedMultiset__E]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def firstEntry(self) -> Multiset.Entry[_SortedMultiset__E]: ...
    def hashCode(self) -> int: ...
    def headMultiset(self, e: _SortedMultiset__E, boundType: BoundType) -> 'SortedMultiset'[_SortedMultiset__E]: ...
    def iterator(self) -> java.util.Iterator[_SortedMultiset__E]: ...
    def lastEntry(self) -> Multiset.Entry[_SortedMultiset__E]: ...
    def pollFirstEntry(self) -> Multiset.Entry[_SortedMultiset__E]: ...
    def pollLastEntry(self) -> Multiset.Entry[_SortedMultiset__E]: ...
    def subMultiset(self, e: _SortedMultiset__E, boundType: BoundType, e2: _SortedMultiset__E, boundType2: BoundType) -> 'SortedMultiset'[_SortedMultiset__E]: ...
    def tailMultiset(self, e: _SortedMultiset__E, boundType: BoundType) -> 'SortedMultiset'[_SortedMultiset__E]: ...
    def toString(self) -> str: ...

_TreeBasedTable__R = typing.TypeVar('_TreeBasedTable__R')  # <R>
_TreeBasedTable__C = typing.TypeVar('_TreeBasedTable__C')  # <C>
_TreeBasedTable__V = typing.TypeVar('_TreeBasedTable__V')  # <V>
class TreeBasedTable(com.google.common.collect.StandardRowSortedTable[_TreeBasedTable__R, _TreeBasedTable__C, _TreeBasedTable__V], typing.Generic[_TreeBasedTable__R, _TreeBasedTable__C, _TreeBasedTable__V]):
    """
    Java class 'com.google.common.collect.TreeBasedTable'
    
        Extends:
            com.google.common.collect.StandardRowSortedTable
    
    """
    def columnComparator(self) -> java.util.Comparator[_TreeBasedTable__C]: ...
    _create_0__R = typing.TypeVar('_create_0__R', bound=java.lang.Comparable)  # <R>
    _create_0__C = typing.TypeVar('_create_0__C', bound=java.lang.Comparable)  # <C>
    _create_0__V = typing.TypeVar('_create_0__V')  # <V>
    _create_1__R = typing.TypeVar('_create_1__R')  # <R>
    _create_1__C = typing.TypeVar('_create_1__C')  # <C>
    _create_1__V = typing.TypeVar('_create_1__V')  # <V>
    _create_2__R = typing.TypeVar('_create_2__R')  # <R>
    _create_2__C = typing.TypeVar('_create_2__C')  # <C>
    _create_2__V = typing.TypeVar('_create_2__V')  # <V>
    @typing.overload
    @staticmethod
    def create() -> 'TreeBasedTable'[_create_0__R, _create_0__C, _create_0__V]: ...
    @typing.overload
    @staticmethod
    def create(treeBasedTable: 'TreeBasedTable'[_create_1__R, _create_1__C, _create_1__V]) -> 'TreeBasedTable'[_create_1__R, _create_1__C, _create_1__V]: ...
    @typing.overload
    @staticmethod
    def create(comparator: typing.Union[java.util.Comparator[_create_2__R], typing.Callable[[_create_2__R, _create_2__R], int]], comparator2: typing.Union[java.util.Comparator[_create_2__C], typing.Callable[[_create_2__C, _create_2__C], int]]) -> 'TreeBasedTable'[_create_2__R, _create_2__C, _create_2__V]: ...
    def row(self, r: _TreeBasedTable__R) -> java.util.SortedMap[_TreeBasedTable__C, _TreeBasedTable__V]: ...
    def rowComparator(self) -> java.util.Comparator[_TreeBasedTable__R]: ...
    def rowKeySet(self) -> java.util.SortedSet[_TreeBasedTable__R]: ...
    def rowMap(self) -> java.util.SortedMap[_TreeBasedTable__R, java.util.Map[_TreeBasedTable__C, _TreeBasedTable__V]]: ...

_TreeMultimap__K = typing.TypeVar('_TreeMultimap__K')  # <K>
_TreeMultimap__V = typing.TypeVar('_TreeMultimap__V')  # <V>
class TreeMultimap(com.google.common.collect.AbstractSortedKeySortedSetMultimap[_TreeMultimap__K, _TreeMultimap__V], typing.Generic[_TreeMultimap__K, _TreeMultimap__V]):
    """
    Java class 'com.google.common.collect.TreeMultimap'
    
        Extends:
            com.google.common.collect.AbstractSortedKeySortedSetMultimap
    
    """
    def asMap(self) -> java.util.NavigableMap[_TreeMultimap__K, java.util.Collection[_TreeMultimap__V]]: ...
    _create_0__K = typing.TypeVar('_create_0__K', bound=java.lang.Comparable)  # <K>
    _create_0__V = typing.TypeVar('_create_0__V', bound=java.lang.Comparable)  # <V>
    _create_1__K = typing.TypeVar('_create_1__K', bound=java.lang.Comparable)  # <K>
    _create_1__V = typing.TypeVar('_create_1__V', bound=java.lang.Comparable)  # <V>
    _create_2__K = typing.TypeVar('_create_2__K')  # <K>
    _create_2__V = typing.TypeVar('_create_2__V')  # <V>
    @typing.overload
    @staticmethod
    def create() -> 'TreeMultimap'[_create_0__K, _create_0__V]: ...
    @typing.overload
    @staticmethod
    def create(multimap: Multimap[_create_1__K, _create_1__V]) -> 'TreeMultimap'[_create_1__K, _create_1__V]: ...
    @typing.overload
    @staticmethod
    def create(comparator: typing.Union[java.util.Comparator[_create_2__K], typing.Callable[[_create_2__K, _create_2__K], int]], comparator2: typing.Union[java.util.Comparator[_create_2__V], typing.Callable[[_create_2__V, _create_2__V], int]]) -> 'TreeMultimap'[_create_2__K, _create_2__V]: ...
    def get(self, k: _TreeMultimap__K) -> java.util.NavigableSet[_TreeMultimap__V]: ...
    def keyComparator(self) -> java.util.Comparator[_TreeMultimap__K]: ...
    def keySet(self) -> java.util.NavigableSet[_TreeMultimap__K]: ...
    def valueComparator(self) -> java.util.Comparator[_TreeMultimap__V]: ...

_TreeMultiset__E = typing.TypeVar('_TreeMultiset__E')  # <E>
class TreeMultiset(com.google.common.collect.AbstractSortedMultiset[_TreeMultiset__E], java.io.Serializable, typing.Generic[_TreeMultiset__E]):
    """
    Java class 'com.google.common.collect.TreeMultiset'
    
        Extends:
            com.google.common.collect.AbstractSortedMultiset
    
        Interfaces:
            java.io.Serializable
    
    """
    @typing.overload
    def add(self, e: _TreeMultiset__E) -> bool: ...
    @typing.overload
    def add(self, e: _TreeMultiset__E, int: int) -> int: ...
    def clear(self) -> None: ...
    def count(self, object: typing.Any) -> int: ...
    _create_0__E = typing.TypeVar('_create_0__E', bound=java.lang.Comparable)  # <E>
    _create_1__E = typing.TypeVar('_create_1__E', bound=java.lang.Comparable)  # <E>
    _create_2__E = typing.TypeVar('_create_2__E')  # <E>
    @typing.overload
    @staticmethod
    def create() -> 'TreeMultiset'[_create_0__E]: ...
    @typing.overload
    @staticmethod
    def create(iterable: java.lang.Iterable[_create_1__E]) -> 'TreeMultiset'[_create_1__E]: ...
    @typing.overload
    @staticmethod
    def create(comparator: typing.Union[java.util.Comparator[_create_2__E], typing.Callable[[_create_2__E, _create_2__E], int]]) -> 'TreeMultiset'[_create_2__E]: ...
    def forEachEntry(self, objIntConsumer: typing.Union[java.util.function.ObjIntConsumer[_TreeMultiset__E], typing.Callable[[_TreeMultiset__E, int], None]]) -> None: ...
    def headMultiset(self, e: _TreeMultiset__E, boundType: BoundType) -> SortedMultiset[_TreeMultiset__E]: ...
    def iterator(self) -> java.util.Iterator[_TreeMultiset__E]: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any, int: int) -> int: ...
    @typing.overload
    def setCount(self, e: _TreeMultiset__E, int: int, int2: int) -> bool: ...
    @typing.overload
    def setCount(self, e: _TreeMultiset__E, int: int) -> int: ...
    def size(self) -> int: ...
    def tailMultiset(self, e: _TreeMultiset__E, boundType: BoundType) -> SortedMultiset[_TreeMultiset__E]: ...

_TreeRangeSet__C = typing.TypeVar('_TreeRangeSet__C', bound=java.lang.Comparable)  # <C>
class TreeRangeSet(com.google.common.collect.AbstractRangeSet[_TreeRangeSet__C], java.io.Serializable, typing.Generic[_TreeRangeSet__C]):
    """
    Java class 'com.google.common.collect.TreeRangeSet'
    
        Extends:
            com.google.common.collect.AbstractRangeSet
    
        Interfaces:
            java.io.Serializable
    
    """
    def add(self, range: Range[_TreeRangeSet__C]) -> None: ...
    def addAll(self, iterable: java.lang.Iterable[Range[_TreeRangeSet__C]]) -> None: ...
    def asDescendingSetOfRanges(self) -> java.util.Set[Range[_TreeRangeSet__C]]: ...
    def asRanges(self) -> java.util.Set[Range[_TreeRangeSet__C]]: ...
    def complement(self) -> RangeSet[_TreeRangeSet__C]: ...
    _create_0__C = typing.TypeVar('_create_0__C', bound=java.lang.Comparable)  # <C>
    _create_1__C = typing.TypeVar('_create_1__C', bound=java.lang.Comparable)  # <C>
    _create_2__C = typing.TypeVar('_create_2__C', bound=java.lang.Comparable)  # <C>
    @typing.overload
    @staticmethod
    def create() -> 'TreeRangeSet'[_create_0__C]: ...
    @typing.overload
    @staticmethod
    def create(rangeSet: RangeSet[_create_1__C]) -> 'TreeRangeSet'[_create_1__C]: ...
    @typing.overload
    @staticmethod
    def create(iterable: java.lang.Iterable[Range[_create_2__C]]) -> 'TreeRangeSet'[_create_2__C]: ...
    def encloses(self, range: Range[_TreeRangeSet__C]) -> bool: ...
    def enclosesAll(self, iterable: java.lang.Iterable[Range[_TreeRangeSet__C]]) -> bool: ...
    def intersects(self, range: Range[_TreeRangeSet__C]) -> bool: ...
    def rangeContaining(self, c: _TreeRangeSet__C) -> Range[_TreeRangeSet__C]: ...
    def remove(self, range: Range[_TreeRangeSet__C]) -> None: ...
    def removeAll(self, iterable: java.lang.Iterable[Range[_TreeRangeSet__C]]) -> None: ...
    def span(self) -> Range[_TreeRangeSet__C]: ...
    def subRangeSet(self, range: Range[_TreeRangeSet__C]) -> RangeSet[_TreeRangeSet__C]: ...

class AbstractBiMap: ...

class AbstractMapBasedMultiset: ...

class AbstractMultimap: ...

class AbstractMultiset: ...

class AbstractRangeSet: ...

class AbstractSortedKeySortedSetMultimap: ...

class AbstractSortedMultiset: ...

class AbstractTable: ...

class ArrayListMultimapGwtSerializationDependencies: ...

class BaseImmutableMultimap: ...

class HashMultimapGwtSerializationDependencies: ...

class ImmutableBiMapFauxverideShim: ...

class ImmutableMultisetGwtSerializationDependencies: ...

class ImmutableSortedMapFauxverideShim: ...

class ImmutableSortedMultisetFauxverideShim: ...

class ImmutableSortedSetFauxverideShim: ...

class LinkedHashMultimapGwtSerializationDependencies: ...

class RangeGwtSerializationDependencies: ...

class SortedIterable: ...

class SortedMultisetBridge: ...

class StandardRowSortedTable: ...

class StandardTable: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("com.google.common.collect")``.

    AbstractBiMap: typing.Type[AbstractBiMap]
    AbstractIterator: typing.Type[AbstractIterator]
    AbstractMapBasedMultiset: typing.Type[AbstractMapBasedMultiset]
    AbstractMultimap: typing.Type[AbstractMultimap]
    AbstractMultiset: typing.Type[AbstractMultiset]
    AbstractRangeSet: typing.Type[AbstractRangeSet]
    AbstractSequentialIterator: typing.Type[AbstractSequentialIterator]
    AbstractSortedKeySortedSetMultimap: typing.Type[AbstractSortedKeySortedSetMultimap]
    AbstractSortedMultiset: typing.Type[AbstractSortedMultiset]
    AbstractTable: typing.Type[AbstractTable]
    ArrayListMultimap: typing.Type[ArrayListMultimap]
    ArrayListMultimapGwtSerializationDependencies: typing.Type[ArrayListMultimapGwtSerializationDependencies]
    ArrayTable: typing.Type[ArrayTable]
    BaseImmutableMultimap: typing.Type[BaseImmutableMultimap]
    BiMap: typing.Type[BiMap]
    BoundType: typing.Type[BoundType]
    ClassToInstanceMap: typing.Type[ClassToInstanceMap]
    Collections2: typing.Type[Collections2]
    Comparators: typing.Type[Comparators]
    ComparisonChain: typing.Type[ComparisonChain]
    ComputationException: typing.Type[ComputationException]
    ConcurrentHashMultiset: typing.Type[ConcurrentHashMultiset]
    ContiguousSet: typing.Type[ContiguousSet]
    DiscreteDomain: typing.Type[DiscreteDomain]
    EnumBiMap: typing.Type[EnumBiMap]
    EnumHashBiMap: typing.Type[EnumHashBiMap]
    EnumMultiset: typing.Type[EnumMultiset]
    EvictingQueue: typing.Type[EvictingQueue]
    FluentIterable: typing.Type[FluentIterable]
    ForwardingBlockingDeque: typing.Type[ForwardingBlockingDeque]
    ForwardingCollection: typing.Type[ForwardingCollection]
    ForwardingConcurrentMap: typing.Type[ForwardingConcurrentMap]
    ForwardingDeque: typing.Type[ForwardingDeque]
    ForwardingIterator: typing.Type[ForwardingIterator]
    ForwardingList: typing.Type[ForwardingList]
    ForwardingListIterator: typing.Type[ForwardingListIterator]
    ForwardingListMultimap: typing.Type[ForwardingListMultimap]
    ForwardingMap: typing.Type[ForwardingMap]
    ForwardingMapEntry: typing.Type[ForwardingMapEntry]
    ForwardingMultimap: typing.Type[ForwardingMultimap]
    ForwardingMultiset: typing.Type[ForwardingMultiset]
    ForwardingNavigableMap: typing.Type[ForwardingNavigableMap]
    ForwardingNavigableSet: typing.Type[ForwardingNavigableSet]
    ForwardingObject: typing.Type[ForwardingObject]
    ForwardingQueue: typing.Type[ForwardingQueue]
    ForwardingSet: typing.Type[ForwardingSet]
    ForwardingSetMultimap: typing.Type[ForwardingSetMultimap]
    ForwardingSortedMap: typing.Type[ForwardingSortedMap]
    ForwardingSortedMultiset: typing.Type[ForwardingSortedMultiset]
    ForwardingSortedSet: typing.Type[ForwardingSortedSet]
    ForwardingSortedSetMultimap: typing.Type[ForwardingSortedSetMultimap]
    ForwardingTable: typing.Type[ForwardingTable]
    HashBasedTable: typing.Type[HashBasedTable]
    HashBiMap: typing.Type[HashBiMap]
    HashMultimap: typing.Type[HashMultimap]
    HashMultimapGwtSerializationDependencies: typing.Type[HashMultimapGwtSerializationDependencies]
    HashMultiset: typing.Type[HashMultiset]
    ImmutableBiMap: typing.Type[ImmutableBiMap]
    ImmutableBiMapFauxverideShim: typing.Type[ImmutableBiMapFauxverideShim]
    ImmutableClassToInstanceMap: typing.Type[ImmutableClassToInstanceMap]
    ImmutableCollection: typing.Type[ImmutableCollection]
    ImmutableList: typing.Type[ImmutableList]
    ImmutableListMultimap: typing.Type[ImmutableListMultimap]
    ImmutableMap: typing.Type[ImmutableMap]
    ImmutableMultimap: typing.Type[ImmutableMultimap]
    ImmutableMultiset: typing.Type[ImmutableMultiset]
    ImmutableMultisetGwtSerializationDependencies: typing.Type[ImmutableMultisetGwtSerializationDependencies]
    ImmutableRangeMap: typing.Type[ImmutableRangeMap]
    ImmutableRangeSet: typing.Type[ImmutableRangeSet]
    ImmutableSet: typing.Type[ImmutableSet]
    ImmutableSetMultimap: typing.Type[ImmutableSetMultimap]
    ImmutableSortedMap: typing.Type[ImmutableSortedMap]
    ImmutableSortedMapFauxverideShim: typing.Type[ImmutableSortedMapFauxverideShim]
    ImmutableSortedMultiset: typing.Type[ImmutableSortedMultiset]
    ImmutableSortedMultisetFauxverideShim: typing.Type[ImmutableSortedMultisetFauxverideShim]
    ImmutableSortedSet: typing.Type[ImmutableSortedSet]
    ImmutableSortedSetFauxverideShim: typing.Type[ImmutableSortedSetFauxverideShim]
    ImmutableTable: typing.Type[ImmutableTable]
    Interner: typing.Type[Interner]
    Interners: typing.Type[Interners]
    Iterables: typing.Type[Iterables]
    Iterators: typing.Type[Iterators]
    LinkedHashMultimap: typing.Type[LinkedHashMultimap]
    LinkedHashMultimapGwtSerializationDependencies: typing.Type[LinkedHashMultimapGwtSerializationDependencies]
    LinkedHashMultiset: typing.Type[LinkedHashMultiset]
    LinkedListMultimap: typing.Type[LinkedListMultimap]
    ListMultimap: typing.Type[ListMultimap]
    Lists: typing.Type[Lists]
    MapDifference: typing.Type[MapDifference]
    MapMaker: typing.Type[MapMaker]
    Maps: typing.Type[Maps]
    MinMaxPriorityQueue: typing.Type[MinMaxPriorityQueue]
    MoreCollectors: typing.Type[MoreCollectors]
    Multimap: typing.Type[Multimap]
    MultimapBuilder: typing.Type[MultimapBuilder]
    Multimaps: typing.Type[Multimaps]
    Multiset: typing.Type[Multiset]
    Multisets: typing.Type[Multisets]
    MutableClassToInstanceMap: typing.Type[MutableClassToInstanceMap]
    ObjectArrays: typing.Type[ObjectArrays]
    Ordering: typing.Type[Ordering]
    PeekingIterator: typing.Type[PeekingIterator]
    Queues: typing.Type[Queues]
    Range: typing.Type[Range]
    RangeGwtSerializationDependencies: typing.Type[RangeGwtSerializationDependencies]
    RangeMap: typing.Type[RangeMap]
    RangeSet: typing.Type[RangeSet]
    RowSortedTable: typing.Type[RowSortedTable]
    SetMultimap: typing.Type[SetMultimap]
    Sets: typing.Type[Sets]
    SortedIterable: typing.Type[SortedIterable]
    SortedMapDifference: typing.Type[SortedMapDifference]
    SortedMultiset: typing.Type[SortedMultiset]
    SortedMultisetBridge: typing.Type[SortedMultisetBridge]
    SortedSetMultimap: typing.Type[SortedSetMultimap]
    StandardRowSortedTable: typing.Type[StandardRowSortedTable]
    StandardTable: typing.Type[StandardTable]
    Streams: typing.Type[Streams]
    Table: typing.Type[Table]
    Tables: typing.Type[Tables]
    TreeBasedTable: typing.Type[TreeBasedTable]
    TreeMultimap: typing.Type[TreeMultimap]
    TreeMultiset: typing.Type[TreeMultiset]
    TreeRangeMap: typing.Type[TreeRangeMap]
    TreeRangeSet: typing.Type[TreeRangeSet]
    TreeTraverser: typing.Type[TreeTraverser]
    UnmodifiableIterator: typing.Type[UnmodifiableIterator]
    UnmodifiableListIterator: typing.Type[UnmodifiableListIterator]
