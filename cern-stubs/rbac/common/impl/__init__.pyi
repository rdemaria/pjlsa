import cern.rbac.common
import cern.rbac.common.authorization
import cern.rbac.common.impl.exec_
import java.lang
import java.net
import java.nio.charset
import java.security
import typing


class AppPrincipalImpl(cern.rbac.common.AppPrincipal, java.lang.Cloneable):
    def __init__(self, string: str, boolean: bool, integer: int): ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getName(self) -> str: ...
    def getTimeout(self) -> int: ...
    def hashCode(self) -> int: ...
    def isCritical(self) -> bool: ...
    def toString(self) -> str: ...

class LocationPrincipalImpl(cern.rbac.common.LocationPrincipal, java.lang.Cloneable):
    @typing.overload
    def __init__(self, string: str, string2: str, boolean: bool): ...
    @typing.overload
    def __init__(self, string: str, inetAddress: java.net.InetAddress, boolean: bool): ...
    @typing.overload
    def __init__(self, string: str, inetAddress: java.net.InetAddress, boolean: bool, string2: str): ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAddress(self) -> java.net.InetAddress: ...
    def getDefaultUser(self) -> str: ...
    def getName(self) -> str: ...
    def hashCode(self) -> int: ...
    def isAuthRequired(self) -> bool: ...
    def toString(self) -> str: ...

class RbaConstants:
    VERSION: typing.ClassVar[str] = ...
    DEFAULT_ENCODING: typing.ClassVar[java.nio.charset.Charset] = ...
    SIGNATURE_ALGORITHM: typing.ClassVar[str] = ...
    KEY_ALGORITHM: typing.ClassVar[str] = ...
    KEY_SIZE: typing.ClassVar[int] = ...
    UNDEFINED_TOKEN_LIFETIME: typing.ClassVar[int] = ...
    DEFAULT_TOKEN_LIFETIME: typing.ClassVar[int] = ...
    DEFAULT_READ_TIMEOUT: typing.ClassVar[int] = ...
    CRITICAL_ROLE_PREFIX: typing.ClassVar[str] = ...
    AUTHORIZATION_SCHEME: typing.ClassVar[str] = ...
    AUTHORIZATION_HEADER: typing.ClassVar[str] = ...

class RoleImpl(cern.rbac.common.Role, java.lang.Cloneable, java.lang.Comparable['RoleImpl']):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, int: int): ...
    def clone(self) -> typing.Any: ...
    def compareTo(self, roleImpl: 'RoleImpl') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getLifetime(self) -> int: ...
    def getName(self) -> str: ...
    def hashCode(self) -> int: ...
    def isCritical(self) -> bool: ...
    def isLifetimeDefined(self) -> bool: ...
    def toString(self) -> str: ...

class ServiceLocator:
    @staticmethod
    def getExecutionService() -> cern.rbac.common.impl.exec_.ExecutionService: ...

class UserPrincipalImpl(cern.rbac.common.UserPrincipal, java.lang.Cloneable):
    def __init__(self, string: str, string2: str, string3: str, roleArray: typing.List[cern.rbac.common.Role], accountType: cern.rbac.common.UserPrincipal.AccountType): ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAccountType(self) -> cern.rbac.common.UserPrincipal.AccountType: ...
    def getEmail(self) -> str: ...
    def getFullName(self) -> str: ...
    def getName(self) -> str: ...
    def getRoles(self) -> typing.List[cern.rbac.common.Role]: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class McsRoleImpl(RoleImpl, cern.rbac.common.authorization.McsRole):
    def __init__(self, string: str, publicKey: java.security.PublicKey): ...
    def getPublicKey(self) -> java.security.PublicKey: ...
