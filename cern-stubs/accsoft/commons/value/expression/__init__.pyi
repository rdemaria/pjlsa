import cern.accsoft.commons.value
import cern.accsoft.commons.value.operation
import cern.accsoft.commons.value.operation.factory
import java.lang
import java.util
import typing


class Expression:
    def evaluate(self, valueMap: 'ValueMap') -> cern.accsoft.commons.value.Value: ...
    def getVariableNames(self) -> java.util.List[str]: ...

class ExpressionParser:
    ADDITION_OPERATOR: typing.ClassVar[str] = ...
    SUBTRACTION_OPERATOR: typing.ClassVar[str] = ...
    MULTIPLICATION_OPERATOR: typing.ClassVar[str] = ...
    DIVISION_OPERATOR: typing.ClassVar[str] = ...
    EXPONENTIATION_OPERATOR: typing.ClassVar[str] = ...
    UNARY_NEGATION_OPERATOR: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, operationFactory: cern.accsoft.commons.value.operation.factory.OperationFactory): ...
    @typing.overload
    def parse(self) -> Expression: ...
    @typing.overload
    @staticmethod
    def parse(string: str) -> Expression: ...

class ExpressionSyntaxException(java.lang.Exception):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class ValueMap:
    @typing.overload
    def get(self, string: str) -> cern.accsoft.commons.value.ImmutableValue: ...
    @typing.overload
    def get(self, string: str, int: int) -> cern.accsoft.commons.value.ImmutableValue: ...

class BinaryOperationExpression(Expression):
    def __init__(self, binaryOperation: cern.accsoft.commons.value.operation.BinaryOperation, expression: Expression, expression2: Expression): ...
    def evaluate(self, valueMap: ValueMap) -> cern.accsoft.commons.value.Value: ...
    def getVariableNames(self) -> java.util.List[str]: ...
    def toString(self) -> str: ...

class BooleanConstantExpression(Expression):
    @typing.overload
    def __init__(self, boolean: bool): ...
    @typing.overload
    def __init__(self, string: str): ...
    def evaluate(self, valueMap: ValueMap) -> cern.accsoft.commons.value.Value: ...
    def getVariableNames(self) -> java.util.List[str]: ...
    def toString(self) -> str: ...

class ConstantExpression(Expression):
    def __init__(self, double: float): ...
    def evaluate(self, valueMap: ValueMap) -> cern.accsoft.commons.value.Value: ...
    def getVariableNames(self) -> java.util.List[str]: ...
    def toString(self) -> str: ...

class FunctionBasedOperationExpression(Expression):
    def __init__(self, multiOperation: cern.accsoft.commons.value.operation.MultiOperation, list: java.util.List[Expression]): ...
    def evaluate(self, valueMap: ValueMap) -> cern.accsoft.commons.value.Value: ...
    def getVariableNames(self) -> java.util.List[str]: ...
    def toString(self) -> str: ...

class UnaryOperationExpression(Expression):
    @typing.overload
    def __init__(self, mathFunction: cern.accsoft.commons.value.MathFunction, expression: Expression): ...
    @typing.overload
    def __init__(self, unaryOperation: cern.accsoft.commons.value.operation.UnaryOperation, expression: Expression): ...
    def evaluate(self, valueMap: ValueMap) -> cern.accsoft.commons.value.Value: ...
    def getVariableNames(self) -> java.util.List[str]: ...
    def toString(self) -> str: ...

class ValueMapAdapter(ValueMap):
    def __init__(self): ...
    @typing.overload
    def get(self, string: str) -> cern.accsoft.commons.value.ImmutableValue: ...
    @typing.overload
    def get(self, string: str, int: int) -> cern.accsoft.commons.value.ImmutableValue: ...

class VectorExpression(Expression):
    def __init__(self, list: java.util.List[Expression]): ...
    def evaluate(self, valueMap: ValueMap) -> cern.accsoft.commons.value.Value: ...
    def getVariableNames(self) -> java.util.List[str]: ...
    def toString(self) -> str: ...
