import cern.accsoft.commons.util
import cern.accsoft.commons.util.value
import cern.accsoft.commons.value.expression
import cern.accsoft.commons.value.operation
import cern.accsoft.commons.value.spi.function
import cern.accsoft.commons.value.spi.operation
import cern.japc.value
import java.io
import java.lang
import java.util
import typing


class BoundedPolynomials:
    @typing.overload
    @staticmethod
    def createBoundedPolynomialSequence(boundedPolynomialArray: typing.List['BoundedPolynomial']) -> 'BoundedPolynomialSequence': ...
    @typing.overload
    @staticmethod
    def createBoundedPolynomialSequence(collection: typing.Union[java.util.Collection['BoundedPolynomial'], typing.Sequence['BoundedPolynomial']]) -> 'BoundedPolynomialSequence': ...
    @staticmethod
    def createLinearBoundedPolynomialSequence(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> 'BoundedPolynomialSequence': ...
    @typing.overload
    @staticmethod
    def forAbsoluteBoundedPolynomial(polynomial: 'Polynomial', interval: 'Interval') -> 'BoundedPolynomial': ...
    @typing.overload
    @staticmethod
    def forAbsoluteBoundedPolynomial(polynomial: 'Polynomial', double: float, double2: float) -> 'BoundedPolynomial': ...
    @typing.overload
    @staticmethod
    def forRelativeBoundedPolynomial(polynomial: 'Polynomial', interval: 'Interval') -> 'BoundedPolynomial': ...
    @typing.overload
    @staticmethod
    def forRelativeBoundedPolynomial(polynomial: 'Polynomial', double: float, double2: float) -> 'BoundedPolynomial': ...
    @typing.overload
    @staticmethod
    def getIntervals(boundedPolynomialSequence: 'BoundedPolynomialSequence') -> typing.List['Interval']: ...
    @typing.overload
    @staticmethod
    def getIntervals(boundedPolynomialArray: typing.List['BoundedPolynomial']) -> typing.List['Interval']: ...
    @typing.overload
    @staticmethod
    def getLength(boundedPolynomial: 'BoundedPolynomial') -> float: ...
    @typing.overload
    @staticmethod
    def getLength(boundedPolynomialSequence: 'BoundedPolynomialSequence') -> float: ...
    @staticmethod
    def isContinue(boundedPolynomialSequence: 'BoundedPolynomialSequence', boundedPolynomialSequence2: 'BoundedPolynomialSequence') -> bool: ...
    @staticmethod
    def isContinueWith(boundedPolynomialSequence: 'BoundedPolynomialSequence', boundedPolynomialSequence2: 'BoundedPolynomialSequence', double: float) -> bool: ...
    @staticmethod
    def toAbsolutePolynomial(boundedPolynomial: 'BoundedPolynomial') -> 'Polynomial': ...
    @staticmethod
    def toAbsolutePolynomials(boundedPolynomialSequence: 'BoundedPolynomialSequence') -> typing.List['Polynomial']: ...
    @typing.overload
    @staticmethod
    def toDiscreteFunction(boundedPolynomialSequence: 'BoundedPolynomialSequence') -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def toDiscreteFunction(boundedPolynomialSequence: 'BoundedPolynomialSequence', double: float) -> 'DiscreteFunction': ...
    @staticmethod
    def toRelativePolynomial(boundedPolynomial: 'BoundedPolynomial') -> 'Polynomial': ...
    @staticmethod
    def toRelativePolynomials(boundedPolynomialSequence: 'BoundedPolynomialSequence') -> typing.List['Polynomial']: ...

class DiscreteFunctionCompressor:
    @typing.overload
    def __init__(self, discreteFunction: 'DiscreteFunction', int: int): ...
    @typing.overload
    def __init__(self, discreteFunction: 'DiscreteFunction', int: int, int2: int, int3: int, int4: int, float: float): ...
    def compressFunction(self) -> 'DiscreteFunction': ...

class DiscreteFunctions:
    DEFAULT_SHIFT_COMPENSATION_FACTOR: typing.ClassVar[float] = ...
    @staticmethod
    def align(discreteFunction: 'DiscreteFunction', int: int, int2: int) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def buildDiscreteFunctionList(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> cern.japc.value.DiscreteFunctionList: ...
    @typing.overload
    @staticmethod
    def buildDiscreteFunctionList(doubleArray: typing.List[float], doubleArray2: typing.List[float], intArray: typing.List[int]) -> cern.japc.value.DiscreteFunctionList: ...
    @typing.overload
    @staticmethod
    def compare(immutableDiscreteFunction: 'ImmutableDiscreteFunction', immutableDiscreteFunction2: 'ImmutableDiscreteFunction') -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def compare(immutableDiscreteFunction: 'ImmutableDiscreteFunction', immutableDiscreteFunction2: 'ImmutableDiscreteFunction', double: float) -> 'DiscreteFunction': ...
    @staticmethod
    def computeDerivative(immutableDiscreteFunction: 'ImmutableDiscreteFunction', approximationMode: 'DiscreteFunctions.ApproximationMode') -> 'DiscreteFunction': ...
    @staticmethod
    def computeIntegral(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> float: ...
    @staticmethod
    def computeTotalSize(discreteFunctionList: cern.japc.value.DiscreteFunctionList) -> int: ...
    @staticmethod
    def concat(immutableDiscreteFunction: 'ImmutableDiscreteFunction', immutableDiscreteFunction2: 'ImmutableDiscreteFunction') -> 'DiscreteFunction': ...
    @staticmethod
    def containsNaN(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> bool: ...
    @staticmethod
    def convertFromJAPCFunction(discreteFunction: cern.japc.value.DiscreteFunction) -> 'ImmutableDiscreteFunction': ...
    @staticmethod
    def convertFromJAPCFunctionList(discreteFunctionList: cern.japc.value.DiscreteFunctionList) -> 'ImmutableDiscreteFunctionList': ...
    @staticmethod
    def convertToJAPCFunction(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> cern.japc.value.DiscreteFunction: ...
    @staticmethod
    def convertToJAPCFunctionList(immutableDiscreteFunctionList: 'ImmutableDiscreteFunctionList') -> cern.japc.value.DiscreteFunctionList: ...
    @staticmethod
    def createConstantDiscreteFunction(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def dx(immutableDiscreteFunction: 'ImmutableDiscreteFunction', int: int) -> float: ...
    @typing.overload
    @staticmethod
    def dx(immutableDiscreteFunction: 'ImmutableDiscreteFunction', int: int, int2: int) -> float: ...
    @typing.overload
    @staticmethod
    def dy(immutableDiscreteFunction: 'ImmutableDiscreteFunction', int: int) -> float: ...
    @typing.overload
    @staticmethod
    def dy(immutableDiscreteFunction: 'ImmutableDiscreteFunction', int: int, int2: int) -> float: ...
    @typing.overload
    @staticmethod
    def extractXArray(immutableDiscreteFunctionList: 'ImmutableDiscreteFunctionList') -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def extractXArray(discreteFunctionList: cern.japc.value.DiscreteFunctionList) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def extractYArray(immutableDiscreteFunctionList: 'ImmutableDiscreteFunctionList') -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def extractYArray(discreteFunctionList: cern.japc.value.DiscreteFunctionList) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def filter(discreteFunction: 'DiscreteFunction', double: float) -> 'DiscreteFunctions.FilterResult': ...
    @typing.overload
    @staticmethod
    def filter(discreteFunction: 'DiscreteFunction', double: float, interval: 'Interval') -> 'DiscreteFunctions.FilterResult': ...
    @typing.overload
    @staticmethod
    def filterByXCoordinate(discreteFunction: 'DiscreteFunction', double: float) -> None: ...
    @typing.overload
    @staticmethod
    def filterByXCoordinate(discreteFunction: 'DiscreteFunction', double: float, double2: float) -> None: ...
    @staticmethod
    def filterFractionalXCoordinates(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> 'ImmutableDiscreteFunction': ...
    @typing.overload
    @staticmethod
    def filterRamerDouglasPeucker(discreteFunction: 'DiscreteFunction', double: float) -> 'DiscreteFunctions.FilterResult': ...
    @typing.overload
    @staticmethod
    def filterRamerDouglasPeucker(discreteFunction: 'DiscreteFunction', double: float, interval: 'Interval') -> 'DiscreteFunctions.FilterResult': ...
    @staticmethod
    def getAbsoluteFunction(discreteFunctionList: cern.japc.value.DiscreteFunctionList, int: int) -> cern.japc.value.DiscreteFunction: ...
    @staticmethod
    def getAllXforY(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> java.util.SortedSet[float]: ...
    @typing.overload
    @staticmethod
    def getAvailableConstantSpaceAtBeginning(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> float: ...
    @typing.overload
    @staticmethod
    def getAvailableConstantSpaceAtBeginning(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> float: ...
    @typing.overload
    @staticmethod
    def getAvailableConstantSpaceAtEnd(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> float: ...
    @typing.overload
    @staticmethod
    def getAvailableConstantSpaceAtEnd(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> float: ...
    @staticmethod
    def getSplitIndices(discreteFunctionList: cern.japc.value.DiscreteFunctionList) -> typing.List[int]: ...
    @staticmethod
    def getXforY(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> float: ...
    @typing.overload
    @staticmethod
    def hasSameLength(immutableDiscreteFunction: 'ImmutableDiscreteFunction', int: int) -> bool: ...
    @typing.overload
    @staticmethod
    def hasSameLength(immutableDiscreteFunctionsArray: 'ImmutableDiscreteFunctionsArray', int: int) -> bool: ...
    @staticmethod
    def inRange(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> bool: ...
    @staticmethod
    def indexOf(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float, double2: float) -> int: ...
    @staticmethod
    def integrate(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> 'DiscreteFunction': ...
    @staticmethod
    def interpolate(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> float: ...
    @typing.overload
    @staticmethod
    def isConstant(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> bool: ...
    @typing.overload
    @staticmethod
    def isConstant(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> bool: ...
    @typing.overload
    @staticmethod
    def isConstant(immutableDiscreteFunctionsArray: 'ImmutableDiscreteFunctionsArray') -> bool: ...
    @typing.overload
    @staticmethod
    def isConstant(immutableDiscreteFunctionsArray: 'ImmutableDiscreteFunctionsArray', double: float) -> bool: ...
    @typing.overload
    @staticmethod
    def isContinue(immutableDiscreteFunction: 'ImmutableDiscreteFunction', immutableDiscreteFunction2: 'ImmutableDiscreteFunction') -> bool: ...
    @typing.overload
    @staticmethod
    def isContinue(immutableDiscreteFunctionsArray: 'ImmutableDiscreteFunctionsArray', immutableDiscreteFunctionsArray2: 'ImmutableDiscreteFunctionsArray') -> bool: ...
    @typing.overload
    @staticmethod
    def isContinueWith(immutableDiscreteFunction: 'ImmutableDiscreteFunction', immutableDiscreteFunction2: 'ImmutableDiscreteFunction', double: float) -> bool: ...
    @typing.overload
    @staticmethod
    def isContinueWith(immutableDiscreteFunction: 'ImmutableDiscreteFunction', immutableDiscreteFunction2: 'ImmutableDiscreteFunction', double: float, double2: float) -> bool: ...
    @typing.overload
    @staticmethod
    def isEmpty(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> bool: ...
    @typing.overload
    @staticmethod
    def isEmpty(immutableDiscreteFunctionsArray: 'ImmutableDiscreteFunctionsArray') -> bool: ...
    @staticmethod
    def isMonotonic(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> bool: ...
    @staticmethod
    def isStriclyAscending(doubleArray: typing.List[float]) -> bool: ...
    @staticmethod
    def isStrictlyMonotonic(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> bool: ...
    @typing.overload
    @staticmethod
    def isZero(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> bool: ...
    @typing.overload
    @staticmethod
    def isZero(immutableDiscreteFunctionsArray: 'ImmutableDiscreteFunctionsArray') -> bool: ...
    @staticmethod
    def max(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> float: ...
    @staticmethod
    def maxCoordinates(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> cern.accsoft.commons.util.value.Pair[float, java.util.SortedSet[float]]: ...
    @staticmethod
    def min(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> float: ...
    @staticmethod
    def minCoordinates(immutableDiscreteFunction: 'ImmutableDiscreteFunction') -> cern.accsoft.commons.util.value.Pair[float, java.util.SortedSet[float]]: ...
    @staticmethod
    def normalizeByXCoordinates(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float, double2: float) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def reduceFunctionPoints(immutableDiscreteFunction: 'ImmutableDiscreteFunction', int: int) -> 'ImmutableDiscreteFunction': ...
    @typing.overload
    @staticmethod
    def reduceFunctionPoints(immutableDiscreteFunction: 'ImmutableDiscreteFunction', int: int, double: float) -> 'ImmutableDiscreteFunction': ...
    @typing.overload
    @staticmethod
    def shift(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> 'ImmutableDiscreteFunction': ...
    @typing.overload
    @staticmethod
    def shift(immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float, double2: float) -> 'ImmutableDiscreteFunction': ...
    @staticmethod
    def toArray(discreteFunctionList: cern.japc.value.DiscreteFunctionList) -> typing.List[cern.japc.value.DiscreteFunction]: ...
    @staticmethod
    def toXArray(discreteFunctionList: cern.japc.value.DiscreteFunctionList) -> typing.List[float]: ...
    @staticmethod
    def toYArray(discreteFunctionList: cern.japc.value.DiscreteFunctionList) -> typing.List[float]: ...
    class ApproximationMode(java.lang.Enum['DiscreteFunctions.ApproximationMode']):
        FORWARD: typing.ClassVar['DiscreteFunctions.ApproximationMode'] = ...
        BACKWARD: typing.ClassVar['DiscreteFunctions.ApproximationMode'] = ...
        CENTERED: typing.ClassVar['DiscreteFunctions.ApproximationMode'] = ...
        _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'DiscreteFunctions.ApproximationMode': ...
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
        @staticmethod
        def values() -> typing.List['DiscreteFunctions.ApproximationMode']: ...
    class FilterResult(java.lang.Enum['DiscreteFunctions.FilterResult']):
        FILTERED: typing.ClassVar['DiscreteFunctions.FilterResult'] = ...
        NOT_FILTERED: typing.ClassVar['DiscreteFunctions.FilterResult'] = ...
        ONLY_FLAT_TOPS: typing.ClassVar['DiscreteFunctions.FilterResult'] = ...
        _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'DiscreteFunctions.FilterResult': ...
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
        @staticmethod
        def values() -> typing.List['DiscreteFunctions.FilterResult']: ...

class FunctionOperationException(java.lang.RuntimeException):
    def __init__(self, string: str): ...

class Indexed:
    def execute(self, indexing: cern.accsoft.commons.value.spi.operation.Indexing) -> 'Scalar': ...

class Interpolable:
    def interpolate(self, double: float) -> float: ...

class Interval(java.io.Serializable):
    INFINITY: typing.ClassVar['Interval'] = ...
    BOUNDS_COMPARATOR: typing.ClassVar[java.util.Comparator] = ...
    def __init__(self, double: float, double2: float): ...
    def compareByBoundsTo(self, interval: 'Interval') -> int: ...
    def compareTo(self, interval: 'Interval') -> int: ...
    def contains(self, double: float) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    @staticmethod
    def gapIntervals(intervalArray: typing.List['Interval']) -> typing.List['Interval']: ...
    def getLength(self) -> float: ...
    def getLowerBound(self) -> float: ...
    def getUpperBound(self) -> float: ...
    def hashCode(self) -> int: ...
    def intersects(self, interval: 'Interval') -> bool: ...
    def isAdjacentTo(self, interval: 'Interval') -> bool: ...
    @staticmethod
    def of(double: float, double2: float) -> 'Interval': ...
    def overlaps(self, interval: 'Interval') -> bool: ...
    @staticmethod
    def span(intervalArray: typing.List['Interval']) -> 'Interval': ...
    def toString(self) -> str: ...

class Operations:
    @staticmethod
    def abs(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def absNoCopy(value: 'Value') -> None: ...
    @staticmethod
    def acos(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def acosNoCopy(value: 'Value') -> None: ...
    @typing.overload
    @staticmethod
    def add(immutableValue: 'ImmutableValue', immutableValue2: 'ImmutableValue') -> 'Value': ...
    @typing.overload
    @staticmethod
    def add(immutableValue: 'ImmutableValue', double: float) -> 'Value': ...
    @typing.overload
    @staticmethod
    def addNoCopy(value: 'Value', immutableValue: 'ImmutableValue') -> None: ...
    @typing.overload
    @staticmethod
    def addNoCopy(value: 'Value', double: float) -> None: ...
    @staticmethod
    def asin(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def asinNoCopy(value: 'Value') -> None: ...
    @staticmethod
    def atan(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def atanNoCopy(value: 'Value') -> None: ...
    @staticmethod
    def ceil(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def ceilNoCopy(value: 'Value') -> None: ...
    @staticmethod
    def cos(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def cosNoCopy(value: 'Value') -> None: ...
    @typing.overload
    @staticmethod
    def divide(immutableValue: 'ImmutableValue', immutableValue2: 'ImmutableValue') -> 'Value': ...
    @typing.overload
    @staticmethod
    def divide(immutableValue: 'ImmutableValue', double: float) -> 'Value': ...
    @typing.overload
    @staticmethod
    def divideNoCopy(value: 'Value', immutableValue: 'ImmutableValue') -> None: ...
    @typing.overload
    @staticmethod
    def divideNoCopy(value: 'Value', double: float) -> None: ...
    @staticmethod
    def floor(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def floorNoCopy(value: 'Value') -> None: ...
    @staticmethod
    def log(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def log10(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def log10NoCopy(value: 'Value') -> None: ...
    @staticmethod
    def logNoCopy(value: 'Value') -> None: ...
    @staticmethod
    def mathNoCopy(value: 'Value', string: str) -> None: ...
    @typing.overload
    @staticmethod
    def multiply(immutableValue: 'ImmutableValue', immutableValue2: 'ImmutableValue') -> 'Value': ...
    @typing.overload
    @staticmethod
    def multiply(immutableValue: 'ImmutableValue', double: float) -> 'Value': ...
    @typing.overload
    @staticmethod
    def multiplyNoCopy(value: 'Value', immutableValue: 'ImmutableValue') -> None: ...
    @typing.overload
    @staticmethod
    def multiplyNoCopy(value: 'Value', double: float) -> None: ...
    @staticmethod
    def pow2(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def pow2NoCopy(value: 'Value') -> None: ...
    @typing.overload
    @staticmethod
    def power(immutableValue: 'ImmutableValue', immutableValue2: 'ImmutableValue') -> 'Value': ...
    @typing.overload
    @staticmethod
    def power(immutableValue: 'ImmutableValue', double: float) -> 'Value': ...
    @typing.overload
    @staticmethod
    def powerNoCopy(value: 'Value', immutableValue: 'ImmutableValue') -> None: ...
    @typing.overload
    @staticmethod
    def powerNoCopy(value: 'Value', double: float) -> None: ...
    @staticmethod
    def rint(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def rintNoCopy(value: 'Value') -> None: ...
    @staticmethod
    def round(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def roundNoCopy(value: 'Value') -> None: ...
    @staticmethod
    def sin(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def sinNoCopy(value: 'Value') -> None: ...
    @staticmethod
    def sqrt(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def sqrtNoCopy(value: 'Value') -> None: ...
    @typing.overload
    @staticmethod
    def subtract(immutableValue: 'ImmutableValue', immutableValue2: 'ImmutableValue') -> 'Value': ...
    @typing.overload
    @staticmethod
    def subtract(immutableValue: 'ImmutableValue', double: float) -> 'Value': ...
    @typing.overload
    @staticmethod
    def subtractNoCopy(value: 'Value', immutableValue: 'ImmutableValue') -> None: ...
    @typing.overload
    @staticmethod
    def subtractNoCopy(value: 'Value', double: float) -> None: ...
    @staticmethod
    def tan(immutableValue: 'ImmutableValue') -> 'Value': ...
    @staticmethod
    def tanNoCopy(value: 'Value') -> None: ...

class ParabolicSplineFunction(cern.accsoft.commons.value.spi.function.AbstractMathFunction):
    def __init__(self, immutableDiscreteFunction: 'ImmutableDiscreteFunction'): ...
    def getFunction(self) -> 'ImmutableDiscreteFunction': ...
    def getSplineX(self, int: int) -> float: ...

class ScalarArrays:
    @staticmethod
    def isContinueWith(immutableScalarArray: 'ImmutableScalarArray', immutableScalarArray2: 'ImmutableScalarArray', double: float) -> bool: ...

class Type(java.lang.Enum['Type'], cern.accsoft.commons.util.Named):
    FUNCTION: typing.ClassVar['Type'] = ...
    POINT: typing.ClassVar['Type'] = ...
    EXPRESSION_BASED_FUNCTION: typing.ClassVar['Type'] = ...
    FUNCTION_LIST: typing.ClassVar['Type'] = ...
    FUNCTIONS_ARRAY: typing.ClassVar['Type'] = ...
    POLYNOMIAL: typing.ClassVar['Type'] = ...
    BOUNDED_POLYNOMIAL: typing.ClassVar['Type'] = ...
    BOUNDED_POLYNOMIAL_SEQUENCE: typing.ClassVar['Type'] = ...
    BOOLEAN: typing.ClassVar['Type'] = ...
    BYTE: typing.ClassVar['Type'] = ...
    DOUBLE: typing.ClassVar['Type'] = ...
    FLOAT: typing.ClassVar['Type'] = ...
    LONG: typing.ClassVar['Type'] = ...
    INT: typing.ClassVar['Type'] = ...
    SHORT: typing.ClassVar['Type'] = ...
    STRING: typing.ClassVar['Type'] = ...
    TEXT_DOCUMENT: typing.ClassVar['Type'] = ...
    BOOLEAN_ARRAY: typing.ClassVar['Type'] = ...
    BYTE_ARRAY: typing.ClassVar['Type'] = ...
    DOUBLE_ARRAY: typing.ClassVar['Type'] = ...
    FLOAT_ARRAY: typing.ClassVar['Type'] = ...
    INT_ARRAY: typing.ClassVar['Type'] = ...
    LONG_ARRAY: typing.ClassVar['Type'] = ...
    SHORT_ARRAY: typing.ClassVar['Type'] = ...
    STRING_ARRAY: typing.ClassVar['Type'] = ...
    BOOLEAN_ARRAY_2D: typing.ClassVar['Type'] = ...
    BYTE_ARRAY_2D: typing.ClassVar['Type'] = ...
    DOUBLE_ARRAY_2D: typing.ClassVar['Type'] = ...
    FLOAT_ARRAY_2D: typing.ClassVar['Type'] = ...
    INT_ARRAY_2D: typing.ClassVar['Type'] = ...
    LONG_ARRAY_2D: typing.ClassVar['Type'] = ...
    SHORT_ARRAY_2D: typing.ClassVar['Type'] = ...
    STRING_ARRAY_2D: typing.ClassVar['Type'] = ...
    ENUM: typing.ClassVar['Type'] = ...
    ENUM_ARRAY: typing.ClassVar['Type'] = ...
    ENUM_ARRAY_2D: typing.ClassVar['Type'] = ...
    ENUM_SET: typing.ClassVar['Type'] = ...
    ENUM_SET_ARRAY: typing.ClassVar['Type'] = ...
    ENUM_SET_ARRAY_2D: typing.ClassVar['Type'] = ...
    UNDEFINED: typing.ClassVar['Type'] = ...
    @staticmethod
    def convertEnumTypeToPrimitiveType(type: 'Type', enumType: cern.japc.value.EnumType) -> 'Type': ...
    @staticmethod
    def convertToArray2DType(type: 'Type') -> 'Type': ...
    @staticmethod
    def convertToArrayType(type: 'Type') -> 'Type': ...
    @staticmethod
    def convertToScalarType(type: 'Type') -> 'Type': ...
    def getName(self) -> str: ...
    @staticmethod
    def getObjectType(object: typing.Any) -> 'Type': ...
    def isArray(self) -> bool: ...
    def isArray2D(self) -> bool: ...
    @staticmethod
    def isBooleanType(type: 'Type') -> bool: ...
    def isDiscrete(self) -> bool: ...
    @staticmethod
    def isDiscreteType(type: 'Type') -> bool: ...
    def isEnum(self) -> bool: ...
    def isEnumSet(self) -> bool: ...
    @staticmethod
    def isEnumSetType(type: 'Type') -> bool: ...
    @staticmethod
    def isEnumType(type: 'Type') -> bool: ...
    def isEnumeric(self) -> bool: ...
    @staticmethod
    def isEnumericType(type: 'Type') -> bool: ...
    @staticmethod
    def isFloatingType(type: 'Type') -> bool: ...
    def isFunction(self) -> bool: ...
    def isFunctionList(self) -> bool: ...
    @staticmethod
    def isFunctionListType(type: 'Type') -> bool: ...
    @staticmethod
    def isFunctionType(type: 'Type') -> bool: ...
    def isFunctionsArray(self) -> bool: ...
    @staticmethod
    def isFunctionsArrayType(type: 'Type') -> bool: ...
    @staticmethod
    def isNumberArray2DType(type: 'Type') -> bool: ...
    @staticmethod
    def isNumberArrayType(type: 'Type') -> bool: ...
    @staticmethod
    def isNumberType(type: 'Type') -> bool: ...
    def isScalar(self) -> bool: ...
    @staticmethod
    def isScalarArray2DType(type: 'Type') -> bool: ...
    @staticmethod
    def isScalarArrayType(type: 'Type') -> bool: ...
    @staticmethod
    def isScalarType(type: 'Type') -> bool: ...
    @staticmethod
    def isStringType(type: 'Type') -> bool: ...
    _valueOf_2__T = typing.TypeVar('_valueOf_2__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(valueType: cern.japc.value.ValueType) -> 'Type': ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Type': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_2__T], string: str) -> _valueOf_2__T: ...
    @staticmethod
    def values() -> typing.List['Type']: ...

class Typed:
    def getType(self) -> Type: ...

class ValueDescriptor(java.io.Serializable, java.lang.Cloneable):
    def clone(self) -> 'ValueDescriptor': ...
    def containsMeanings(self) -> bool: ...
    def getAbsoluteTolerance(self) -> float: ...
    def getBooleanType(self) -> cern.japc.value.BooleanType: ...
    def getColumnCount(self) -> int: ...
    def getEnumType(self) -> cern.japc.value.EnumType: ...
    def getMax(self) -> float: ...
    def getMeaning(self, object: typing.Any) -> cern.japc.value.SimpleValueStandardMeaning: ...
    def getMin(self) -> float: ...
    def getRelativeTolerance(self) -> float: ...
    def getRowCount(self) -> int: ...
    def getXPrecision(self) -> int: ...
    def getXUnit(self) -> str: ...
    def getYPrecision(self) -> int: ...
    def getYUnit(self) -> str: ...
    def isSettable(self, object: typing.Any) -> bool: ...
    class ValueCompareType(java.lang.Enum['ValueDescriptor.ValueCompareType']):
        EXACT_MEANING: typing.ClassVar['ValueDescriptor.ValueCompareType'] = ...
        TOL_REL: typing.ClassVar['ValueDescriptor.ValueCompareType'] = ...
        TOL_ABS: typing.ClassVar['ValueDescriptor.ValueCompareType'] = ...
        EXACT_WITH_RES: typing.ClassVar['ValueDescriptor.ValueCompareType'] = ...
        EXACT: typing.ClassVar['ValueDescriptor.ValueCompareType'] = ...
        TOL_ABS_REL: typing.ClassVar['ValueDescriptor.ValueCompareType'] = ...
        TOL_ABS_MOD360: typing.ClassVar['ValueDescriptor.ValueCompareType'] = ...
        NONE: typing.ClassVar['ValueDescriptor.ValueCompareType'] = ...
        _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'ValueDescriptor.ValueCompareType': ...
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
        @staticmethod
        def values() -> typing.List['ValueDescriptor.ValueCompareType']: ...

class ValueFactory:
    @staticmethod
    def convertToDiscreteFunction(immutableScalarArray: 'ImmutableScalarArray') -> 'DiscreteFunction': ...
    @staticmethod
    def createConstantFunction(double: float, double2: float) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def createDiscreteFunctionList() -> 'DiscreteFunctionList': ...
    @typing.overload
    @staticmethod
    def createDiscreteFunctionList(immutableDiscreteFunctionArray: typing.List['ImmutableDiscreteFunction']) -> 'DiscreteFunctionList': ...
    @typing.overload
    @staticmethod
    def createDiscreteFunctionList(doubleArray: typing.List[float], doubleArray2: typing.List[float], intArray: typing.List[int]) -> 'DiscreteFunctionList': ...
    @typing.overload
    @staticmethod
    def createDiscreteFunctionsArray() -> 'DiscreteFunctionsArray': ...
    @typing.overload
    @staticmethod
    def createDiscreteFunctionsArray(immutableDiscreteFunctionArray: typing.List['ImmutableDiscreteFunction']) -> 'DiscreteFunctionsArray': ...
    @typing.overload
    @staticmethod
    def createFunction(immutablePointArray: typing.List['ImmutablePoint']) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def createFunction(immutableValue: 'ImmutableValue') -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def createFunction(interpolable: Interpolable, double: float, int2: int, double2: float, double3: float) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def createFunction(interpolable: Interpolable, doubleArray: typing.List[float]) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def createFunction(interpolable: Interpolable, int2: int, double: float, double2: float) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def createFunction(interpolable: Interpolable, double: float, int2: int, double2: float, double3: float, integer: int, double4: float, double5: float) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def createFunction(pointArray: typing.List['Point']) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def createFunction(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def createFunction(doubleArray: typing.List[float], doubleArray2: typing.List[float], boolean: bool) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def createFunction(intArray: typing.List[int], doubleArray: typing.List[float]) -> 'DiscreteFunction': ...
    @typing.overload
    @staticmethod
    def createFunction(string: str) -> cern.accsoft.commons.value.spi.function.ExpressionBasedFunction: ...
    @staticmethod
    def createLinearBoundedPolynomialSequence(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> 'BoundedPolynomialSequence': ...
    @typing.overload
    @staticmethod
    def createMonomial(int: int) -> 'Polynomial': ...
    @typing.overload
    @staticmethod
    def createMonomial(int: int, double: float) -> 'Polynomial': ...
    @typing.overload
    @staticmethod
    def createPoint(immutableValue: 'ImmutableValue') -> 'Point': ...
    @typing.overload
    @staticmethod
    def createPoint(double: float, double2: float) -> 'Point': ...
    @typing.overload
    @staticmethod
    def createPolynomial(doubleArray: typing.List[float]) -> 'Polynomial': ...
    @typing.overload
    @staticmethod
    def createPolynomial(collection: typing.Union[java.util.Collection[float], typing.Sequence[float]]) -> 'Polynomial': ...
    @typing.overload
    @staticmethod
    def createPolynomial(sortedMap: java.util.SortedMap[int, float]) -> 'Polynomial': ...
    @typing.overload
    @staticmethod
    def createScalar(boolean: bool) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(byte: int) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(type: Type) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(type: Type, valueDescriptor: ValueDescriptor, object: typing.Any) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(type: Type, object: typing.Any) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(valueDescriptor: ValueDescriptor, object: typing.Any) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(double: float) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(double: float, type: Type) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(float: float) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(int: int) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(object: typing.Any) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(string: str) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(long: int) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(long: int, type: Type) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalar(short: int) -> 'Scalar': ...
    @typing.overload
    @staticmethod
    def createScalarArray(immutableValue: 'ImmutableValue') -> 'ScalarArray': ...
    @typing.overload
    @staticmethod
    def createScalarArray(valueArray: typing.List['Value']) -> 'ScalarArray': ...
    @typing.overload
    @staticmethod
    def createScalarArray(object: typing.Any) -> 'ScalarArray': ...
    @typing.overload
    @staticmethod
    def createScalarArray(object: typing.Any, type: Type) -> 'ScalarArray': ...
    @typing.overload
    @staticmethod
    def createScalarArray2D(immutableValue: 'ImmutableValue') -> 'ScalarArray2D': ...
    @typing.overload
    @staticmethod
    def createScalarArray2D(object: typing.Any, int: int, int2: int) -> 'ScalarArray2D': ...
    @typing.overload
    @staticmethod
    def createScalarArray2D(object: typing.Any, int: int, int2: int, type: Type) -> 'ScalarArray2D': ...
    @staticmethod
    def createScalarFunction(double: float) -> 'DiscreteFunction': ...
    @staticmethod
    def createZeroFunction(double: float) -> 'DiscreteFunction': ...

class Values:
    DEFAULT_DOUBLE_PRECISION: typing.ClassVar[float] = ...
    INFINITE_PRECISION: typing.ClassVar[float] = ...
    doublePrecision: typing.ClassVar[float] = ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(immutableValue: 'ImmutableValue', immutableValue2: 'ImmutableValue') -> bool: ...
    @typing.overload
    @staticmethod
    def equals(double: float, double2: float) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(double: float, double2: float, double3: float) -> bool: ...
    @staticmethod
    def getDisplayValue(immutableValue: 'ImmutableValue') -> str: ...
    @staticmethod
    def getPrecision() -> float: ...
    @staticmethod
    def hasAllowedValue(immutableScalar: 'ImmutableScalar') -> bool: ...
    @staticmethod
    def isInLimits(immutableValue: 'ImmutableValue') -> bool: ...
    @staticmethod
    def isZero(double: float) -> bool: ...
    @typing.overload
    @staticmethod
    def round(double: float, int: int) -> float: ...
    @typing.overload
    @staticmethod
    def round(doubleArray: typing.List[float], int: int) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def round(float: float, int: int) -> float: ...
    @typing.overload
    @staticmethod
    def round(floatArray: typing.List[float], int: int) -> typing.List[float]: ...
    @staticmethod
    def roundArray(immutableScalarArray: 'ImmutableScalarArray', int: int) -> 'ImmutableScalarArray': ...
    @staticmethod
    def roundFunction(immutableDiscreteFunction: 'ImmutableDiscreteFunction', integer: int, integer2: int) -> 'ImmutableDiscreteFunction': ...
    @staticmethod
    def roundFunctionList(immutableDiscreteFunctionList: 'ImmutableDiscreteFunctionList', integer: int, integer2: int) -> 'ImmutableValue': ...
    @staticmethod
    def roundFunctionsArray(immutableDiscreteFunctionsArray: 'ImmutableDiscreteFunctionsArray', integer: int, integer2: int) -> 'ImmutableValue': ...
    @staticmethod
    def roundScalar(immutableScalar: 'ImmutableScalar', int: int) -> 'ImmutableScalar': ...
    @staticmethod
    def roundValue(immutableValue: 'ImmutableValue') -> 'ImmutableValue': ...
    @staticmethod
    def setPrecision(double: float) -> None: ...

class Function(Typed):
    def isDiscrete(self) -> bool: ...

class ImmutableValue(java.lang.Cloneable, java.io.Serializable, Typed):
    def clone(self) -> typing.Any: ...
    def getString(self) -> str: ...
    def getValueDescriptor(self) -> ValueDescriptor: ...
    def isDefined(self) -> bool: ...
    def makeMutable(self) -> 'Value': ...

class ContinuousFunction(Function):
    _evaluate__T = typing.TypeVar('_evaluate__T', bound='Value')  # <T>
    def evaluate(self, valueMap: cern.accsoft.commons.value.expression.ValueMap, list: java.util.List[_evaluate__T]) -> _evaluate__T: ...

class ImmutableDiscreteFunctionsArray(ImmutableValue):
    def getFunction(self, int: int) -> 'ImmutableDiscreteFunction': ...
    def getFunctions(self) -> typing.List['ImmutableDiscreteFunction']: ...
    def getFunctionsCount(self) -> int: ...
    def getYs(self, double: float) -> typing.List[float]: ...
    def subView(self, double: float, double2: float) -> 'ImmutableDiscreteFunctionsArray': ...
    def toXArray(self) -> typing.List[float]: ...

class ImmutableScalar(ImmutableValue):
    def getBoolean(self) -> bool: ...
    def getByte(self) -> int: ...
    def getDouble(self) -> float: ...
    def getFloat(self) -> float: ...
    def getInt(self) -> int: ...
    def getLong(self) -> int: ...
    def getObject(self) -> typing.Any: ...
    def getShort(self) -> int: ...
    def toSimpleParameterValue(self) -> cern.japc.value.SimpleParameterValue: ...

class MathFunction(Function, Interpolable): ...

class Value(ImmutableValue):
    @typing.overload
    def execute(self, binaryOperation: cern.accsoft.commons.value.operation.BinaryOperation, immutableValue: ImmutableValue) -> None: ...
    @typing.overload
    def execute(self, unaryOperation: cern.accsoft.commons.value.operation.UnaryOperation) -> None: ...
    def setDefined(self, boolean: bool) -> None: ...
    def setValueDescriptor(self, valueDescriptor: ValueDescriptor) -> None: ...

class BoundedPolynomialSequence(MathFunction, Value):
    def getBoundedPolynomials(self) -> typing.List['BoundedPolynomial']: ...
    def interpolate(self, double: float) -> float: ...

class DiscreteFunctionsArray(ImmutableDiscreteFunctionsArray, Value):
    def getFunction(self, int: int) -> 'DiscreteFunction': ...
    def getFunctions(self) -> typing.List['DiscreteFunction']: ...
    @typing.overload
    def insert(self, double: float) -> bool: ...
    @typing.overload
    def insert(self, int: int, double: float) -> bool: ...
    @typing.overload
    def insert(self, int: int, double: float, double2: float) -> bool: ...
    @typing.overload
    def insertAll(self, doubleArray: typing.List[float]) -> int: ...
    @typing.overload
    def insertAll(self, int: int, immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> int: ...
    @typing.overload
    def insertAll(self, int: int, doubleArray: typing.List[float]) -> int: ...
    @typing.overload
    def remove(self, double: float) -> bool: ...
    @typing.overload
    def remove(self, int: int, double: float) -> bool: ...
    @typing.overload
    def removeAll(self, doubleArray: typing.List[float]) -> int: ...
    @typing.overload
    def removeAll(self, int: int, doubleArray: typing.List[float]) -> int: ...
    def retainAll(self, int: int, immutableDiscreteFunction: 'ImmutableDiscreteFunction', double: float) -> int: ...
    def setY(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def subView(self, int: int, double: float, double2: float) -> 'DiscreteFunction': ...
    @typing.overload
    def subView(self, double: float, double2: float) -> 'DiscreteFunctionsArray': ...
    @typing.overload
    def translate(self, double: float) -> None: ...
    @typing.overload
    def translate(self, int: int, double: float) -> None: ...

class ImmutableDiscreteFunction(Function, ImmutableScalar, Interpolable):
    def getLength(self) -> float: ...
    def getX(self, int: int) -> float: ...
    def getY(self, int: int) -> float: ...
    def indexOf(self, double: float) -> int: ...
    def size(self) -> int: ...
    def subFunction(self, double: float, double2: float) -> 'DiscreteFunction': ...
    @typing.overload
    def toPointArray(self) -> typing.List['ImmutablePoint']: ...
    @typing.overload
    def toPointArray(self, immutablePointArray: typing.List['ImmutablePoint']) -> typing.List['ImmutablePoint']: ...
    def toScalarArray2D(self) -> 'ScalarArray2D': ...
    def toXArray(self) -> typing.List[float]: ...
    def toYArray(self) -> typing.List[float]: ...

class ImmutablePoint(ImmutableScalar):
    def getX(self) -> float: ...
    def getY(self) -> float: ...

class ImmutableScalarArray(ImmutableScalar):
    def getArray2D(self) -> cern.japc.value.Array2D: ...
    @typing.overload
    def getBoolean(self) -> bool: ...
    @typing.overload
    def getBoolean(self, int: int) -> bool: ...
    @typing.overload
    def getBooleans(self) -> typing.List[bool]: ...
    @typing.overload
    def getBooleans(self, int: int, int2: int) -> typing.List[bool]: ...
    @typing.overload
    def getByte(self) -> int: ...
    @typing.overload
    def getByte(self, int: int) -> int: ...
    @typing.overload
    def getBytes(self) -> typing.List[int]: ...
    @typing.overload
    def getBytes(self, int: int, int2: int) -> typing.List[int]: ...
    @typing.overload
    def getDouble(self) -> float: ...
    @typing.overload
    def getDouble(self, int: int) -> float: ...
    @typing.overload
    def getDoubles(self) -> typing.List[float]: ...
    @typing.overload
    def getDoubles(self, int: int, int2: int) -> typing.List[float]: ...
    @typing.overload
    def getFloat(self) -> float: ...
    @typing.overload
    def getFloat(self, int: int) -> float: ...
    @typing.overload
    def getFloats(self) -> typing.List[float]: ...
    @typing.overload
    def getFloats(self, int: int, int2: int) -> typing.List[float]: ...
    @typing.overload
    def getInt(self) -> int: ...
    @typing.overload
    def getInt(self, int: int) -> int: ...
    @typing.overload
    def getInts(self) -> typing.List[int]: ...
    @typing.overload
    def getInts(self, int: int, int2: int) -> typing.List[int]: ...
    def getLength(self) -> int: ...
    @typing.overload
    def getLong(self) -> int: ...
    @typing.overload
    def getLong(self, int: int) -> int: ...
    @typing.overload
    def getLongs(self) -> typing.List[int]: ...
    @typing.overload
    def getLongs(self, int: int, int2: int) -> typing.List[int]: ...
    @typing.overload
    def getObject(self) -> typing.Any: ...
    @typing.overload
    def getObject(self, int: int) -> typing.Any: ...
    def getScalar(self, int: int) -> ImmutableScalar: ...
    def getScalars(self) -> typing.List[ImmutableScalar]: ...
    @typing.overload
    def getShort(self) -> int: ...
    @typing.overload
    def getShort(self, int: int) -> int: ...
    @typing.overload
    def getShorts(self) -> typing.List[int]: ...
    @typing.overload
    def getShorts(self, int: int, int2: int) -> typing.List[int]: ...
    @typing.overload
    def getString(self, int: int) -> str: ...
    @typing.overload
    def getString(self) -> str: ...
    @typing.overload
    def getStrings(self) -> typing.List[str]: ...
    @typing.overload
    def getStrings(self, int: int, int2: int) -> typing.List[str]: ...
    def indexOf(self, object: typing.Any) -> int: ...
    def subArray(self, int: int, int2: int) -> 'ScalarArray': ...

class Polynomial(MathFunction, Value):
    def getCoefficients(self) -> typing.List[float]: ...
    def getDegree(self) -> int: ...

class Scalar(Value, ImmutableScalar):
    def setBoolean(self, boolean: bool) -> None: ...
    def setByte(self, byte: int) -> None: ...
    def setDouble(self, double: float) -> None: ...
    def setFloat(self, float: float) -> None: ...
    def setInt(self, int: int) -> None: ...
    def setLong(self, long: int) -> None: ...
    def setObject(self, object: typing.Any) -> None: ...
    def setShort(self, short: int) -> None: ...
    def setString(self, string: str) -> None: ...

class BoundedPolynomial(Polynomial):
    def getInterval(self) -> Interval: ...
    def interpolate(self, double: float) -> float: ...

class DiscreteFunction(Scalar, ImmutableDiscreteFunction):
    @typing.overload
    def insert(self, double: float) -> bool: ...
    @typing.overload
    def insert(self, double: float, double2: float) -> bool: ...
    @typing.overload
    def insertAll(self, immutableDiscreteFunction: ImmutableDiscreteFunction, double: float) -> int: ...
    @typing.overload
    def insertAll(self, doubleArray: typing.List[float]) -> int: ...
    def remove(self, double: float) -> bool: ...
    def removeAll(self, doubleArray: typing.List[float]) -> int: ...
    def retainAll(self, immutableDiscreteFunction: ImmutableDiscreteFunction, double: float) -> int: ...
    def setY(self, int: int, double: float) -> None: ...
    def subView(self, double: float, double2: float) -> 'DiscreteFunction': ...
    def translate(self, double: float) -> None: ...

class ImmutableDiscreteFunctionList(ImmutableDiscreteFunction):
    def getAbsoluteFunction(self, int: int) -> ImmutableDiscreteFunction: ...
    def getFunction(self, int: int) -> ImmutableDiscreteFunction: ...
    def getFunctions(self) -> typing.List[ImmutableDiscreteFunction]: ...
    def getFunctionsCount(self) -> int: ...
    def getSizeIncludingStopPoints(self) -> int: ...
    def getStopPointsIndices(self) -> typing.List[int]: ...

class ImmutableScalarArray2D(ImmutableScalarArray):
    def getArray2D(self) -> cern.japc.value.Array2D: ...
    def getColumnCount(self) -> int: ...
    def getRowCount(self) -> int: ...

class Point(Scalar, ImmutablePoint):
    def setX(self, double: float) -> None: ...
    def setY(self, double: float) -> None: ...

class ScalarArray(Scalar, ImmutableScalarArray, Indexed):
    def insert(self, int: int, double: float) -> None: ...
    def insertAll(self, intArray: typing.List[int], doubleArray: typing.List[float]) -> None: ...
    def remove(self, int: int) -> None: ...
    def removeAll(self, intArray: typing.List[int]) -> None: ...
    @typing.overload
    def setBoolean(self, boolean: bool) -> None: ...
    @typing.overload
    def setBoolean(self, int: int, boolean: bool) -> None: ...
    def setBooleans(self, booleanArray: typing.List[bool]) -> None: ...
    @typing.overload
    def setByte(self, byte: int) -> None: ...
    @typing.overload
    def setByte(self, int: int, byte: int) -> None: ...
    def setBytes(self, byteArray: typing.List[int]) -> None: ...
    @typing.overload
    def setDouble(self, double: float) -> None: ...
    @typing.overload
    def setDouble(self, int: int, double: float) -> None: ...
    def setDoubles(self, doubleArray: typing.List[float]) -> None: ...
    @typing.overload
    def setFloat(self, float: float) -> None: ...
    @typing.overload
    def setFloat(self, int: int, float: float) -> None: ...
    def setFloats(self, floatArray: typing.List[float]) -> None: ...
    @typing.overload
    def setInt(self, int: int) -> None: ...
    @typing.overload
    def setInt(self, int: int, int2: int) -> None: ...
    def setInts(self, intArray: typing.List[int]) -> None: ...
    @typing.overload
    def setLong(self, long: int) -> None: ...
    @typing.overload
    def setLong(self, int: int, long: int) -> None: ...
    def setLongs(self, longArray: typing.List[int]) -> None: ...
    def setObject(self, object: typing.Any) -> None: ...
    def setScalar(self, int: int, immutableScalar: ImmutableScalar) -> None: ...
    def setScalars(self, immutableScalarArray: typing.List[ImmutableScalar]) -> None: ...
    @typing.overload
    def setShort(self, short: int) -> None: ...
    @typing.overload
    def setShort(self, int: int, short: int) -> None: ...
    def setShorts(self, shortArray: typing.List[int]) -> None: ...
    @typing.overload
    def setString(self, string: str) -> None: ...
    @typing.overload
    def setString(self, int: int, string: str) -> None: ...
    def setStrings(self, stringArray: typing.List[str]) -> None: ...

class DiscreteFunctionList(DiscreteFunction, ImmutableDiscreteFunctionList):
    def merge(self, int: int) -> None: ...
    def setStopPoints(self, intArray: typing.List[int]) -> None: ...
    def split(self, double: float) -> None: ...
    def subView(self, double: float, double2: float) -> DiscreteFunction: ...

class ScalarArray2D(ImmutableScalarArray2D, ScalarArray):
    def setBooleans2D(self, booleanArray: typing.List[bool], int: int, int2: int) -> None: ...
    def setBytes2D(self, byteArray: typing.List[int], int: int, int2: int) -> None: ...
    def setDoubles2D(self, doubleArray: typing.List[float], int: int, int2: int) -> None: ...
    def setFloats2D(self, floatArray: typing.List[float], int: int, int2: int) -> None: ...
    def setInts2D(self, intArray: typing.List[int], int2: int, int3: int) -> None: ...
    def setLongs2D(self, longArray: typing.List[int], int: int, int2: int) -> None: ...
    def setObjects2D(self, object: typing.Any, int: int, int2: int) -> None: ...
    def setShorts2D(self, shortArray: typing.List[int], int: int, int2: int) -> None: ...
    def setStrings2D(self, stringArray: typing.List[str], int: int, int2: int) -> None: ...
