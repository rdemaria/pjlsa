import cern.accsoft.commons.value
import cern.accsoft.commons.value.expression
import cern.accsoft.commons.value.operation
import cern.accsoft.commons.value.spi
import cern.japc.value
import java.io
import java.util
import typing



class AbstractMathFunction(cern.accsoft.commons.value.MathFunction):
    """
    Java class 'cern.accsoft.commons.value.spi.function.AbstractMathFunction'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.accsoft.commons.value.MathFunction
    
      Constructors:
        * AbstractMathFunction()
    
    """
    def __init__(self): ...
    def getType(self) -> cern.accsoft.commons.value.Type: ...
    def interpolate(self, double: float) -> float: ...
    def isDiscrete(self) -> bool: ...

class BoundedPolynomialIntervalComparator(java.util.Comparator[cern.accsoft.commons.value.BoundedPolynomial]):
    """
    Java class 'cern.accsoft.commons.value.spi.function.BoundedPolynomialIntervalComparator'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.util.Comparator
    
    """
    def compare(self, boundedPolynomial: cern.accsoft.commons.value.BoundedPolynomial, boundedPolynomial2: cern.accsoft.commons.value.BoundedPolynomial) -> int: ...
    @staticmethod
    def getInstance() -> 'BoundedPolynomialIntervalComparator': ...

class BoundedPolynomialSequenceImpl(cern.accsoft.commons.value.spi.AbstractValue, cern.accsoft.commons.value.BoundedPolynomialSequence):
    """
    Java class 'cern.accsoft.commons.value.spi.function.BoundedPolynomialSequenceImpl'
    
        Extends:
            cern.accsoft.commons.value.spi.AbstractValue
    
        Interfaces:
            cern.accsoft.commons.value.BoundedPolynomialSequence
    
      Constructors:
        * BoundedPolynomialSequenceImpl(java.util.Collection)
        * BoundedPolynomialSequenceImpl(cern.accsoft.commons.value.BoundedPolynomial[])
    
    """
    @typing.overload
    def __init__(self, boundedPolynomialArray: typing.List[cern.accsoft.commons.value.BoundedPolynomial]): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[cern.accsoft.commons.value.BoundedPolynomial], typing.Sequence[cern.accsoft.commons.value.BoundedPolynomial]]): ...
    @staticmethod
    def createOfAbsoluteBoundedPolynomials(doubleArray: typing.List[typing.List[float]]) -> cern.accsoft.commons.value.BoundedPolynomialSequence: ...
    @staticmethod
    def createOfRelativeBoundedPolynomials(doubleArray: typing.List[typing.List[float]]) -> cern.accsoft.commons.value.BoundedPolynomialSequence: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def execute(self, binaryOperation: cern.accsoft.commons.value.operation.BinaryOperation, immutableValue: cern.accsoft.commons.value.ImmutableValue) -> None: ...
    @typing.overload
    def execute(self, unaryOperation: cern.accsoft.commons.value.operation.UnaryOperation) -> None: ...
    def getBoundedPolynomials(self) -> typing.List[cern.accsoft.commons.value.BoundedPolynomial]: ...
    def getString(self) -> str: ...
    def hashCode(self) -> int: ...
    def interpolate(self, double: float) -> float: ...
    def isDiscrete(self) -> bool: ...
    def toString(self) -> str: ...

class DiscreteFunctionImpl(cern.accsoft.commons.value.spi.AbstractValue, cern.accsoft.commons.value.DiscreteFunction, java.io.Serializable):
    """
    Java class 'cern.accsoft.commons.value.spi.function.DiscreteFunctionImpl'
    
        Extends:
            cern.accsoft.commons.value.spi.AbstractValue
    
        Interfaces:
            cern.accsoft.commons.value.DiscreteFunction,
            java.io.Serializable
    
    """
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def execute(self, binaryOperation: cern.accsoft.commons.value.operation.BinaryOperation, immutableValue: cern.accsoft.commons.value.ImmutableValue) -> None: ...
    @typing.overload
    def execute(self, unaryOperation: cern.accsoft.commons.value.operation.UnaryOperation) -> None: ...
    def getBoolean(self) -> bool: ...
    def getByte(self) -> int: ...
    def getDouble(self) -> float: ...
    def getFloat(self) -> float: ...
    def getInt(self) -> int: ...
    def getLength(self) -> float: ...
    def getLong(self) -> int: ...
    def getObject(self) -> typing.Any: ...
    def getShort(self) -> int: ...
    def getString(self) -> str: ...
    def hashCode(self) -> int: ...
    def interpolate(self, double: float) -> float: ...
    def isDiscrete(self) -> bool: ...
    def setBoolean(self, boolean: bool) -> None: ...
    def setByte(self, byte: int) -> None: ...
    def setDouble(self, double: float) -> None: ...
    def setFloat(self, float: float) -> None: ...
    def setInt(self, int: int) -> None: ...
    def setLong(self, long: int) -> None: ...
    def setObject(self, object: typing.Any) -> None: ...
    def setShort(self, short: int) -> None: ...
    def setString(self, string: str) -> None: ...
    def toScalarArray2D(self) -> cern.accsoft.commons.value.ScalarArray2D: ...
    def toSimpleParameterValue(self) -> cern.japc.value.SimpleParameterValue: ...
    def toString(self) -> str: ...

class DiscreteFunctionsArrayImpl(cern.accsoft.commons.value.spi.AbstractValue, cern.accsoft.commons.value.DiscreteFunctionsArray, java.io.Serializable):
    """
    Java class 'cern.accsoft.commons.value.spi.function.DiscreteFunctionsArrayImpl'
    
        Extends:
            cern.accsoft.commons.value.spi.AbstractValue
    
        Interfaces:
            cern.accsoft.commons.value.DiscreteFunctionsArray,
            java.io.Serializable
    
      Constructors:
        * DiscreteFunctionsArrayImpl()
        * DiscreteFunctionsArrayImpl(cern.accsoft.commons.value.ImmutableDiscreteFunction[])
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, immutableDiscreteFunctionArray: typing.List[cern.accsoft.commons.value.ImmutableDiscreteFunction]): ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def execute(self, binaryOperation: cern.accsoft.commons.value.operation.BinaryOperation, immutableValue: cern.accsoft.commons.value.ImmutableValue) -> None: ...
    @typing.overload
    def execute(self, unaryOperation: cern.accsoft.commons.value.operation.UnaryOperation) -> None: ...
    def getFunction(self, int: int) -> cern.accsoft.commons.value.DiscreteFunction: ...
    def getFunctions(self) -> typing.List[cern.accsoft.commons.value.DiscreteFunction]: ...
    def getFunctionsCount(self) -> int: ...
    def getString(self) -> str: ...
    def getYs(self, double: float) -> typing.List[float]: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def insert(self, double: float) -> bool: ...
    @typing.overload
    def insert(self, int: int, double: float) -> bool: ...
    @typing.overload
    def insert(self, int: int, double: float, double2: float) -> bool: ...
    @typing.overload
    def insertAll(self, doubleArray: typing.List[float]) -> int: ...
    @typing.overload
    def insertAll(self, int: int, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction, double: float) -> int: ...
    @typing.overload
    def insertAll(self, int: int, doubleArray: typing.List[float]) -> int: ...
    @typing.overload
    def remove(self, double: float) -> bool: ...
    @typing.overload
    def remove(self, int: int, double: float) -> bool: ...
    @typing.overload
    def removeAll(self, doubleArray: typing.List[float]) -> int: ...
    @typing.overload
    def removeAll(self, int: int, doubleArray: typing.List[float]) -> int: ...
    def retainAll(self, int: int, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction, double: float) -> int: ...
    def setY(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def subView(self, int: int, double: float, double2: float) -> cern.accsoft.commons.value.DiscreteFunction: ...
    @typing.overload
    def subView(self, double: float, double2: float) -> cern.accsoft.commons.value.DiscreteFunctionsArray: ...
    def toXArray(self) -> typing.List[float]: ...
    @typing.overload
    def translate(self, double: float) -> None: ...
    @typing.overload
    def translate(self, int: int, double: float) -> None: ...

class Discretizer:
    """
    Java class 'cern.accsoft.commons.value.spi.function.Discretizer'
    
        Extends:
            java.lang.Object
    
    """
    @typing.overload
    @staticmethod
    def createArray(int: int, double: float, double2: float) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def createArray(double: float, integer: int, double2: float, double3: float, integer2: int) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def createDiscreteFunction(interpolable: cern.accsoft.commons.value.Interpolable, double: float, int2: int, double2: float, double3: float) -> cern.accsoft.commons.value.DiscreteFunction: ...
    @typing.overload
    @staticmethod
    def createDiscreteFunction(interpolable: cern.accsoft.commons.value.Interpolable, doubleArray: typing.List[float]) -> cern.accsoft.commons.value.DiscreteFunction: ...
    @typing.overload
    @staticmethod
    def createDiscreteFunction(interpolable: cern.accsoft.commons.value.Interpolable, int2: int, double: float, double2: float) -> cern.accsoft.commons.value.DiscreteFunction: ...
    @typing.overload
    @staticmethod
    def createDiscreteFunction(interpolable: cern.accsoft.commons.value.Interpolable, double: float, int2: int, double2: float, double3: float, integer: int, double4: float, double5: float) -> cern.accsoft.commons.value.DiscreteFunction: ...

class ExpressionBasedFunction(cern.accsoft.commons.value.ContinuousFunction, java.io.Serializable):
    """
    Java class 'cern.accsoft.commons.value.spi.function.ExpressionBasedFunction'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.accsoft.commons.value.ContinuousFunction,
            java.io.Serializable
    
      Constructors:
        * ExpressionBasedFunction(cern.accsoft.commons.value.expression.Expression)
        * ExpressionBasedFunction(java.lang.String)
    
      Raises:
        cern.accsoft.commons.value.expression.ExpressionSyntaxException: from java
    
    """
    @typing.overload
    def __init__(self, expression: cern.accsoft.commons.value.expression.Expression): ...
    @typing.overload
    def __init__(self, string: str): ...
    _evaluate__T = typing.TypeVar('_evaluate__T', bound=cern.accsoft.commons.value.Value)  # <T>
    def evaluate(self, valueMap: cern.accsoft.commons.value.expression.ValueMap, list: java.util.List[_evaluate__T]) -> _evaluate__T: ...
    def getFunctionExpression(self) -> cern.accsoft.commons.value.expression.Expression: ...
    def getString(self) -> str: ...
    def getType(self) -> cern.accsoft.commons.value.Type: ...
    def isDiscrete(self) -> bool: ...
    @typing.overload
    def performOperation(self, binaryOperation: cern.accsoft.commons.value.operation.BinaryOperation, expression: cern.accsoft.commons.value.expression.Expression) -> None: ...
    @typing.overload
    def performOperation(self, binaryOperation: cern.accsoft.commons.value.operation.BinaryOperation, expressionBasedFunction: 'ExpressionBasedFunction') -> None: ...
    @typing.overload
    def performOperation(self, unaryOperation: cern.accsoft.commons.value.operation.UnaryOperation) -> None: ...
    def setFunctionExpression(self, expression: cern.accsoft.commons.value.expression.Expression) -> None: ...
    def toString(self) -> str: ...

class PolynomialImpl(cern.accsoft.commons.value.spi.AbstractValue, cern.accsoft.commons.value.Polynomial, cern.accsoft.commons.value.ImmutableValue):
    """
    Java class 'cern.accsoft.commons.value.spi.function.PolynomialImpl'
    
        Extends:
            cern.accsoft.commons.value.spi.AbstractValue
    
        Interfaces:
            cern.accsoft.commons.value.Polynomial,
            cern.accsoft.commons.value.ImmutableValue
    
      Constructors:
        * PolynomialImpl(java.util.SortedMap)
        * PolynomialImpl(int, double)
        * PolynomialImpl(double[])
        * PolynomialImpl(java.util.Collection)
    
    """
    @typing.overload
    def __init__(self, doubleArray: typing.List[float]): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[float], typing.Sequence[float]]): ...
    @typing.overload
    def __init__(self, sortedMap: java.util.SortedMap[int, float]): ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def execute(self, binaryOperation: cern.accsoft.commons.value.operation.BinaryOperation, immutableValue: cern.accsoft.commons.value.ImmutableValue) -> None: ...
    @typing.overload
    def execute(self, unaryOperation: cern.accsoft.commons.value.operation.UnaryOperation) -> None: ...
    def getCoefficients(self) -> typing.List[float]: ...
    def getDegree(self) -> int: ...
    def getString(self) -> str: ...
    def hashCode(self) -> int: ...
    def interpolate(self, double: float) -> float: ...
    def isDiscrete(self) -> bool: ...
    def toString(self) -> str: ...

class BoundedPolynomialImpl(PolynomialImpl, cern.accsoft.commons.value.BoundedPolynomial):
    """
    Java class 'cern.accsoft.commons.value.spi.function.BoundedPolynomialImpl'
    
        Extends:
            cern.accsoft.commons.value.spi.function.PolynomialImpl
    
        Interfaces:
            cern.accsoft.commons.value.BoundedPolynomial
    
      Constructors:
        * BoundedPolynomialImpl(cern.accsoft.commons.value.Polynomial, double, double)
        * BoundedPolynomialImpl(cern.accsoft.commons.value.Polynomial, cern.accsoft.commons.value.Interval)
    
    """
    @typing.overload
    def __init__(self, polynomial: cern.accsoft.commons.value.Polynomial, interval: cern.accsoft.commons.value.Interval): ...
    @typing.overload
    def __init__(self, polynomial: cern.accsoft.commons.value.Polynomial, double: float, double2: float): ...
    @staticmethod
    def createRelativeBoundedPolynomial(doubleArray: typing.List[float]) -> cern.accsoft.commons.value.BoundedPolynomial: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def execute(self, binaryOperation: cern.accsoft.commons.value.operation.BinaryOperation, immutableValue: cern.accsoft.commons.value.ImmutableValue) -> None: ...
    @typing.overload
    def execute(self, unaryOperation: cern.accsoft.commons.value.operation.UnaryOperation) -> None: ...
    def getInterval(self) -> cern.accsoft.commons.value.Interval: ...
    def getString(self) -> str: ...
    def hashCode(self) -> int: ...
    def interpolate(self, double: float) -> float: ...
    def toString(self) -> str: ...

class ConstantFunction(ExpressionBasedFunction):
    """
    Java class 'cern.accsoft.commons.value.spi.function.ConstantFunction'
    
        Extends:
            cern.accsoft.commons.value.spi.function.ExpressionBasedFunction
    
      Constructors:
        * ConstantFunction(double)
    
    """
    def __init__(self, double: float): ...

class CubicSplineFunctionPrototype(AbstractMathFunction):
    """
    Java class 'cern.accsoft.commons.value.spi.function.CubicSplineFunctionPrototype'
    
        Extends:
            cern.accsoft.commons.value.spi.function.AbstractMathFunction
    
      Constructors:
        * CubicSplineFunctionPrototype(cern.accsoft.commons.value.ImmutableDiscreteFunction)
    
    """
    def __init__(self, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction): ...
    def getAcceleration(self, double: float) -> float: ...
    def getFunction(self) -> cern.accsoft.commons.value.ImmutableDiscreteFunction: ...
    def getSplineX(self, int: int) -> float: ...
    @typing.overload
    def toDiscreteFunction(self, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction, double: float, int: int) -> cern.accsoft.commons.value.DiscreteFunction: ...
    @typing.overload
    def toDiscreteFunction(self, double: float, double2: float, int: int) -> cern.accsoft.commons.value.DiscreteFunction: ...

class DiscreteFunctionArrayImpl(DiscreteFunctionImpl, java.io.Serializable):
    """
    Java class 'cern.accsoft.commons.value.spi.function.DiscreteFunctionArrayImpl'
    
        Extends:
            cern.accsoft.commons.value.spi.function.DiscreteFunctionImpl
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * DiscreteFunctionArrayImpl(double[], double[], boolean)
        * DiscreteFunctionArrayImpl(double[], double[])
        * DiscreteFunctionArrayImpl(int[], double[])
    
    """
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], boolean: bool): ...
    @typing.overload
    def __init__(self, intArray: typing.List[int], doubleArray: typing.List[float]): ...
    def clone(self) -> typing.Any: ...
    def getX(self, int: int) -> float: ...
    def getY(self, int: int) -> float: ...
    def indexOf(self, double: float) -> int: ...
    @typing.overload
    def insert(self, double: float) -> bool: ...
    @typing.overload
    def insert(self, double: float, double2: float) -> bool: ...
    @typing.overload
    def insertAll(self, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction, double: float) -> int: ...
    @typing.overload
    def insertAll(self, doubleArray: typing.List[float]) -> int: ...
    @staticmethod
    def newInstanceWithoutCoordinatesCheck(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> 'DiscreteFunctionArrayImpl': ...
    def remove(self, double: float) -> bool: ...
    def removeAll(self, doubleArray: typing.List[float]) -> int: ...
    def retainAll(self, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction, double: float) -> int: ...
    def setX(self, int: int, double: float) -> None: ...
    def setY(self, int: int, double: float) -> None: ...
    def size(self) -> int: ...
    def stringValue(self) -> str: ...
    def subFunction(self, double: float, double2: float) -> cern.accsoft.commons.value.DiscreteFunction: ...
    def subView(self, double: float, double2: float) -> cern.accsoft.commons.value.DiscreteFunction: ...
    @typing.overload
    def toPointArray(self) -> typing.List[cern.accsoft.commons.value.ImmutablePoint]: ...
    @typing.overload
    def toPointArray(self, immutablePointArray: typing.List[cern.accsoft.commons.value.ImmutablePoint]) -> typing.List[cern.accsoft.commons.value.ImmutablePoint]: ...
    def toXArray(self) -> typing.List[float]: ...
    def toYArray(self) -> typing.List[float]: ...
    def translate(self, double: float) -> None: ...

class DiscreteFunctionListImpl(DiscreteFunctionImpl, cern.accsoft.commons.value.DiscreteFunctionList):
    """
    Java class 'cern.accsoft.commons.value.spi.function.DiscreteFunctionListImpl'
    
        Extends:
            cern.accsoft.commons.value.spi.function.DiscreteFunctionImpl
    
        Interfaces:
            cern.accsoft.commons.value.DiscreteFunctionList
    
      Constructors:
        * DiscreteFunctionListImpl(double[], double[], int[])
        * DiscreteFunctionListImpl(cern.accsoft.commons.value.ImmutableDiscreteFunction[])
        * DiscreteFunctionListImpl()
    
    """
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, immutableDiscreteFunctionArray: typing.List[cern.accsoft.commons.value.ImmutableDiscreteFunction]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.List[float], doubleArray2: typing.List[float], intArray: typing.List[int]): ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAbsoluteFunction(self, int: int) -> cern.accsoft.commons.value.ImmutableDiscreteFunction: ...
    def getFunction(self, int: int) -> cern.accsoft.commons.value.ImmutableDiscreteFunction: ...
    def getFunctions(self) -> typing.List[cern.accsoft.commons.value.ImmutableDiscreteFunction]: ...
    def getFunctionsCount(self) -> int: ...
    def getSizeIncludingStopPoints(self) -> int: ...
    def getStopPointsIndices(self) -> typing.List[int]: ...
    def getString(self) -> str: ...
    def getX(self, int: int) -> float: ...
    def getY(self, int: int) -> float: ...
    def hashCode(self) -> int: ...
    def indexOf(self, double: float) -> int: ...
    @typing.overload
    def insert(self, double: float) -> bool: ...
    @typing.overload
    def insert(self, double: float, double2: float) -> bool: ...
    @typing.overload
    def insertAll(self, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction, double: float) -> int: ...
    @typing.overload
    def insertAll(self, doubleArray: typing.List[float]) -> int: ...
    def merge(self, int: int) -> None: ...
    def remove(self, double: float) -> bool: ...
    def removeAll(self, doubleArray: typing.List[float]) -> int: ...
    def retainAll(self, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction, double: float) -> int: ...
    def setStopPoints(self, intArray: typing.List[int]) -> None: ...
    def setY(self, int: int, double: float) -> None: ...
    def size(self) -> int: ...
    def split(self, double: float) -> None: ...
    def subFunction(self, double: float, double2: float) -> cern.accsoft.commons.value.DiscreteFunctionList: ...
    def subView(self, double: float, double2: float) -> cern.accsoft.commons.value.DiscreteFunction: ...
    @typing.overload
    def toPointArray(self) -> typing.List[cern.accsoft.commons.value.ImmutablePoint]: ...
    @typing.overload
    def toPointArray(self, immutablePointArray: typing.List[cern.accsoft.commons.value.ImmutablePoint]) -> typing.List[cern.accsoft.commons.value.ImmutablePoint]: ...
    def toSimpleParameterValue(self) -> cern.japc.value.SimpleParameterValue: ...
    def toXArray(self) -> typing.List[float]: ...
    def toYArray(self) -> typing.List[float]: ...
    def translate(self, double: float) -> None: ...

class DiscreteFunctionPointImpl(DiscreteFunctionImpl, cern.accsoft.commons.value.DiscreteFunction, java.io.Serializable):
    """
    Java class 'cern.accsoft.commons.value.spi.function.DiscreteFunctionPointImpl'
    
        Extends:
            cern.accsoft.commons.value.spi.function.DiscreteFunctionImpl
    
        Interfaces:
            cern.accsoft.commons.value.DiscreteFunction,
            java.io.Serializable
    
      Constructors:
        * DiscreteFunctionPointImpl(cern.accsoft.commons.value.ImmutablePoint[])
        * DiscreteFunctionPointImpl(cern.accsoft.commons.value.Point[])
    
    """
    @typing.overload
    def __init__(self, immutablePointArray: typing.List[cern.accsoft.commons.value.ImmutablePoint]): ...
    @typing.overload
    def __init__(self, pointArray: typing.List[cern.accsoft.commons.value.Point]): ...
    def clone(self) -> typing.Any: ...
    def getX(self, int: int) -> float: ...
    def getY(self, int: int) -> float: ...
    def indexOf(self, double: float) -> int: ...
    @typing.overload
    def insert(self, double: float) -> bool: ...
    @typing.overload
    def insert(self, double: float, double2: float) -> bool: ...
    @typing.overload
    def insertAll(self, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction, double: float) -> int: ...
    @typing.overload
    def insertAll(self, doubleArray: typing.List[float]) -> int: ...
    def remove(self, double: float) -> bool: ...
    def removeAll(self, doubleArray: typing.List[float]) -> int: ...
    def retainAll(self, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction, double: float) -> int: ...
    def setX(self, int: int, double: float) -> None: ...
    def setY(self, int: int, double: float) -> None: ...
    def size(self) -> int: ...
    def stringValue(self) -> str: ...
    def subFunction(self, double: float, double2: float) -> cern.accsoft.commons.value.DiscreteFunction: ...
    def subView(self, double: float, double2: float) -> cern.accsoft.commons.value.DiscreteFunction: ...
    @typing.overload
    def toPointArray(self) -> typing.List[cern.accsoft.commons.value.ImmutablePoint]: ...
    @typing.overload
    def toPointArray(self, immutablePointArray: typing.List[cern.accsoft.commons.value.ImmutablePoint]) -> typing.List[cern.accsoft.commons.value.ImmutablePoint]: ...
    def toString(self) -> str: ...
    def toXArray(self) -> typing.List[float]: ...
    def toYArray(self) -> typing.List[float]: ...
    def translate(self, double: float) -> None: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("cern.accsoft.commons.value.spi.function")``.

    AbstractMathFunction: typing.Type[AbstractMathFunction]
    BoundedPolynomialImpl: typing.Type[BoundedPolynomialImpl]
    BoundedPolynomialIntervalComparator: typing.Type[BoundedPolynomialIntervalComparator]
    BoundedPolynomialSequenceImpl: typing.Type[BoundedPolynomialSequenceImpl]
    ConstantFunction: typing.Type[ConstantFunction]
    CubicSplineFunctionPrototype: typing.Type[CubicSplineFunctionPrototype]
    DiscreteFunctionArrayImpl: typing.Type[DiscreteFunctionArrayImpl]
    DiscreteFunctionImpl: typing.Type[DiscreteFunctionImpl]
    DiscreteFunctionListImpl: typing.Type[DiscreteFunctionListImpl]
    DiscreteFunctionPointImpl: typing.Type[DiscreteFunctionPointImpl]
    DiscreteFunctionsArrayImpl: typing.Type[DiscreteFunctionsArrayImpl]
    Discretizer: typing.Type[Discretizer]
    ExpressionBasedFunction: typing.Type[ExpressionBasedFunction]
    PolynomialImpl: typing.Type[PolynomialImpl]
