from typing import Any as _py_Any
from typing import List as _py_List
from typing import TypeVar as _py_TypeVar
from typing import Type as _py_Type
from typing import ClassVar as _py_ClassVar
from typing import Generic as _py_Generic
from typing import overload
import cern
import java.awt
import java.beans
import java.io
import java.lang
import java.lang.reflect
import java.net
import java.nio.file
import java.text
import java.util
import java.util.stream


class AppLauncher:
    @classmethod
    def launch(cls, stringArray: _py_List[str]) -> None: ...

class ArrayUtils:
    def __init__(self): ...
    @classmethod
    def addObjectToArray(cls, objectArray: _py_List[_py_Any], object2: _py_Any) -> _py_List[_py_Any]: ...
    _concatenateArrays__T = _py_TypeVar('_concatenateArrays__T')  # <T>
    @classmethod
    def concatenateArrays(cls, tArray: _py_List[_concatenateArrays__T], tArray2: _py_List[_concatenateArrays__T]) -> _py_List[_concatenateArrays__T]: ...
    @classmethod
    def isEmpty(cls, objectArray: _py_List[_py_Any]) -> bool: ...
    _toArray__T = _py_TypeVar('_toArray__T')  # <T>
    @classmethod
    def toArray(cls, collection: java.util.Collection[_toArray__T], class_: _py_Type[_toArray__T]) -> _py_List[_toArray__T]: ...
    @classmethod
    def toDoubleArray(cls, collection: java.util.Collection[float]) -> _py_List[float]: ...
    @classmethod
    def toFloatArray(cls, collection: java.util.Collection[float]) -> _py_List[float]: ...
    @classmethod
    def toLongArray(cls, collection: java.util.Collection[int]) -> _py_List[int]: ...
    @classmethod
    def toObjectArray(cls, object: _py_Any) -> _py_List[_py_Any]: ...
    @classmethod
    def toStringArray(cls, collection: java.util.Collection[str]) -> _py_List[str]: ...

class Assert:
    def __init__(self): ...
    @classmethod
    def argHasText(cls, string: str, string2: str) -> None: ...
    @classmethod
    def argIsNumber(cls, double: float, string: str) -> None: ...
    @classmethod
    def argNotNull(cls, object: _py_Any, string: str) -> None: ...
    @classmethod
    @overload
    def doesNotContain(cls, string: str, string2: str) -> None: ...
    @classmethod
    @overload
    def doesNotContain(cls, string: str, string2: str, string3: str) -> None: ...
    @classmethod
    @overload
    def hasLength(cls, string: str) -> None: ...
    @classmethod
    @overload
    def hasLength(cls, string: str, string2: str) -> None: ...
    @classmethod
    @overload
    def hasText(cls, string: str) -> None: ...
    @classmethod
    @overload
    def hasText(cls, string: str, string2: str) -> None: ...
    @classmethod
    @overload
    def isAssignable(cls, class_: _py_Type, class2: _py_Type) -> None: ...
    @classmethod
    @overload
    def isAssignable(cls, class_: _py_Type, class2: _py_Type, string: str) -> None: ...
    @classmethod
    @overload
    def isInstanceOf(cls, class_: _py_Type, object: _py_Any) -> None: ...
    @classmethod
    @overload
    def isInstanceOf(cls, class_: _py_Type, object: _py_Any, string: str) -> None: ...
    @classmethod
    @overload
    def isNull(cls, object: _py_Any) -> None: ...
    @classmethod
    @overload
    def isNull(cls, object: _py_Any, string: str) -> None: ...
    @classmethod
    def isNumber(cls, double: float, string: str) -> None: ...
    @classmethod
    @overload
    def isTrue(cls, boolean: bool) -> None: ...
    @classmethod
    @overload
    def isTrue(cls, boolean: bool, string: str) -> None: ...
    @classmethod
    @overload
    def notEmpty(cls, objectArray: _py_List[_py_Any]) -> None: ...
    @classmethod
    @overload
    def notEmpty(cls, objectArray: _py_List[_py_Any], string: str) -> None: ...
    @classmethod
    @overload
    def notEmpty(cls, collection: java.util.Collection) -> None: ...
    @classmethod
    @overload
    def notEmpty(cls, collection: java.util.Collection, string: str) -> None: ...
    @classmethod
    @overload
    def notEmpty(cls, map: java.util.Map) -> None: ...
    @classmethod
    @overload
    def notEmpty(cls, map: java.util.Map, string: str) -> None: ...
    @classmethod
    @overload
    def notNull(cls, object: _py_Any) -> None: ...
    @classmethod
    @overload
    def notNull(cls, object: _py_Any, string: str) -> None: ...
    @classmethod
    @overload
    def notNullElements(cls, objectArray: _py_List[_py_Any]) -> None: ...
    @classmethod
    @overload
    def notNullElements(cls, objectArray: _py_List[_py_Any], string: str) -> None: ...
    @classmethod
    @overload
    def notNullElements(cls, collection: java.util.Collection[_py_Any], string: str) -> None: ...
    @classmethod
    @overload
    def state(cls, boolean: bool) -> None: ...
    @classmethod
    @overload
    def state(cls, boolean: bool, string: str) -> None: ...

class BeanSupport:
    def __init__(self, object: _py_Any): ...
    @overload
    def addPropertyChangeListener(self, propertyChangeListener: java.beans.PropertyChangeListener) -> None: ...
    @overload
    def addPropertyChangeListener(self, string: str, propertyChangeListener: java.beans.PropertyChangeListener) -> None: ...
    @overload
    def removePropertyChangeListener(self, propertyChangeListener: java.beans.PropertyChangeListener) -> None: ...
    @overload
    def removePropertyChangeListener(self, string: str, propertyChangeListener: java.beans.PropertyChangeListener) -> None: ...

class BeanUtils:
    def __init__(self): ...
    @classmethod
    def findDeclaredMethod(cls, class_: _py_Type, string: str, classArray: _py_List[_py_Type]) -> java.lang.reflect.Method: ...
    @classmethod
    def findDeclaredMethodWithMinimalParameters(cls, class_: _py_Type, string: str) -> java.lang.reflect.Method: ...
    @classmethod
    def findMethod(cls, class_: _py_Type, string: str, classArray: _py_List[_py_Type]) -> java.lang.reflect.Method: ...
    @classmethod
    def findMethodWithMinimalParameters(cls, class_: _py_Type, string: str) -> java.lang.reflect.Method: ...
    @classmethod
    def getNames(cls, objectArray: _py_List[_py_Any]) -> _py_List[str]: ...
    @classmethod
    def getPropertyType(cls, class_: _py_Type, string: str) -> _py_Type: ...
    @classmethod
    def getPropertyValue(cls, object: _py_Any, string: str) -> _py_Any: ...
    @classmethod
    def isSimpleProperty(cls, class_: _py_Type) -> bool: ...
    @classmethod
    def resolveSignature(cls, string: str, class_: _py_Type) -> java.lang.reflect.Method: ...
    @classmethod
    def toPropertyValues(cls, objectArray: _py_List[_py_Any], string: str, class_: _py_Type) -> _py_List[_py_Any]: ...

class ClassLoaderJarInfo:
    JAR_EXT: _py_ClassVar[str] = ...
    @classmethod
    @overload
    def getJarInfo(cls, string: str) -> 'JarInfo': ...
    @classmethod
    @overload
    def getJarInfo(cls, string: str, object: _py_Any) -> 'JarInfo': ...
    @classmethod
    @overload
    def getLoadedJarInfo(cls) -> java.util.HashMap[str, 'JarInfo']: ...
    @classmethod
    @overload
    def getLoadedJarInfo(cls, object: _py_Any) -> java.util.HashMap[str, 'JarInfo']: ...

class ClassLoaderUtil:
    @classmethod
    @overload
    def addFile(cls, file: java.io.File) -> None: ...
    @classmethod
    @overload
    def addFile(cls, string: str) -> None: ...
    @classmethod
    def addURL(cls, uRL: java.net.URL) -> None: ...

class ClassLoaderUtils:
    def __init__(self): ...
    @classmethod
    @overload
    def showClassLoaderHierarchy(cls, classLoader: java.lang.ClassLoader) -> str: ...
    @classmethod
    @overload
    def showClassLoaderHierarchy(cls, classLoader: java.lang.ClassLoader, string: str, string2: str) -> str: ...
    @classmethod
    @overload
    def showClassLoaderHierarchy(cls, object: _py_Any, string: str) -> str: ...
    @classmethod
    @overload
    def showClassLoaderHierarchy(cls, object: _py_Any, string: str, string2: str, string3: str) -> str: ...

class ClassUtils:
    ARRAY_SUFFIX: _py_ClassVar[str] = ...
    def __init__(self): ...
    @classmethod
    def addResourcePathToPackagePath(cls, class_: _py_Type, string: str) -> str: ...
    @classmethod
    @overload
    def classNamesToString(cls, classArray: _py_List[_py_Type]) -> str: ...
    @classmethod
    @overload
    def classNamesToString(cls, collection: java.util.Collection) -> str: ...
    @classmethod
    def classPackageAsResourcePath(cls, class_: _py_Type) -> str: ...
    @classmethod
    def createCompositeInterface(cls, classArray: _py_List[_py_Type], classLoader: java.lang.ClassLoader) -> _py_Type: ...
    @classmethod
    def findClassVersion(cls, class_: _py_Type[_py_Any]) -> str: ...
    @classmethod
    @overload
    def forName(cls, string: str) -> _py_Type: ...
    @classmethod
    @overload
    def forName(cls, string: str, classLoader: java.lang.ClassLoader) -> _py_Type: ...
    @classmethod
    def getAllInterfaces(cls, object: _py_Any) -> _py_List[_py_Type]: ...
    @classmethod
    def getAllInterfacesAsSet(cls, object: _py_Any) -> java.util.Set: ...
    @classmethod
    def getAllInterfacesForClass(cls, class_: _py_Type) -> _py_List[_py_Type]: ...
    @classmethod
    def getAllInterfacesForClassAsSet(cls, class_: _py_Type) -> java.util.Set: ...
    @classmethod
    def getClassFileName(cls, class_: _py_Type) -> str: ...
    @classmethod
    def getConstructorIfAvailable(cls, class_: _py_Type, classArray: _py_List[_py_Type]) -> java.lang.reflect.Constructor: ...
    @classmethod
    def getDefaultClassLoader(cls) -> java.lang.ClassLoader: ...
    @classmethod
    def getMethodCountForName(cls, class_: _py_Type, string: str) -> int: ...
    @classmethod
    def getMethodIfAvailable(cls, class_: _py_Type, string: str, classArray: _py_List[_py_Type]) -> java.lang.reflect.Method: ...
    @classmethod
    def getQualifiedMethodName(cls, method: java.lang.reflect.Method) -> str: ...
    @classmethod
    def getQualifiedName(cls, class_: _py_Type) -> str: ...
    @classmethod
    @overload
    def getShortName(cls, class_: _py_Type) -> str: ...
    @classmethod
    @overload
    def getShortName(cls, string: str) -> str: ...
    @classmethod
    def getShortNameAsProperty(cls, class_: _py_Type) -> str: ...
    @classmethod
    def getStaticMethod(cls, class_: _py_Type, string: str, classArray: _py_List[_py_Type]) -> java.lang.reflect.Method: ...
    @classmethod
    @overload
    def getUserClass(cls, class_: _py_Type) -> _py_Type: ...
    @classmethod
    @overload
    def getUserClass(cls, object: _py_Any) -> _py_Type: ...
    @classmethod
    def hasAtLeastOneMethodWithName(cls, class_: _py_Type, string: str) -> bool: ...
    @classmethod
    def hasConstructor(cls, class_: _py_Type, classArray: _py_List[_py_Type]) -> bool: ...
    @classmethod
    def hasMethod(cls, class_: _py_Type, string: str, classArray: _py_List[_py_Type]) -> bool: ...
    @classmethod
    def isAssignable(cls, class_: _py_Type, class2: _py_Type) -> bool: ...
    @classmethod
    def isAssignableValue(cls, class_: _py_Type, object: _py_Any) -> bool: ...
    @classmethod
    @overload
    def isPresent(cls, string: str) -> bool: ...
    @classmethod
    @overload
    def isPresent(cls, string: str, classLoader: java.lang.ClassLoader) -> bool: ...
    @classmethod
    def isPrimitiveArray(cls, class_: _py_Type) -> bool: ...
    @classmethod
    def isPrimitiveOrWrapper(cls, class_: _py_Type) -> bool: ...
    @classmethod
    def isPrimitiveWrapper(cls, class_: _py_Type) -> bool: ...
    @classmethod
    def isPrimitiveWrapperArray(cls, class_: _py_Type) -> bool: ...
    @classmethod
    def resolveClassName(cls, string: str, classLoader: java.lang.ClassLoader) -> _py_Type: ...
    @classmethod
    def resolvePrimitiveClassName(cls, string: str) -> _py_Type: ...

class ClasspathUtils:
    @classmethod
    def findSubClassesInPackage(cls, class_: _py_Type[_py_Any], string: str, boolean: bool) -> java.util.Set[_py_Type[_py_Any]]: ...

class Cleanable:
    def cleanup(self) -> None: ...
    def isCleaning(self) -> bool: ...

class CleanableUtil:
    @classmethod
    def cleanupContainer(cls, container: java.awt.Container) -> None: ...

class CollectionUtils:
    def __init__(self): ...
    @classmethod
    def arrayToList(cls, object: _py_Any) -> java.util.List: ...
    @classmethod
    @overload
    def contains(cls, enumeration: java.util.Enumeration, object: _py_Any) -> bool: ...
    @classmethod
    @overload
    def contains(cls, iterator: java.util.Iterator, object: _py_Any) -> bool: ...
    @classmethod
    def containsAny(cls, collection: java.util.Collection, collection2: java.util.Collection) -> bool: ...
    @classmethod
    def containsInstance(cls, collection: java.util.Collection, object: _py_Any) -> bool: ...
    @classmethod
    def findFirstMatch(cls, collection: java.util.Collection, collection2: java.util.Collection) -> _py_Any: ...
    @classmethod
    @overload
    def findValueOfType(cls, collection: java.util.Collection, class_: _py_Type) -> _py_Any: ...
    @classmethod
    @overload
    def findValueOfType(cls, collection: java.util.Collection, classArray: _py_List[_py_Type]) -> _py_Any: ...
    _flatten__C = _py_TypeVar('_flatten__C', bound=java.util.Collection)  # <C>
    _flatten__T = _py_TypeVar('_flatten__T')  # <T>
    @classmethod
    def flatten(cls, collection: java.util.Collection[java.util.Collection[_flatten__T]], collector: java.util.stream.Collector[_flatten__T, _py_Any, _flatten__C]) -> _flatten__C: ...
    _flattenToList__T = _py_TypeVar('_flattenToList__T')  # <T>
    @classmethod
    def flattenToList(cls, collection: java.util.Collection[java.util.Collection[_flattenToList__T]]) -> java.util.List[_flattenToList__T]: ...
    _flattenToSet__T = _py_TypeVar('_flattenToSet__T')  # <T>
    @classmethod
    def flattenToSet(cls, collection: java.util.Collection[java.util.Collection[_flattenToSet__T]]) -> java.util.Set[_flattenToSet__T]: ...
    @classmethod
    def hasUniqueObject(cls, collection: java.util.Collection) -> bool: ...
    @classmethod
    @overload
    def isEmpty(cls, collection: java.util.Collection[_py_Any]) -> bool: ...
    @classmethod
    @overload
    def isEmpty(cls, map: java.util.Map[_py_Any, _py_Any]) -> bool: ...
    @classmethod
    def mergeArrayIntoCollection(cls, object: _py_Any, collection: java.util.Collection) -> None: ...
    @classmethod
    def mergePropertiesIntoMap(cls, properties: java.util.Properties, map: java.util.Map) -> None: ...
    _toSet__E = _py_TypeVar('_toSet__E')  # <E>
    @classmethod
    def toSet(cls, eArray: _py_List[_toSet__E]) -> java.util.Set[_toSet__E]: ...
    _toSortedList__T = _py_TypeVar('_toSortedList__T')  # <T>
    @classmethod
    def toSortedList(cls, collection: java.util.Collection[_toSortedList__T]) -> java.util.List[_toSortedList__T]: ...

class ExceptionUtils:
    def __init__(self): ...
    @classmethod
    @overload
    def extractExceptionMessage(cls, throwable: java.lang.Throwable) -> str: ...
    @classmethod
    @overload
    def extractExceptionMessage(cls, throwable: java.lang.Throwable, boolean: bool) -> str: ...
    @classmethod
    def filterStackTrace(cls, throwable: java.lang.Throwable, string: str) -> None: ...
    @classmethod
    def getCondensedStackTrace(cls, throwable: java.lang.Throwable, int: int) -> str: ...
    @classmethod
    def getRootCause(cls, throwable: java.lang.Throwable) -> java.lang.Throwable: ...
    @classmethod
    def getStackTraceAsString(cls, throwable: java.lang.Throwable) -> str: ...

class FileCopyUtils:
    BUFFER_SIZE: _py_ClassVar[int] = ...
    def __init__(self): ...
    @classmethod
    @overload
    def copy(cls, file: java.io.File, file2: java.io.File) -> int: ...
    @classmethod
    @overload
    def copy(cls, inputStream: java.io.InputStream, outputStream: java.io.OutputStream) -> int: ...
    @classmethod
    @overload
    def copy(cls, reader: java.io.Reader, writer: java.io.Writer) -> int: ...
    @classmethod
    @overload
    def copy(cls, byteArray: _py_List[int], file: java.io.File) -> None: ...
    @classmethod
    @overload
    def copy(cls, byteArray: _py_List[int], outputStream: java.io.OutputStream) -> None: ...
    @classmethod
    @overload
    def copy(cls, string: str, writer: java.io.Writer) -> None: ...
    @classmethod
    @overload
    def copyToByteArray(cls, file: java.io.File) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyToByteArray(cls, inputStream: java.io.InputStream) -> _py_List[int]: ...
    @classmethod
    def copyToString(cls, reader: java.io.Reader) -> str: ...

class FileUtils:
    FS: _py_ClassVar[str] = ...
    DATA_URL: _py_ClassVar[str] = ...
    DATA_PATH: _py_ClassVar[str] = ...
    FILE_BY_DATE_COMPARATOR: _py_ClassVar[java.util.Comparator] = ...
    def __init__(self): ...
    @classmethod
    def createFilenameFilter(cls, string: str) -> java.io.FilenameFilter: ...
    @classmethod
    @overload
    def findFiles(cls, file: java.io.File, filenameFilter: java.io.FilenameFilter) -> java.util.List[java.io.File]: ...
    @classmethod
    @overload
    def findFiles(cls, string: str, string2: str) -> java.util.List[str]: ...
    @classmethod
    def getTempDir(cls) -> java.io.File: ...
    @classmethod
    @overload
    def readAllLines(cls, inputStream: java.io.InputStream) -> java.util.List[str]: ...
    @classmethod
    @overload
    def readAllLines(cls, string: str) -> java.util.List[str]: ...
    @classmethod
    @overload
    def readAllText(cls, inputStream: java.io.InputStream) -> str: ...
    @classmethod
    @overload
    def readAllText(cls, string: str) -> str: ...

class JarClassLoader(java.net.URLClassLoader):
    def __init__(self, uRL: java.net.URL): ...
    def getMainClassName(self) -> str: ...
    def invokeClass(self, string: str, stringArray: _py_List[str]) -> None: ...

class JarInfo:
    classLoaderName: str = ...
    cbngJarName: str = ...
    jarName: str = ...
    vendor: str = ...
    version: str = ...
    version2: str = ...
    jarPath: str = ...
    def __init__(self): ...
    def toString(self) -> str: ...

class JdkUtils:
    JDK_VERSION: _py_ClassVar[str] = ...
    JDK_PATH_DEFAULT: _py_ClassVar[str] = ...
    def __init__(self): ...
    @classmethod
    def findCurrentJdkDir(cls) -> str: ...
    @classmethod
    def findCurrentJvmPath(cls) -> java.nio.file.Path: ...
    @classmethod
    def findJdkDirsUnder(cls, string: str) -> java.util.List[str]: ...
    @classmethod
    def findStandardJdkDirs(cls) -> java.util.List[str]: ...
    @classmethod
    def getPidLinux(cls) -> int: ...

class MapUtils:
    def __init__(self): ...
    _extractValues__K = _py_TypeVar('_extractValues__K')  # <K>
    _extractValues__V = _py_TypeVar('_extractValues__V')  # <V>
    _extractValues__C = _py_TypeVar('_extractValues__C', bound=java.util.Collection)  # <C>
    @classmethod
    def extractValues(cls, map: java.util.Map[_extractValues__K, _extractValues__C]) -> java.util.Set[_extractValues__V]: ...
    _findMatchingValues__T = _py_TypeVar('_findMatchingValues__T')  # <T>
    @classmethod
    def findMatchingValues(cls, map: java.util.Map[str, _findMatchingValues__T], string: str, matchType: 'MapUtils.MatchType') -> java.util.Map[str, _findMatchingValues__T]: ...
    _getKeyByValue__T = _py_TypeVar('_getKeyByValue__T')  # <T>
    _getKeyByValue__E = _py_TypeVar('_getKeyByValue__E')  # <E>
    @classmethod
    def getKeyByValue(cls, map: java.util.Map[_getKeyByValue__T, _getKeyByValue__E], e: _getKeyByValue__E) -> _getKeyByValue__T: ...
    _getKeysByValue__T = _py_TypeVar('_getKeysByValue__T')  # <T>
    _getKeysByValue__E = _py_TypeVar('_getKeysByValue__E')  # <E>
    @classmethod
    def getKeysByValue(cls, map: java.util.Map[_getKeysByValue__T, _getKeysByValue__E], e: _getKeysByValue__E) -> java.util.Set[_getKeysByValue__T]: ...
    _indexBy__T = _py_TypeVar('_indexBy__T')  # <T>
    @classmethod
    def indexBy(cls, tArray: _py_List[_indexBy__T], string: str, objectArray: _py_List[_py_Any]) -> java.util.Map[str, _indexBy__T]: ...
    _indexByName__T = _py_TypeVar('_indexByName__T')  # <T>
    @classmethod
    def indexByName(cls, tArray: _py_List[_indexByName__T]) -> java.util.Map[str, _indexByName__T]: ...
    _valuesIntersection__K = _py_TypeVar('_valuesIntersection__K')  # <K>
    _valuesIntersection__V = _py_TypeVar('_valuesIntersection__V')  # <V>
    _valuesIntersection__C = _py_TypeVar('_valuesIntersection__C', bound=java.util.Collection)  # <C>
    @classmethod
    def valuesIntersection(cls, map: java.util.Map[_valuesIntersection__K, _valuesIntersection__C]) -> java.util.Set[_valuesIntersection__V]: ...
    class MatchType(java.lang.Enum['MapUtils.MatchType']):
        STARTS_WITH: _py_ClassVar['MapUtils.MatchType'] = ...
        CONTAINS: _py_ClassVar['MapUtils.MatchType'] = ...
        ENDS_WITH: _py_ClassVar['MapUtils.MatchType'] = ...
        REGEXP: _py_ClassVar['MapUtils.MatchType'] = ...
        @classmethod
        @overload
        def valueOf(cls, string: str) -> 'MapUtils.MatchType': ...
        _valueOf_1__T = _py_TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @overload
        def valueOf(cls, class_: _py_Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
        @classmethod
        def values(cls) -> _py_List['MapUtils.MatchType']: ...

class MockitoUtil:
    def __init__(self): ...
    @classmethod
    @overload
    def wireWithMocks(cls, object: _py_Any) -> java.util.Map[str, _py_Any]: ...
    @classmethod
    @overload
    def wireWithMocks(cls, object: _py_Any, class_: _py_Type[_py_Any]) -> java.util.Map[str, _py_Any]: ...

class Named:
    def getName(self) -> str: ...

class Nameds:
    NAMED_MAPPER: _py_ClassVar['Mappers.Mapper'] = ...
    NAMED_COMPARATOR: _py_ClassVar[java.util.Comparator] = ...
    def __init__(self): ...
    _containsByName__T = _py_TypeVar('_containsByName__T', bound=Named)  # <T>
    @classmethod
    def containsByName(cls, collection: java.util.Collection[_containsByName__T], string: str) -> bool: ...
    _filterByNames_0__T = _py_TypeVar('_filterByNames_0__T', bound=Named)  # <T>
    @classmethod
    @overload
    def filterByNames(cls, collection: java.util.Collection[_filterByNames_0__T], collection2: java.util.Collection[str]) -> java.util.Collection[_filterByNames_0__T]: ...
    _filterByNames_1__T = _py_TypeVar('_filterByNames_1__T', bound=Named)  # <T>
    @classmethod
    @overload
    def filterByNames(cls, list: java.util.List[_filterByNames_1__T], collection: java.util.Collection[str]) -> java.util.List[_filterByNames_1__T]: ...
    _filterByNames_2__T = _py_TypeVar('_filterByNames_2__T', bound=Named)  # <T>
    @classmethod
    @overload
    def filterByNames(cls, set: java.util.Set[_filterByNames_2__T], collection: java.util.Collection[str]) -> java.util.Set[_filterByNames_2__T]: ...
    _findByName_0__T = _py_TypeVar('_findByName_0__T', bound=Named)  # <T>
    @classmethod
    @overload
    def findByName(cls, tArray: _py_List[_findByName_0__T], string: str) -> _findByName_0__T: ...
    _findByName_1__T = _py_TypeVar('_findByName_1__T', bound=Named)  # <T>
    @classmethod
    @overload
    def findByName(cls, collection: java.util.Collection[_findByName_1__T], string: str) -> _findByName_1__T: ...
    @classmethod
    @overload
    def getNames(cls, collection: java.util.Collection[Named]) -> java.util.Collection[str]: ...
    @classmethod
    @overload
    def getNames(cls, namedArray: _py_List[Named]) -> java.util.List[str]: ...
    @classmethod
    @overload
    def getNames(cls, list: java.util.List[Named]) -> java.util.List[str]: ...
    @classmethod
    @overload
    def getNames(cls, set: java.util.Set[Named]) -> java.util.Set[str]: ...
    @classmethod
    def getNamesList(cls, collection: java.util.Collection[Named]) -> java.util.List[str]: ...
    @classmethod
    def getNamesSet(cls, collection: java.util.Collection[Named]) -> java.util.Set[str]: ...
    @classmethod
    @overload
    def getSortedNames(cls, collection: java.util.Collection[Named]) -> java.util.Collection[str]: ...
    @classmethod
    @overload
    def getSortedNames(cls, namedArray: _py_List[Named]) -> java.util.List[str]: ...
    @classmethod
    @overload
    def getSortedNames(cls, list: java.util.List[Named]) -> java.util.List[str]: ...
    @classmethod
    @overload
    def getSortedNames(cls, set: java.util.Set[Named]) -> java.util.Set[str]: ...
    _mapByName_0__T = _py_TypeVar('_mapByName_0__T', bound=Named)  # <T>
    @classmethod
    @overload
    def mapByName(cls, tArray: _py_List[_mapByName_0__T]) -> java.util.Map[str, _mapByName_0__T]: ...
    _mapByName_1__T = _py_TypeVar('_mapByName_1__T', bound=Named)  # <T>
    @classmethod
    @overload
    def mapByName(cls, collection: java.util.Collection[_mapByName_1__T]) -> java.util.Map[str, _mapByName_1__T]: ...
    _sortByName_0__T = _py_TypeVar('_sortByName_0__T', bound=Named)  # <T>
    @classmethod
    @overload
    def sortByName(cls, list: java.util.List[_sortByName_0__T]) -> java.util.List[_sortByName_0__T]: ...
    _sortByName_1__T = _py_TypeVar('_sortByName_1__T', bound=Named)  # <T>
    @classmethod
    @overload
    def sortByName(cls, set: java.util.Set[_sortByName_1__T]) -> java.util.Set[_sortByName_1__T]: ...
    _sortByNameToList__T = _py_TypeVar('_sortByNameToList__T', bound=Named)  # <T>
    @classmethod
    def sortByNameToList(cls, collection: java.util.Collection[_sortByNameToList__T]) -> java.util.List[_sortByNameToList__T]: ...
    _sortByNameToSet__T = _py_TypeVar('_sortByNameToSet__T', bound=Named)  # <T>
    @classmethod
    def sortByNameToSet(cls, collection: java.util.Collection[_sortByNameToSet__T]) -> java.util.Set[_sortByNameToSet__T]: ...

class NumberUtils:
    def __init__(self): ...
    @classmethod
    def convertNumberToTargetClass(cls, number: java.lang.Number, class_: _py_Type) -> java.lang.Number: ...
    @classmethod
    @overload
    def parseNumber(cls, string: str, class_: _py_Type) -> java.lang.Number: ...
    @classmethod
    @overload
    def parseNumber(cls, string: str, class_: _py_Type, numberFormat: java.text.NumberFormat) -> java.lang.Number: ...

class OSUtils:
    IS_WINDOWS: _py_ClassVar[bool] = ...
    IS_LINUX: _py_ClassVar[bool] = ...
    def __init__(self): ...

class ObjectUtils:
    def __init__(self): ...
    @classmethod
    def getDisplayString(cls, object: _py_Any) -> str: ...
    @classmethod
    def getIdentityHexString(cls, object: _py_Any) -> str: ...
    @overload
    def hashCode(self) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, boolean: bool) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, double: float) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, float: float) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, long: int) -> int: ...
    @classmethod
    def identityToString(cls, object: _py_Any) -> str: ...
    @classmethod
    def isCheckedException(cls, throwable: java.lang.Throwable) -> bool: ...
    @classmethod
    def isCompatibleWithThrowsClause(cls, throwable: java.lang.Throwable, classArray: _py_List[_py_Type]) -> bool: ...
    @classmethod
    def nullSafeClassName(cls, object: _py_Any) -> str: ...
    @classmethod
    def nullSafeEquals(cls, object: _py_Any, object2: _py_Any) -> bool: ...
    @classmethod
    @overload
    def nullSafeHashCode(cls, booleanArray: _py_List[bool]) -> int: ...
    @classmethod
    @overload
    def nullSafeHashCode(cls, byteArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def nullSafeHashCode(cls, charArray: _py_List[str]) -> int: ...
    @classmethod
    @overload
    def nullSafeHashCode(cls, doubleArray: _py_List[float]) -> int: ...
    @classmethod
    @overload
    def nullSafeHashCode(cls, floatArray: _py_List[float]) -> int: ...
    @classmethod
    @overload
    def nullSafeHashCode(cls, intArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def nullSafeHashCode(cls, object: _py_Any) -> int: ...
    @classmethod
    @overload
    def nullSafeHashCode(cls, objectArray: _py_List[_py_Any]) -> int: ...
    @classmethod
    @overload
    def nullSafeHashCode(cls, longArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def nullSafeHashCode(cls, shortArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def nullSafeToString(cls, booleanArray: _py_List[bool]) -> str: ...
    @classmethod
    @overload
    def nullSafeToString(cls, byteArray: _py_List[int]) -> str: ...
    @classmethod
    @overload
    def nullSafeToString(cls, charArray: _py_List[str]) -> str: ...
    @classmethod
    @overload
    def nullSafeToString(cls, doubleArray: _py_List[float]) -> str: ...
    @classmethod
    @overload
    def nullSafeToString(cls, floatArray: _py_List[float]) -> str: ...
    @classmethod
    @overload
    def nullSafeToString(cls, intArray: _py_List[int]) -> str: ...
    @classmethod
    @overload
    def nullSafeToString(cls, object: _py_Any) -> str: ...
    @classmethod
    @overload
    def nullSafeToString(cls, objectArray: _py_List[_py_Any]) -> str: ...
    @classmethod
    @overload
    def nullSafeToString(cls, longArray: _py_List[int]) -> str: ...
    @classmethod
    @overload
    def nullSafeToString(cls, shortArray: _py_List[int]) -> str: ...

class PcropsRepositoryDownloader:
    def __init__(self): ...
    @classmethod
    def main(cls, stringArray: _py_List[str]) -> None: ...

class PcropsRepositoryJnlpSearcher:
    def __init__(self): ...
    @classmethod
    def main(cls, stringArray: _py_List[str]) -> None: ...

class PcropsRepositoryProductUsageSearcher:
    def __init__(self): ...
    @classmethod
    def main(cls, stringArray: _py_List[str]) -> None: ...

class ProcessUtils:
    def __init__(self): ...
    @classmethod
    def getMyPid(cls) -> int: ...
    @classmethod
    def getMyProcessName(cls) -> str: ...
    @classmethod
    def getMyShortProcessName(cls) -> str: ...

class ProductInfo:
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class ProductVersionSearchOption(java.lang.Enum['ProductVersionSearchOption']):
    VERSION_IGNORED: _py_ClassVar['ProductVersionSearchOption'] = ...
    VERSION_EQUAL_TO_SPECIFIED: _py_ClassVar['ProductVersionSearchOption'] = ...
    VERSION_DIFFERENT_THAN_SPECIFIED: _py_ClassVar['ProductVersionSearchOption'] = ...
    VERSION_GREATER_THAN_SPECIFIED: _py_ClassVar['ProductVersionSearchOption'] = ...
    VERSION_GREATER_OR_EQUAL_THAN_SPECIFIED: _py_ClassVar['ProductVersionSearchOption'] = ...
    VERSION_LOWER_THAN_SPECIFIED: _py_ClassVar['ProductVersionSearchOption'] = ...
    VERSION_LOWER_OR_EQUAL_THAN_SPECIFIED: _py_ClassVar['ProductVersionSearchOption'] = ...
    @classmethod
    @overload
    def valueOf(cls, string: str) -> 'ProductVersionSearchOption': ...
    _valueOf_1__T = _py_TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @overload
    def valueOf(cls, class_: _py_Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @classmethod
    def values(cls) -> _py_List['ProductVersionSearchOption']: ...

class ReflectionUtils:
    COPYABLE_FIELDS: _py_ClassVar['ReflectionUtils.FieldFilter'] = ...
    def __init__(self): ...
    @classmethod
    @overload
    def doWithFields(cls, class_: _py_Type, fieldCallback: 'ReflectionUtils.FieldCallback') -> None: ...
    @classmethod
    @overload
    def doWithFields(cls, class_: _py_Type, fieldCallback: 'ReflectionUtils.FieldCallback', fieldFilter: 'ReflectionUtils.FieldFilter') -> None: ...
    @classmethod
    @overload
    def doWithMethods(cls, class_: _py_Type, methodCallback: 'ReflectionUtils.MethodCallback') -> None: ...
    @classmethod
    @overload
    def doWithMethods(cls, class_: _py_Type, methodCallback: 'ReflectionUtils.MethodCallback', methodFilter: 'ReflectionUtils.MethodFilter') -> None: ...
    @classmethod
    def findAncestors(cls, class_: _py_Type[_py_Any], list: java.util.List[_py_Type[_py_Any]]) -> None: ...
    @classmethod
    def findMethod(cls, class_: _py_Type, string: str, classArray: _py_List[_py_Type]) -> java.lang.reflect.Method: ...
    @classmethod
    def getAllDeclaredMethods(cls, class_: _py_Type) -> _py_List[java.lang.reflect.Method]: ...
    @classmethod
    def getPropertyValue(cls, object: _py_Any, string: str) -> _py_Any: ...
    @classmethod
    def handleInvocationTargetException(cls, invocationTargetException: java.lang.reflect.InvocationTargetException) -> None: ...
    @classmethod
    def handleReflectionException(cls, exception: java.lang.Exception) -> None: ...
    @classmethod
    @overload
    def invokeMethod(cls, method: java.lang.reflect.Method, object: _py_Any) -> _py_Any: ...
    @classmethod
    @overload
    def invokeMethod(cls, method: java.lang.reflect.Method, object: _py_Any, objectArray: _py_List[_py_Any]) -> _py_Any: ...
    @classmethod
    def isFoundOnClassPath(cls, string: str) -> bool: ...
    @classmethod
    def isPublicStaticFinal(cls, field: java.lang.reflect.Field) -> bool: ...
    @classmethod
    def makeAccessible(cls, field: java.lang.reflect.Field) -> None: ...
    @classmethod
    def shallowCopyFieldState(cls, object: _py_Any, object2: _py_Any) -> None: ...
    class FieldCallback:
        def doWith(self, field: java.lang.reflect.Field) -> None: ...
    class FieldFilter:
        def matches(self, field: java.lang.reflect.Field) -> bool: ...
    class MethodCallback:
        def doWith(self, method: java.lang.reflect.Method) -> None: ...
    class MethodFilter:
        def matches(self, method: java.lang.reflect.Method) -> bool: ...

class RepositoryDir:
    @classmethod
    def getRepositoryFile(cls) -> java.io.File: ...
    @classmethod
    def getRepositoryRootDir(cls) -> java.io.File: ...

class ResourceUtils:
    CLASSPATH_URL_PREFIX: _py_ClassVar[str] = ...
    FILE_URL_PREFIX: _py_ClassVar[str] = ...
    URL_PROTOCOL_FILE: _py_ClassVar[str] = ...
    URL_PROTOCOL_JAR: _py_ClassVar[str] = ...
    URL_PROTOCOL_ZIP: _py_ClassVar[str] = ...
    URL_PROTOCOL_WSJAR: _py_ClassVar[str] = ...
    JAR_URL_SEPARATOR: _py_ClassVar[str] = ...
    def __init__(self): ...
    @classmethod
    def extractJarFileURL(cls, uRL: java.net.URL) -> java.net.URL: ...
    @classmethod
    @overload
    def getFile(cls, string: str) -> java.io.File: ...
    @classmethod
    @overload
    def getFile(cls, uRL: java.net.URL) -> java.io.File: ...
    @classmethod
    @overload
    def getFile(cls, uRL: java.net.URL, string: str) -> java.io.File: ...
    @classmethod
    def getURL(cls, string: str) -> java.net.URL: ...
    @classmethod
    def isJarURL(cls, uRL: java.net.URL) -> bool: ...
    @classmethod
    def isUrl(cls, string: str) -> bool: ...

class SearchedProductsDescriptor:
    def toString(self) -> str: ...

class SerializationObjectCloner:
    def __init__(self): ...
    _deepCopy__T = _py_TypeVar('_deepCopy__T', bound=java.io.Serializable)  # <T>
    @classmethod
    def deepCopy(cls, t: _deepCopy__T) -> _deepCopy__T: ...

class StringUtils:
    EMPTY_STRING: _py_ClassVar[str] = ...
    EMPTY_STRING_ARRAY: _py_ClassVar[_py_List[str]] = ...
    EMPTY_STRING_ARRAY2D: _py_ClassVar[_py_List[_py_List[str]]] = ...
    def __init__(self): ...
    @classmethod
    def addStringToArray(cls, stringArray: _py_List[str], string2: str) -> _py_List[str]: ...
    @classmethod
    def applyRelativePath(cls, string: str, string2: str) -> str: ...
    @classmethod
    def arrayToCommaDelimitedString(cls, objectArray: _py_List[_py_Any]) -> str: ...
    @classmethod
    def arrayToDelimitedString(cls, objectArray: _py_List[_py_Any], string: str) -> str: ...
    @classmethod
    def capitalize(cls, string: str) -> str: ...
    @classmethod
    @overload
    def center(cls, string: str, int: int) -> str: ...
    @classmethod
    @overload
    def center(cls, string: str, int: int, char: str) -> str: ...
    @classmethod
    def cleanPath(cls, string: str) -> str: ...
    @classmethod
    def collectionToCommaDelimitedString(cls, collection: java.util.Collection[_py_Any]) -> str: ...
    @classmethod
    @overload
    def collectionToDelimitedString(cls, collection: java.util.Collection[_py_Any], string: str) -> str: ...
    @classmethod
    @overload
    def collectionToDelimitedString(cls, collection: java.util.Collection[_py_Any], string: str, string2: str, string3: str) -> str: ...
    @classmethod
    def commaDelimitedListToSet(cls, string: str) -> java.util.Set[str]: ...
    @classmethod
    def commaDelimitedListToStringArray(cls, string: str) -> _py_List[str]: ...
    @classmethod
    def concatenateStringArrays(cls, stringArray: _py_List[str], stringArray2: _py_List[str]) -> _py_List[str]: ...
    @classmethod
    def containsAnySubstring(cls, string: str, stringArray: _py_List[str]) -> bool: ...
    @classmethod
    def containsWhitespace(cls, string: str) -> bool: ...
    @classmethod
    def countOccurrencesOf(cls, string: str, string2: str) -> int: ...
    @classmethod
    def delete(cls, string: str, string2: str) -> str: ...
    @classmethod
    def deleteAny(cls, string: str, string2: str) -> str: ...
    @classmethod
    def delimitedListToStringArray(cls, string: str, string2: str) -> _py_List[str]: ...
    @classmethod
    def emptyStringToNull(cls, string: str) -> str: ...
    @classmethod
    def endsWithIgnoreCase(cls, string: str, string2: str) -> bool: ...
    @classmethod
    def getFilename(cls, string: str) -> str: ...
    @classmethod
    def getFilenameExtension(cls, string: str) -> str: ...
    @classmethod
    def hasLength(cls, string: str) -> bool: ...
    @classmethod
    def hasText(cls, string: str) -> bool: ...
    @classmethod
    def mergeStringArrays(cls, stringArray: _py_List[str], stringArray2: _py_List[str]) -> _py_List[str]: ...
    @classmethod
    def nullToEmptyString(cls, string: str) -> str: ...
    @classmethod
    def parseLocaleString(cls, string: str) -> java.util.Locale: ...
    @classmethod
    def pathEquals(cls, string: str, string2: str) -> bool: ...
    @classmethod
    def quote(cls, string: str) -> str: ...
    @classmethod
    def quoteIfString(cls, object: _py_Any) -> _py_Any: ...
    @classmethod
    def removeDuplicateStrings(cls, stringArray: _py_List[str]) -> _py_List[str]: ...
    @classmethod
    def repeatChar(cls, char: str, int: int) -> str: ...
    @classmethod
    @overload
    def replace(cls, string: str, string2: str, string3: str) -> str: ...
    @classmethod
    @overload
    def replace(cls, stringBuilder: java.lang.StringBuilder, string2: str, string3: str, boolean: bool) -> None: ...
    @classmethod
    @overload
    def setStringLength(cls, string: str, int: int) -> str: ...
    @classmethod
    @overload
    def setStringLength(cls, string: str, int: int, char: str) -> str: ...
    @classmethod
    def sortStringArray(cls, stringArray: _py_List[str]) -> _py_List[str]: ...
    @classmethod
    def split(cls, string: str, string2: str) -> _py_List[str]: ...
    @classmethod
    @overload
    def splitArrayElementsIntoProperties(cls, stringArray: _py_List[str], string2: str) -> java.util.Properties: ...
    @classmethod
    @overload
    def splitArrayElementsIntoProperties(cls, stringArray: _py_List[str], string2: str, string3: str) -> java.util.Properties: ...
    @classmethod
    def splitHTMLSentence(cls, string: str, int: int) -> str: ...
    @classmethod
    @overload
    def splitSentence(cls, string: str, int: int) -> str: ...
    @classmethod
    @overload
    def splitSentence(cls, string: str, string2: str, int: int) -> str: ...
    @classmethod
    def startsWithIgnoreCase(cls, string: str, string2: str) -> bool: ...
    @classmethod
    def stripFilenameExtension(cls, string: str) -> str: ...
    @classmethod
    @overload
    def toCamelCase(cls, string: str) -> str: ...
    @classmethod
    @overload
    def toCamelCase(cls, string: str, firstLetterCapitalization: 'StringUtils.FirstLetterCapitalization') -> str: ...
    @classmethod
    def toNotNullTrimmedString(cls, string: str) -> str: ...
    @classmethod
    def toStringArray(cls, collection: java.util.Collection[str]) -> _py_List[str]: ...
    @classmethod
    @overload
    def tokenizeToStringArray(cls, string: str, string2: str) -> _py_List[str]: ...
    @classmethod
    @overload
    def tokenizeToStringArray(cls, string: str, string2: str, boolean: bool, boolean2: bool) -> _py_List[str]: ...
    @classmethod
    def trimAllWhitespace(cls, string: str) -> str: ...
    @classmethod
    def trimLeadingWhitespace(cls, string: str) -> str: ...
    @classmethod
    def trimTrailingWhitespace(cls, string: str) -> str: ...
    @classmethod
    @overload
    def trimWhitespace(cls, string: str) -> str: ...
    @classmethod
    @overload
    def trimWhitespace(cls, stringArray: _py_List[str]) -> _py_List[str]: ...
    @classmethod
    def uncapitalize(cls, string: str) -> str: ...
    @classmethod
    def underscoreName(cls, string: str) -> str: ...
    @classmethod
    @overload
    def unqualify(cls, string: str) -> str: ...
    @classmethod
    @overload
    def unqualify(cls, string: str, char: str) -> str: ...
    class FirstLetterCapitalization(java.lang.Enum['StringUtils.FirstLetterCapitalization']):
        CAPITALIZE_FIRST_LETTER: _py_ClassVar['StringUtils.FirstLetterCapitalization'] = ...
        UNCAPITALIZE_FIRST_LETTER: _py_ClassVar['StringUtils.FirstLetterCapitalization'] = ...
        DO_NOT_CHANGE_FIRST_LETTER: _py_ClassVar['StringUtils.FirstLetterCapitalization'] = ...
        @classmethod
        @overload
        def valueOf(cls, string: str) -> 'StringUtils.FirstLetterCapitalization': ...
        _valueOf_1__T = _py_TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @overload
        def valueOf(cls, class_: _py_Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
        @classmethod
        def values(cls) -> _py_List['StringUtils.FirstLetterCapitalization']: ...

class SystemPropertyUtils:
    PLACEHOLDER_PREFIX: _py_ClassVar[str] = ...
    PLACEHOLDER_SUFFIX: _py_ClassVar[str] = ...
    def __init__(self): ...
    @classmethod
    def getBooleanSystemPropertyValue(cls, string: str) -> bool: ...
    @classmethod
    def getProperty(cls, stringArray: _py_List[str], string2: str) -> str: ...
    @classmethod
    def parseBooleanSystemPropertyValue(cls, string: str) -> bool: ...
    @classmethod
    def resolvePlaceholders(cls, string: str) -> str: ...

class Trace:
    @overload
    def dumpMeasurement(self, outputStream: java.io.OutputStream) -> None: ...
    @overload
    def dumpMeasurement(self, string: str, outputStream: java.io.OutputStream) -> None: ...
    @classmethod
    def dumpMeasurements(cls, outputStream: java.io.OutputStream) -> None: ...
    @classmethod
    def getHumanReadableTime(cls, long: int) -> str: ...
    @classmethod
    def getInstance(cls, string: str) -> 'Trace': ...
    def getName(self) -> str: ...
    @classmethod
    def isTraceEnabled(cls) -> bool: ...
    @classmethod
    def printArray(cls, objectArray: _py_List[_py_Any]) -> None: ...
    def printMeasurement(self, boolean: bool, string: str, string2: str, string3: str) -> int: ...
    def printMessage(self, boolean: bool, string: str, string2: str) -> None: ...
    def resetMeasurement(self) -> None: ...
    @classmethod
    def resetMeasurements(cls) -> None: ...
    @classmethod
    def setStringLength(cls, string: str, int: int) -> str: ...
    @classmethod
    def setTraceEnabled(cls, boolean: bool) -> None: ...
    def startMeasurement(self, boolean: bool, string: str, string2: str) -> None: ...

_AbstractImmutableNamed__N = _py_TypeVar('_AbstractImmutableNamed__N', bound=Named)  # <N>
class AbstractImmutableNamed(Named, java.lang.Comparable[_AbstractImmutableNamed__N], _py_Generic[_AbstractImmutableNamed__N]):
    @overload
    def compareTo(self, n: _AbstractImmutableNamed__N) -> int: ...
    @overload
    def compareTo(self, object: _py_Any) -> int: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getName(self) -> str: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

_AbstractImmutableNamedSerializable__N = _py_TypeVar('_AbstractImmutableNamedSerializable__N', bound=Named)  # <N>
class AbstractImmutableNamedSerializable(Named, java.lang.Comparable[_AbstractImmutableNamedSerializable__N], java.io.Serializable, _py_Generic[_AbstractImmutableNamedSerializable__N]):
    @overload
    def compareTo(self, n: _AbstractImmutableNamedSerializable__N) -> int: ...
    @overload
    def compareTo(self, object: _py_Any) -> int: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getName(self) -> str: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

_AbstractNamed__N = _py_TypeVar('_AbstractNamed__N', bound=Named)  # <N>
class AbstractNamed(Named, java.lang.Comparable[_AbstractNamed__N], _py_Generic[_AbstractNamed__N]):
    @overload
    def compareTo(self, n: _AbstractNamed__N) -> int: ...
    @overload
    def compareTo(self, object: _py_Any) -> int: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getName(self) -> str: ...
    def hashCode(self) -> int: ...
    def setName(self, string: str) -> None: ...
    def toString(self) -> str: ...

_AbstractNamedSerializable__N = _py_TypeVar('_AbstractNamedSerializable__N', bound=Named)  # <N>
class AbstractNamedSerializable(Named, java.lang.Comparable[_AbstractNamedSerializable__N], java.io.Serializable, _py_Generic[_AbstractNamedSerializable__N]):
    @overload
    def compareTo(self, n: _AbstractNamedSerializable__N) -> int: ...
    @overload
    def compareTo(self, object: _py_Any) -> int: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getName(self) -> str: ...
    def hashCode(self) -> int: ...
    def setName(self, string: str) -> None: ...
    def toString(self) -> str: ...

_Filters__Filter__T = _py_TypeVar('_Filters__Filter__T')  # <T>
_Filters__FilterSourceAndDestCollectionHolder__T = _py_TypeVar('_Filters__FilterSourceAndDestCollectionHolder__T')  # <T>
_Filters__FilterSourceAndDestCollectionHolder__D = _py_TypeVar('_Filters__FilterSourceAndDestCollectionHolder__D', bound=java.util.Collection)  # <D>
_Filters__FilterSourceCollectionHolder__T = _py_TypeVar('_Filters__FilterSourceCollectionHolder__T')  # <T>
_Filters__FilterSourceCollectionHolder__C = _py_TypeVar('_Filters__FilterSourceCollectionHolder__C', bound=java.util.Collection)  # <C>
_Filters__FilterCollectionHolder__T = _py_TypeVar('_Filters__FilterCollectionHolder__T')  # <T>
_Filters__FilterCollectionHolder__S = _py_TypeVar('_Filters__FilterCollectionHolder__S', bound=java.util.Collection)  # <S>
_Filters__FilterCollectionHolder__D = _py_TypeVar('_Filters__FilterCollectionHolder__D', bound=java.util.Collection)  # <D>
class Filters:
    def __init__(self): ...
    _filter_0__T = _py_TypeVar('_filter_0__T')  # <T>
    @classmethod
    @overload
    def filter(cls, collection: java.util.Collection[_filter_0__T]) -> 'Filters.FilterSourceCollectionHolder'[_filter_0__T, java.util.Collection[_filter_0__T]]: ...
    _filter_1__T = _py_TypeVar('_filter_1__T')  # <T>
    @classmethod
    @overload
    def filter(cls, list: java.util.List[_filter_1__T]) -> 'Filters.FilterSourceCollectionHolder'[_filter_1__T, java.util.List[_filter_1__T]]: ...
    _filter_2__T = _py_TypeVar('_filter_2__T')  # <T>
    @classmethod
    @overload
    def filter(cls, set: java.util.Set[_filter_2__T]) -> 'Filters.FilterSourceCollectionHolder'[_filter_2__T, java.util.Set[_filter_2__T]]: ...
    class Filter(_py_Generic[_Filters__Filter__T]):
        def accepts(self, t: _Filters__Filter__T) -> bool: ...
    class FilterSourceAndDestCollectionHolder(cern.accsoft.commons.util.Filters.FilterCollectionHolder[_Filters__FilterSourceAndDestCollectionHolder__T, java.util.Collection[_Filters__FilterSourceAndDestCollectionHolder__T], _Filters__FilterSourceAndDestCollectionHolder__D], _py_Generic[_Filters__FilterSourceAndDestCollectionHolder__T, _Filters__FilterSourceAndDestCollectionHolder__D]):
        def being(self, filter: 'Filters.Filter') -> java.util.Collection: ...
        def having(self, filter: 'Filters.Filter') -> java.util.Collection: ...
    class FilterSourceCollectionHolder(cern.accsoft.commons.util.Filters.FilterCollectionHolder[_Filters__FilterSourceCollectionHolder__T, _Filters__FilterSourceCollectionHolder__C, _Filters__FilterSourceCollectionHolder__C], _py_Generic[_Filters__FilterSourceCollectionHolder__T, _Filters__FilterSourceCollectionHolder__C]):
        def being(self, filter: 'Filters.Filter') -> java.util.Collection: ...
        def having(self, filter: 'Filters.Filter') -> java.util.Collection: ...
        _to__D = _py_TypeVar('_to__D', bound=java.util.Collection)  # <D>
        def to(self, d: _to__D) -> 'Filters.FilterSourceAndDestCollectionHolder'[_Filters__FilterSourceCollectionHolder__T, _to__D]: ...
    class FilterCollectionHolder(_py_Generic[_Filters__FilterCollectionHolder__T, _Filters__FilterCollectionHolder__S, _Filters__FilterCollectionHolder__D]):
        def being(self, filter: 'Filters.Filter'[_Filters__FilterCollectionHolder__T]) -> _Filters__FilterCollectionHolder__D: ...
        def having(self, filter: 'Filters.Filter'[_Filters__FilterCollectionHolder__T]) -> _Filters__FilterCollectionHolder__D: ...

_Mappers__FlatMapSourceAndDestCollectionHolder__S = _py_TypeVar('_Mappers__FlatMapSourceAndDestCollectionHolder__S')  # <S>
_Mappers__FlatMapSourceAndDestCollectionHolder__D = _py_TypeVar('_Mappers__FlatMapSourceAndDestCollectionHolder__D')  # <D>
_Mappers__FlatMapSourceAndDestCollectionHolder__C = _py_TypeVar('_Mappers__FlatMapSourceAndDestCollectionHolder__C', bound=java.util.Collection)  # <C>
_Mappers__FlatMapSourceCollectionHolder__S = _py_TypeVar('_Mappers__FlatMapSourceCollectionHolder__S')  # <S>
_Mappers__GroupSourceCollectionHolder__S = _py_TypeVar('_Mappers__GroupSourceCollectionHolder__S')  # <S>
_Mappers__GroupSourceCollectionHolder__C = _py_TypeVar('_Mappers__GroupSourceCollectionHolder__C', bound=java.util.Collection)  # <C>
_Mappers__MapBySourceAndDestCollectionHolder__S = _py_TypeVar('_Mappers__MapBySourceAndDestCollectionHolder__S')  # <S>
_Mappers__MapBySourceAndDestCollectionHolder__D = _py_TypeVar('_Mappers__MapBySourceAndDestCollectionHolder__D')  # <D>
_Mappers__MapBySourceAndDestCollectionHolder__M = _py_TypeVar('_Mappers__MapBySourceAndDestCollectionHolder__M', bound=java.util.Map)  # <M>
_Mappers__MapSourceCollectionHolder__S = _py_TypeVar('_Mappers__MapSourceCollectionHolder__S')  # <S>
_Mappers__MapToSourceAndDestCollectionHolder__S = _py_TypeVar('_Mappers__MapToSourceAndDestCollectionHolder__S')  # <S>
_Mappers__MapToSourceAndDestCollectionHolder__D = _py_TypeVar('_Mappers__MapToSourceAndDestCollectionHolder__D')  # <D>
_Mappers__MapToSourceAndDestCollectionHolder__C = _py_TypeVar('_Mappers__MapToSourceAndDestCollectionHolder__C', bound=java.util.Collection)  # <C>
_Mappers__Mapper__S = _py_TypeVar('_Mappers__Mapper__S')  # <S>
_Mappers__Mapper__D = _py_TypeVar('_Mappers__Mapper__D')  # <D>
_Mappers__SourceCollectionHolder__S = _py_TypeVar('_Mappers__SourceCollectionHolder__S')  # <S>
class Mappers:
    def __init__(self): ...
    _flatMap__S = _py_TypeVar('_flatMap__S')  # <S>
    @classmethod
    def flatMap(cls, collection: java.util.Collection[_flatMap__S]) -> 'Mappers.FlatMapSourceCollectionHolder'[_flatMap__S]: ...
    _group_0__S = _py_TypeVar('_group_0__S')  # <S>
    @classmethod
    @overload
    def group(cls, collection: java.util.Collection[_group_0__S]) -> 'Mappers.GroupSourceCollectionHolder'[_group_0__S, java.util.Collection[_group_0__S]]: ...
    _group_1__S = _py_TypeVar('_group_1__S')  # <S>
    @classmethod
    @overload
    def group(cls, list: java.util.List[_group_1__S]) -> 'Mappers.GroupSourceCollectionHolder'[_group_1__S, java.util.List[_group_1__S]]: ...
    _group_2__S = _py_TypeVar('_group_2__S')  # <S>
    @classmethod
    @overload
    def group(cls, set: java.util.Set[_group_2__S]) -> 'Mappers.GroupSourceCollectionHolder'[_group_2__S, java.util.Set[_group_2__S]]: ...
    _map__S = _py_TypeVar('_map__S')  # <S>
    @classmethod
    def map(cls, collection: java.util.Collection[_map__S]) -> 'Mappers.MapSourceCollectionHolder'[_map__S]: ...
    class FlatMapSourceAndDestCollectionHolder(cern.accsoft.commons.util.Mappers.SourceCollectionHolder[_Mappers__FlatMapSourceAndDestCollectionHolder__S], _py_Generic[_Mappers__FlatMapSourceAndDestCollectionHolder__S, _Mappers__FlatMapSourceAndDestCollectionHolder__D, _Mappers__FlatMapSourceAndDestCollectionHolder__C]):
        def of(self, mapper: 'Mappers.Mapper'[_Mappers__FlatMapSourceAndDestCollectionHolder__S, java.util.Collection[_Mappers__FlatMapSourceAndDestCollectionHolder__D]]) -> _Mappers__FlatMapSourceAndDestCollectionHolder__C: ...
    class FlatMapSourceCollectionHolder(cern.accsoft.commons.util.Mappers.SourceCollectionHolder[_Mappers__FlatMapSourceCollectionHolder__S], _py_Generic[_Mappers__FlatMapSourceCollectionHolder__S]):
        _to__D = _py_TypeVar('_to__D')  # <D>
        _to__C = _py_TypeVar('_to__C', bound=java.util.Collection)  # <C>
        def to(self, c: _to__C) -> 'Mappers.FlatMapSourceAndDestCollectionHolder'[_Mappers__FlatMapSourceCollectionHolder__S, _to__D, _to__C]: ...
        _toListOf__D = _py_TypeVar('_toListOf__D')  # <D>
        def toListOf(self, mapper: 'Mappers.Mapper'[_Mappers__FlatMapSourceCollectionHolder__S, java.util.Collection[_toListOf__D]]) -> java.util.List[_toListOf__D]: ...
        _toSetOf__D = _py_TypeVar('_toSetOf__D')  # <D>
        def toSetOf(self, mapper: 'Mappers.Mapper'[_Mappers__FlatMapSourceCollectionHolder__S, java.util.Collection[_toSetOf__D]]) -> java.util.Set[_toSetOf__D]: ...
    class GroupSourceCollectionHolder(_py_Generic[_Mappers__GroupSourceCollectionHolder__S, _Mappers__GroupSourceCollectionHolder__C]):
        _by__D = _py_TypeVar('_by__D')  # <D>
        def by(self, mapper: 'Mappers.Mapper'[_Mappers__GroupSourceCollectionHolder__S, _by__D]) -> java.util.Map[_by__D, _Mappers__GroupSourceCollectionHolder__C]: ...
    class MapBySourceAndDestCollectionHolder(cern.accsoft.commons.util.Mappers.SourceCollectionHolder[_Mappers__MapBySourceAndDestCollectionHolder__S], _py_Generic[_Mappers__MapBySourceAndDestCollectionHolder__S, _Mappers__MapBySourceAndDestCollectionHolder__D, _Mappers__MapBySourceAndDestCollectionHolder__M]):
        def by(self, mapper: 'Mappers.Mapper'[_Mappers__MapBySourceAndDestCollectionHolder__S, _Mappers__MapBySourceAndDestCollectionHolder__D]) -> _Mappers__MapBySourceAndDestCollectionHolder__M: ...
    class MapSourceCollectionHolder(cern.accsoft.commons.util.Mappers.SourceCollectionHolder[_Mappers__MapSourceCollectionHolder__S], _py_Generic[_Mappers__MapSourceCollectionHolder__S]):
        _by__D = _py_TypeVar('_by__D')  # <D>
        def by(self, mapper: 'Mappers.Mapper'[_Mappers__MapSourceCollectionHolder__S, _by__D]) -> java.util.Map[_by__D, _Mappers__MapSourceCollectionHolder__S]: ...
        _to_0__D = _py_TypeVar('_to_0__D')  # <D>
        _to_0__M = _py_TypeVar('_to_0__M', bound=java.util.Map)  # <M>
        @overload
        def to(self, m: _to_0__M) -> 'Mappers.MapBySourceAndDestCollectionHolder'[_Mappers__MapSourceCollectionHolder__S, _to_0__D, _to_0__M]: ...
        _to_1__D = _py_TypeVar('_to_1__D')  # <D>
        _to_1__C = _py_TypeVar('_to_1__C', bound=java.util.Collection)  # <C>
        @overload
        def to(self, c: _to_1__C) -> 'Mappers.MapToSourceAndDestCollectionHolder'[_Mappers__MapSourceCollectionHolder__S, _to_1__D, _to_1__C]: ...
        _toListOf__D = _py_TypeVar('_toListOf__D')  # <D>
        def toListOf(self, mapper: 'Mappers.Mapper'[_Mappers__MapSourceCollectionHolder__S, _toListOf__D]) -> java.util.List[_toListOf__D]: ...
        _toSetOf__D = _py_TypeVar('_toSetOf__D')  # <D>
        def toSetOf(self, mapper: 'Mappers.Mapper'[_Mappers__MapSourceCollectionHolder__S, _toSetOf__D]) -> java.util.Set[_toSetOf__D]: ...
    class MapToSourceAndDestCollectionHolder(cern.accsoft.commons.util.Mappers.SourceCollectionHolder[_Mappers__MapToSourceAndDestCollectionHolder__S], _py_Generic[_Mappers__MapToSourceAndDestCollectionHolder__S, _Mappers__MapToSourceAndDestCollectionHolder__D, _Mappers__MapToSourceAndDestCollectionHolder__C]):
        def of(self, mapper: 'Mappers.Mapper'[_Mappers__MapToSourceAndDestCollectionHolder__S, _Mappers__MapToSourceAndDestCollectionHolder__D]) -> _Mappers__MapToSourceAndDestCollectionHolder__C: ...
    class Mapper(_py_Generic[_Mappers__Mapper__S, _Mappers__Mapper__D]):
        def map(self, s2: _Mappers__Mapper__S) -> _Mappers__Mapper__D: ...
    class SourceCollectionHolder(_py_Generic[_Mappers__SourceCollectionHolder__S]): ...
