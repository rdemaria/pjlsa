import cern.accsoft.commons.util
import cern.accsoft.commons.value
import cern.lsa.domain.settings
import com.google.common.collect
import java.io
import java.lang
import java.time
import java.util
import typing


class BctMarker(cern.accsoft.commons.util.AbstractNamedSerializable['BctMarker']):
    def __init__(self, standAloneContext: cern.lsa.domain.settings.StandAloneContext, string: str, double: float, boolean: bool): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getContext(self) -> cern.lsa.domain.settings.StandAloneContext: ...
    def getName(self) -> str: ...
    def getTime(self) -> float: ...
    def hashCode(self) -> int: ...
    def isEditable(self) -> bool: ...
    def setEditable(self, boolean: bool) -> None: ...
    def setTime(self, double: float) -> None: ...
    def toString(self) -> str: ...

class BctMarkerExistsException(java.lang.RuntimeException):
    def __init__(self, string: str): ...

class FunctionsToReachNewValues:
    @staticmethod
    def builder() -> 'DefaultFunctionsToReachNewValues.Builder': ...
    def getFunction(self, parameter: cern.lsa.domain.settings.Parameter) -> cern.accsoft.commons.value.ImmutableDiscreteFunction: ...
    def getFunctions(self) -> java.util.Map[cern.lsa.domain.settings.Parameter, cern.accsoft.commons.value.ImmutableDiscreteFunction]: ...

class SpsRunType(java.lang.Enum['SpsRunType']):
    LHC_PROTONS: typing.ClassVar['SpsRunType'] = ...
    LHC_IONS: typing.ClassVar['SpsRunType'] = ...
    SFT_PROTONS: typing.ClassVar['SpsRunType'] = ...
    SFT_IONS: typing.ClassVar['SpsRunType'] = ...
    MD_PROTONS: typing.ClassVar['SpsRunType'] = ...
    MD_IONS: typing.ClassVar['SpsRunType'] = ...
    UNDEFINED: typing.ClassVar['SpsRunType'] = ...
    ATTRIBUTE_NAME: typing.ClassVar[str] = ...
    def getAttributeValue(self) -> str: ...
    @staticmethod
    def getSpsRunTypeForAttributeValue(string: str) -> 'SpsRunType': ...
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'SpsRunType': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @staticmethod
    def values() -> typing.List['SpsRunType']: ...

class TimeToReachNewValues:
    def areAllParametersTakenIntoAccount(self) -> bool: ...
    @staticmethod
    def builder() -> 'DefaultTimeToReachNewValues.Builder': ...
    def getDuration(self) -> java.util.Optional[java.time.Duration]: ...
    def getIgnoredParameters(self) -> java.util.Map[cern.lsa.domain.settings.Parameter, 'TimeToReachNewValues.NotCalculatedReason']: ...
    class NotCalculatedReason:
        def getMessage(self) -> str: ...

class DefaultFunctionsToReachNewValues(FunctionsToReachNewValues, java.io.Serializable):
    @staticmethod
    def builder() -> 'DefaultFunctionsToReachNewValues.Builder': ...
    @staticmethod
    def copyOf(functionsToReachNewValues: FunctionsToReachNewValues) -> 'DefaultFunctionsToReachNewValues': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getFunctions(self) -> com.google.common.collect.ImmutableMap[cern.lsa.domain.settings.Parameter, cern.accsoft.commons.value.ImmutableDiscreteFunction]: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...
    def withFunctions(self, map: typing.Union[java.util.Map[cern.lsa.domain.settings.Parameter, cern.accsoft.commons.value.ImmutableDiscreteFunction], typing.Mapping[cern.lsa.domain.settings.Parameter, cern.accsoft.commons.value.ImmutableDiscreteFunction]]) -> 'DefaultFunctionsToReachNewValues': ...
    class Builder:
        def build(self) -> 'DefaultFunctionsToReachNewValues': ...
        def functions(self, map: typing.Union[java.util.Map[cern.lsa.domain.settings.Parameter, cern.accsoft.commons.value.ImmutableDiscreteFunction], typing.Mapping[cern.lsa.domain.settings.Parameter, cern.accsoft.commons.value.ImmutableDiscreteFunction]]) -> 'DefaultFunctionsToReachNewValues.Builder': ...
        def putAllFunctions(self, map: typing.Union[java.util.Map[cern.lsa.domain.settings.Parameter, cern.accsoft.commons.value.ImmutableDiscreteFunction], typing.Mapping[cern.lsa.domain.settings.Parameter, cern.accsoft.commons.value.ImmutableDiscreteFunction]]) -> 'DefaultFunctionsToReachNewValues.Builder': ...
        @typing.overload
        def putFunction(self, parameter: cern.lsa.domain.settings.Parameter, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction) -> 'DefaultFunctionsToReachNewValues.Builder': ...
        @typing.overload
        def putFunction(self, entry: java.util.Map.Entry[cern.lsa.domain.settings.Parameter, cern.accsoft.commons.value.ImmutableDiscreteFunction]) -> 'DefaultFunctionsToReachNewValues.Builder': ...

class DefaultNotCalculatedReason(TimeToReachNewValues.NotCalculatedReason, java.io.Serializable):
    @staticmethod
    def builder() -> 'DefaultNotCalculatedReason.Builder': ...
    @staticmethod
    def copyOf(notCalculatedReason: TimeToReachNewValues.NotCalculatedReason) -> 'DefaultNotCalculatedReason': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getMessage(self) -> str: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def of(string: str) -> 'DefaultNotCalculatedReason': ...
    def toString(self) -> str: ...
    def withMessage(self, string: str) -> 'DefaultNotCalculatedReason': ...
    class Builder:
        def build(self) -> 'DefaultNotCalculatedReason': ...
        def message(self, string: str) -> 'DefaultNotCalculatedReason.Builder': ...

class DefaultTimeToReachNewValues(TimeToReachNewValues, java.io.Serializable):
    @staticmethod
    def builder() -> 'DefaultTimeToReachNewValues.Builder': ...
    @staticmethod
    def copyOf(timeToReachNewValues: TimeToReachNewValues) -> 'DefaultTimeToReachNewValues': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDuration(self) -> java.util.Optional[java.time.Duration]: ...
    def getIgnoredParameters(self) -> com.google.common.collect.ImmutableMap[cern.lsa.domain.settings.Parameter, TimeToReachNewValues.NotCalculatedReason]: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...
    @typing.overload
    def withDuration(self, duration: java.time.Duration) -> 'DefaultTimeToReachNewValues': ...
    @typing.overload
    def withDuration(self, optional: java.util.Optional[java.time.Duration]) -> 'DefaultTimeToReachNewValues': ...
    def withIgnoredParameters(self, map: typing.Union[java.util.Map[cern.lsa.domain.settings.Parameter, TimeToReachNewValues.NotCalculatedReason], typing.Mapping[cern.lsa.domain.settings.Parameter, TimeToReachNewValues.NotCalculatedReason]]) -> 'DefaultTimeToReachNewValues': ...
    class Builder:
        def build(self) -> 'DefaultTimeToReachNewValues': ...
        @typing.overload
        def duration(self, duration: java.time.Duration) -> 'DefaultTimeToReachNewValues.Builder': ...
        @typing.overload
        def duration(self, optional: java.util.Optional[java.time.Duration]) -> 'DefaultTimeToReachNewValues.Builder': ...
        def ignoredParameters(self, map: typing.Union[java.util.Map[cern.lsa.domain.settings.Parameter, TimeToReachNewValues.NotCalculatedReason], typing.Mapping[cern.lsa.domain.settings.Parameter, TimeToReachNewValues.NotCalculatedReason]]) -> 'DefaultTimeToReachNewValues.Builder': ...
        def putAllIgnoredParameters(self, map: typing.Union[java.util.Map[cern.lsa.domain.settings.Parameter, TimeToReachNewValues.NotCalculatedReason], typing.Mapping[cern.lsa.domain.settings.Parameter, TimeToReachNewValues.NotCalculatedReason]]) -> 'DefaultTimeToReachNewValues.Builder': ...
        @typing.overload
        def putIgnoredParameter(self, parameter: cern.lsa.domain.settings.Parameter, notCalculatedReason: TimeToReachNewValues.NotCalculatedReason) -> 'DefaultTimeToReachNewValues.Builder': ...
        @typing.overload
        def putIgnoredParameter(self, entry: java.util.Map.Entry[cern.lsa.domain.settings.Parameter, TimeToReachNewValues.NotCalculatedReason]) -> 'DefaultTimeToReachNewValues.Builder': ...
