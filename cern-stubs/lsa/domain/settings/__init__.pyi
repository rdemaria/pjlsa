import cern
import cern.accsoft.commons.domain
import cern.accsoft.commons.domain.particletransfers
import cern.accsoft.commons.domain.zones
import cern.accsoft.commons.util
import cern.accsoft.commons.util.value
import cern.accsoft.commons.value
import cern.lsa.domain
import cern.lsa.domain.commons
import cern.lsa.domain.devices
import cern.lsa.domain.devices.type
import cern.lsa.domain.exploitation
import cern.lsa.domain.optics
import cern.lsa.domain.settings.factory
import cern.lsa.domain.settings.parameter
import cern.lsa.domain.settings.spi
import cern.lsa.domain.settings.type
import com.google.common.collect
import datetime
import java.io
import java.lang
import java.time
import java.util
import typing



class AcceleratorUser(cern.lsa.domain.commons.IdentifiedEntity, cern.accsoft.commons.util.Named):
    """
    Java class 'cern.lsa.domain.settings.AcceleratorUser'
    
        Interfaces:
            cern.lsa.domain.commons.IdentifiedEntity,
            cern.accsoft.commons.util.Named
    
    """
    @staticmethod
    def builder() -> 'DefaultAcceleratorUser.Builder': ...
    def getAccelerator(self) -> cern.accsoft.commons.domain.Accelerator: ...
    def getAcceleratorUserGroup(self) -> 'AcceleratorUserGroup': ...
    def isMultiplexed(self) -> bool: ...

class AcceleratorUserGroup(cern.lsa.domain.commons.IdentifiedEntity, cern.accsoft.commons.util.Named):
    """
    Java class 'cern.lsa.domain.settings.AcceleratorUserGroup'
    
        Interfaces:
            cern.lsa.domain.commons.IdentifiedEntity,
            cern.accsoft.commons.util.Named
    
    """
    @staticmethod
    def builder() -> 'DefaultAcceleratorUserGroup.Builder': ...
    def getDescription(self) -> str: ...

class AcceleratorUsersRequest:
    """
    Java class 'cern.lsa.domain.settings.AcceleratorUsersRequest'
    
    """
    @staticmethod
    def builder() -> 'DefaultAcceleratorUsersRequest.Builder': ...
    @staticmethod
    def byAccelerator(accelerator: cern.accsoft.commons.domain.Accelerator) -> 'AcceleratorUsersRequest': ...
    @staticmethod
    def byAcceleratorAndUserName(accelerator: cern.accsoft.commons.domain.Accelerator, string: str) -> 'AcceleratorUsersRequest': ...
    @staticmethod
    def byUserName(string: str) -> 'AcceleratorUsersRequest': ...
    @staticmethod
    def byUserNames(iterable: java.lang.Iterable[str]) -> 'AcceleratorUsersRequest': ...
    def getAccelerator(self) -> cern.accsoft.commons.domain.Accelerator: ...
    def getAcceleratorUserGroupName(self) -> str: ...
    def getAcceleratorUserNames(self) -> java.util.Set[str]: ...
    def getIds(self) -> java.util.Set[int]: ...
    def isMultiplexed(self) -> bool: ...

class ActualBeamProcessInfo:
    """
    Java class 'cern.lsa.domain.settings.ActualBeamProcessInfo'
    
    """
    def getSourceBeamProcess(self) -> 'BeamProcess': ...
    def getSourcePoint(self) -> int: ...

class Archive(cern.lsa.domain.commons.IdentifiedEntity, cern.accsoft.commons.util.Named, java.lang.Comparable['Archive']):
    """
    Java class 'cern.lsa.domain.settings.Archive'
    
        Interfaces:
            cern.lsa.domain.commons.IdentifiedEntity,
            cern.accsoft.commons.util.Named, java.lang.Comparable
    
    """
    def getLatestVersion(self) -> 'ArchiveVersion': ...
    def getStandAloneContext(self) -> 'StandAloneContext': ...
    def getVersion(self, double: float) -> 'ArchiveVersion': ...
    def getVersions(self) -> java.util.SortedSet['ArchiveVersion']: ...

class ArchiveVersion(java.lang.Comparable['ArchiveVersion']):
    """
    Java class 'cern.lsa.domain.settings.ArchiveVersion'
    
        Interfaces:
            java.lang.Comparable
    
    """
    def getArchive(self) -> Archive: ...
    def getCreationDate(self) -> java.util.Date: ...
    def getDescription(self) -> str: ...
    def getSettingCount(self) -> int: ...
    def getVersion(self) -> float: ...

class BeamProcessIncorporationRequest:
    """
    Java class 'cern.lsa.domain.settings.BeamProcessIncorporationRequest'
    
    """
    def getDescription(self) -> str: ...
    def getDestBeamProcess(self) -> 'BeamProcess': ...
    def getDestPointInTime(self) -> float: ...
    def getParameters(self) -> java.util.Set['Parameter']: ...
    def getSettingPart(self) -> 'SettingPartEnum': ...
    def getSettingsSource(self) -> 'SettingsSource': ...
    def getSourceBeamProcess(self) -> 'BeamProcess': ...
    def getSourcePointInTime(self) -> float: ...
    def shouldDrive(self) -> bool: ...
    def shouldIncorporateAllParameters(self) -> bool: ...

class BeamProcessIntersection:
    """
    Java class 'cern.lsa.domain.settings.BeamProcessIntersection'
    
    """
    def getBeamProcess(self) -> 'BeamProcess': ...
    def getIntersectionCoordinate(self) -> float: ...

class CompositeContextSettings:
    """
    Java class 'cern.lsa.domain.settings.CompositeContextSettings'
    
    """
    def getContextSettings(self) -> 'ContextSettings': ...
    def getNonMultiplexedSettings(self) -> 'ContextSettings': ...
    def getParameters(self) -> java.util.Set['Parameter']: ...
    def getValue(self, drivableContext: 'DrivableContext', string: str) -> cern.accsoft.commons.value.ImmutableValue: ...

class Context(cern.lsa.domain.commons.IdentifiedEntity, cern.accsoft.commons.util.Named, java.lang.Comparable['Context']):
    """
    Java class 'cern.lsa.domain.settings.Context'
    
        Interfaces:
            cern.lsa.domain.commons.IdentifiedEntity,
            cern.accsoft.commons.util.Named, java.lang.Comparable
    
    """
    def getAccelerator(self) -> cern.accsoft.commons.domain.Accelerator: ...
    def getContextFamily(self) -> 'ContextFamily': ...
    def getCreationDate(self) -> java.util.Date: ...
    def getCreatorName(self) -> str: ...
    def getDescription(self) -> str: ...
    def getLength(self) -> int: ...
    def getModificationDate(self) -> java.util.Date: ...
    def getModifierName(self) -> str: ...
    def getParent(self) -> 'Context': ...
    def getTypeName(self) -> str: ...
    def isMultiplexed(self) -> bool: ...
    def isStandAlone(self) -> bool: ...

class ContextCategory(cern.accsoft.commons.util.Named):
    """
    Java class 'cern.lsa.domain.settings.ContextCategory'
    
        Interfaces:
            cern.accsoft.commons.util.Named
    
    """
    def isArchived(self) -> bool: ...

class ContextFamily(java.lang.Enum['ContextFamily']):
    """
    Java class 'cern.lsa.domain.settings.ContextFamily'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        CYCLE (cern.lsa.domain.settings.ContextFamily): final static enum constant
        BEAMPROCESS (cern.lsa.domain.settings.ContextFamily): final static enum constant
        BEAM_PRODUCTION_CHAIN (cern.lsa.domain.settings.ContextFamily): final static enum constant
        PATTERN (cern.lsa.domain.settings.ContextFamily): final static enum constant
    
    """
    CYCLE: typing.ClassVar['ContextFamily'] = ...
    BEAMPROCESS: typing.ClassVar['ContextFamily'] = ...
    BEAM_PRODUCTION_CHAIN: typing.ClassVar['ContextFamily'] = ...
    PATTERN: typing.ClassVar['ContextFamily'] = ...
    @staticmethod
    def getContextFamily(string: str) -> 'ContextFamily': ...
    def getDisplayName(self) -> str: ...
    def getShortName(self) -> str: ...
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'ContextFamily': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @staticmethod
    def values() -> typing.List['ContextFamily']: ...

class ContextIntersections:
    """
    Java class 'cern.lsa.domain.settings.ContextIntersections'
    
    """
    def getCycleBeamProcessIntersections(self) -> java.util.SortedSet['CycleBeamProcessIntersection']: ...

class ContextOptics:
    """
    Java class 'cern.lsa.domain.settings.ContextOptics'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ContextOptics(cern.lsa.domain.settings.StandAloneContext, java.util.Collection)
    
    """
    def __init__(self, standAloneContext: 'StandAloneContext', collection: typing.Union[java.util.Collection[cern.lsa.domain.optics.OpticsTable], typing.Sequence[cern.lsa.domain.optics.OpticsTable]]): ...
    def getActiveOpticName(self, particleTransfer: cern.accsoft.commons.domain.particletransfers.ParticleTransfer, int: int) -> str: ...
    def getBeamProcessOpticsTable(self, beamProcess: 'BeamProcess') -> cern.lsa.domain.optics.OpticsTable: ...
    def getContext(self) -> 'StandAloneContext': ...
    def getContextName(self) -> str: ...

class ContextSettings:
    """
    Java class 'cern.lsa.domain.settings.ContextSettings'
    
    """
    def addAll(self, contextSettings: 'ContextSettings') -> None: ...
    def getContext(self) -> 'StandAloneContext': ...
    def getCurrentBeamProcesses(self) -> java.util.Set['BeamProcess']: ...
    @typing.overload
    def getCurrentSetting(self, beamProcess: 'BeamProcess', parameter: 'Parameter') -> 'Setting': ...
    @typing.overload
    def getCurrentSetting(self, beamProcess: 'BeamProcess', string: str) -> 'Setting': ...
    def getCurrentSettings(self) -> java.util.Set['Setting']: ...
    @typing.overload
    def getParameterSettings(self, parameter: 'Parameter') -> 'ParameterSettings': ...
    @typing.overload
    def getParameterSettings(self, string: str) -> 'ParameterSettings': ...
    def getParameters(self) -> java.util.Set['Parameter']: ...
    @typing.overload
    def getSetting(self, beamProcess: 'BeamProcess', parameter: 'Parameter') -> 'Setting': ...
    @typing.overload
    def getSetting(self, beamProcess: 'BeamProcess', string: str) -> 'Setting': ...
    def getSettings(self) -> java.util.Set['Setting']: ...
    def getUpdatedBeamProcesses(self) -> java.util.Set['BeamProcess']: ...
    def getUpdatedParameters(self) -> java.util.Set['Parameter']: ...
    @typing.overload
    def getUpdatedSetting(self, beamProcess: 'BeamProcess', parameter: 'Parameter') -> 'Setting': ...
    @typing.overload
    def getUpdatedSetting(self, beamProcess: 'BeamProcess', string: str) -> 'Setting': ...
    def getUpdatedSettings(self) -> java.util.Set['Setting']: ...
    def isEmpty(self) -> bool: ...
    @typing.overload
    def isUpdated(self, beamProcess: 'BeamProcess', parameter: 'Parameter') -> bool: ...
    @typing.overload
    def isUpdated(self, beamProcess: 'BeamProcess', string: str) -> bool: ...
    @typing.overload
    def isUpdated(self, parameter: 'Parameter') -> bool: ...
    @typing.overload
    def isUpdated(self, string: str) -> bool: ...
    def round(self) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def updateSetting(self, beamProcess: 'BeamProcess', parameter: 'Parameter', immutableValue: cern.accsoft.commons.value.ImmutableValue, settingPartEnum: 'SettingPartEnum') -> None: ...
    @typing.overload
    def updateSetting(self, beamProcess: 'BeamProcess', string: str, immutableValue: cern.accsoft.commons.value.ImmutableValue, settingPartEnum: 'SettingPartEnum') -> None: ...

class ContextSettingsRequest(java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.ContextSettingsRequest'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
    """
    @staticmethod
    def builder() -> 'ContextSettingsRequestBuilder': ...
    @staticmethod
    def byStandAloneContext(standAloneContext: 'StandAloneContext') -> 'ContextSettingsRequest': ...
    @staticmethod
    def byStandAloneContextAndAtInstant(standAloneContext: 'StandAloneContext', instant: typing.Union[java.time.Instant, datetime.datetime]) -> 'ContextSettingsRequest': ...
    @staticmethod
    def byStandAloneContextAndParameters(standAloneContext: 'StandAloneContext', collection: typing.Union[java.util.Collection['Parameter'], typing.Sequence['Parameter']]) -> 'ContextSettingsRequest': ...
    def getAtTimestamp(self) -> java.time.Instant: ...
    def getContext(self) -> 'StandAloneContext': ...
    def getParameters(self) -> java.util.Collection['Parameter']: ...

class ContextSettingsRequestBuilder:
    """
    Java class 'cern.lsa.domain.settings.ContextSettingsRequestBuilder'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ContextSettingsRequestBuilder()
    
    """
    def __init__(self): ...
    def at(self, instant: typing.Union[java.time.Instant, datetime.datetime]) -> 'ContextSettingsRequestBuilder': ...
    def build(self) -> ContextSettingsRequest: ...
    @staticmethod
    def byStandAloneContext(standAloneContext: 'StandAloneContext') -> ContextSettingsRequest: ...
    @staticmethod
    def byStandAloneContextAndAtInstant(standAloneContext: 'StandAloneContext', instant: typing.Union[java.time.Instant, datetime.datetime]) -> ContextSettingsRequest: ...
    @staticmethod
    def byStandAloneContextAndParameters(standAloneContext: 'StandAloneContext', collection: typing.Union[java.util.Collection['Parameter'], typing.Sequence['Parameter']]) -> ContextSettingsRequest: ...
    def parameters(self, collection: typing.Union[java.util.Collection['Parameter'], typing.Sequence['Parameter']]) -> 'ContextSettingsRequestBuilder': ...
    def standAloneContext(self, standAloneContext: 'StandAloneContext') -> 'ContextSettingsRequestBuilder': ...

class ContextTypeFilter(cern.accsoft.commons.util.Filters.Filter[cern.lsa.domain.settings.type.ContextType]):
    """
    Java class 'cern.lsa.domain.settings.ContextTypeFilter'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.accsoft.commons.util.Filters.Filter
    
      Constructors:
        * ContextTypeFilter()
    
    """
    def __init__(self): ...
    def accepts(self, contextType: cern.lsa.domain.settings.type.ContextType) -> bool: ...
    @staticmethod
    def categoryIn(collection: typing.Union[java.util.Collection[ContextCategory], typing.Sequence[ContextCategory]]) -> 'ContextTypeFilter': ...
    def setCategories(self, collection: typing.Union[java.util.Collection[ContextCategory], typing.Sequence[ContextCategory]]) -> 'ContextTypeFilter': ...

class ContextTypes:
    """
    Java class 'cern.lsa.domain.settings.ContextTypes'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ContextTypes()
    
      Attributes:
        CATEGORIES (cern.accsoft.commons.util.Mappers$Mapper): final static field
    
    """
    CATEGORIES: typing.ClassVar[cern.accsoft.commons.util.Mappers.Mapper] = ...
    def __init__(self): ...
    _getCategories__T = typing.TypeVar('_getCategories__T', bound=cern.lsa.domain.settings.type.ContextType)  # <T>
    @staticmethod
    def getCategories(collection: typing.Union[java.util.Collection[_getCategories__T], typing.Sequence[_getCategories__T]]) -> java.util.Set[ContextCategory]: ...

class Contexts:
    """
    Java class 'cern.lsa.domain.settings.Contexts'
    
        Extends:
            java.lang.Object
    
      Attributes:
        PARTICLE_TRANSFERS (cern.accsoft.commons.util.Mappers$Mapper): final static field
        CATEGORIES (cern.accsoft.commons.util.Mappers$Mapper): final static field
        SUBCONTEXT_START_TIME_COMPARATOR (java.util.Comparator): final static field
    
    """
    PARTICLE_TRANSFERS: typing.ClassVar[cern.accsoft.commons.util.Mappers.Mapper] = ...
    CATEGORIES: typing.ClassVar[cern.accsoft.commons.util.Mappers.Mapper] = ...
    SUBCONTEXT_START_TIME_COMPARATOR: typing.ClassVar[java.util.Comparator] = ...
    @staticmethod
    def areResident(collection: typing.Union[java.util.Collection['DrivableContext'], typing.Sequence['DrivableContext']]) -> bool: ...
    @staticmethod
    def assertContextIsNonArchived(standAloneContext: 'StandAloneContext') -> None: ...
    @staticmethod
    def assertContextsAreNonArchived(collection: typing.Union[java.util.Collection['StandAloneContext'], typing.Sequence['StandAloneContext']]) -> None: ...
    @staticmethod
    def assertContextsBelongToSameStandAloneContext(collection: typing.Union[java.util.Collection[Context], typing.Sequence[Context]]) -> None: ...
    @staticmethod
    def belongSameStandAloneContext(collection: typing.Union[java.util.Collection[Context], typing.Sequence[Context]]) -> bool: ...
    @staticmethod
    def canBecomeResident(standAloneBeamProcess: 'StandAloneBeamProcess', hyperCycle: 'HyperCycle') -> bool: ...
    @staticmethod
    def cloneStandAloneContext(standAloneContext: 'StandAloneContext') -> 'StandAloneContext': ...
    @staticmethod
    def contains(context: Context, int: int) -> bool: ...
    @staticmethod
    def containsSegmentWithName(beamProcessType: cern.lsa.domain.settings.type.BeamProcessType, string: str) -> bool: ...
    @staticmethod
    def createActualBeamProcessName(beamProcess: 'BeamProcess', int: int) -> str: ...
    _filterBeamProcesses_2__T = typing.TypeVar('_filterBeamProcesses_2__T', bound='BeamProcess')  # <T>
    _filterBeamProcesses_3__T = typing.TypeVar('_filterBeamProcesses_3__T', bound='BeamProcess')  # <T>
    @typing.overload
    @staticmethod
    def filterBeamProcesses(standAloneContext: 'StandAloneContext', particleTransfer: cern.accsoft.commons.domain.particletransfers.ParticleTransfer, beamProcessTypeCategoryArray: typing.List[cern.lsa.domain.settings.type.BeamProcessTypeCategory]) -> java.util.List['BeamProcess']: ...
    @typing.overload
    @staticmethod
    def filterBeamProcesses(standAloneContext: 'StandAloneContext', particleTransfer: cern.accsoft.commons.domain.particletransfers.ParticleTransfer, collection: typing.Union[java.util.Collection[cern.lsa.domain.settings.type.BeamProcessTypeCategory], typing.Sequence[cern.lsa.domain.settings.type.BeamProcessTypeCategory]]) -> java.util.List['BeamProcess']: ...
    @typing.overload
    @staticmethod
    def filterBeamProcesses(collection: typing.Union[java.util.Collection[_filterBeamProcesses_2__T], typing.Sequence[_filterBeamProcesses_2__T]], particleTransfer: cern.accsoft.commons.domain.particletransfers.ParticleTransfer, beamProcessTypeCategoryArray: typing.List[cern.lsa.domain.settings.type.BeamProcessTypeCategory]) -> java.util.List[_filterBeamProcesses_2__T]: ...
    @typing.overload
    @staticmethod
    def filterBeamProcesses(collection: typing.Union[java.util.Collection[_filterBeamProcesses_3__T], typing.Sequence[_filterBeamProcesses_3__T]], particleTransfer: cern.accsoft.commons.domain.particletransfers.ParticleTransfer, collection2: typing.Union[java.util.Collection[cern.lsa.domain.settings.type.BeamProcessTypeCategory], typing.Sequence[cern.lsa.domain.settings.type.BeamProcessTypeCategory]]) -> java.util.List[_filterBeamProcesses_3__T]: ...
    _filterBeamProcessesByParticleTransfers__T = typing.TypeVar('_filterBeamProcessesByParticleTransfers__T', bound='BeamProcess')  # <T>
    @staticmethod
    def filterBeamProcessesByParticleTransfers(collection: typing.Union[java.util.Collection[_filterBeamProcessesByParticleTransfers__T], typing.Sequence[_filterBeamProcessesByParticleTransfers__T]], collection2: typing.Union[java.util.Collection[cern.accsoft.commons.domain.particletransfers.ParticleTransfer], typing.Sequence[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]]) -> java.util.List[_filterBeamProcessesByParticleTransfers__T]: ...
    _filterByCategories__T = typing.TypeVar('_filterByCategories__T', bound='StandAloneContext')  # <T>
    @staticmethod
    def filterByCategories(collection: typing.Union[java.util.Collection[_filterByCategories__T], typing.Sequence[_filterByCategories__T]], contextCategoryArray: typing.List[ContextCategory]) -> java.util.List[_filterByCategories__T]: ...
    _filterByMultiplexingCriteria__T = typing.TypeVar('_filterByMultiplexingCriteria__T', bound='StandAloneContext')  # <T>
    @staticmethod
    def filterByMultiplexingCriteria(collection: typing.Union[java.util.Collection[_filterByMultiplexingCriteria__T], typing.Sequence[_filterByMultiplexingCriteria__T]], boolean: bool) -> java.util.List[_filterByMultiplexingCriteria__T]: ...
    _filterCompatibleBeamProcesses__T = typing.TypeVar('_filterCompatibleBeamProcesses__T', bound='BeamProcess')  # <T>
    @staticmethod
    def filterCompatibleBeamProcesses(collection: typing.Union[java.util.Collection[_filterCompatibleBeamProcesses__T], typing.Sequence[_filterCompatibleBeamProcesses__T]], parameter: 'Parameter') -> java.util.List[_filterCompatibleBeamProcesses__T]: ...
    _filterDrivableContextsByUsers__T = typing.TypeVar('_filterDrivableContextsByUsers__T', bound='DrivableContext')  # <T>
    @staticmethod
    def filterDrivableContextsByUsers(collection: typing.Union[java.util.Collection[_filterDrivableContextsByUsers__T], typing.Sequence[_filterDrivableContextsByUsers__T]], collection2: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> java.util.Set[_filterDrivableContextsByUsers__T]: ...
    @staticmethod
    def filterFunctionBeamProcesses(standAloneContext: 'StandAloneContext', particleTransfer: cern.accsoft.commons.domain.particletransfers.ParticleTransfer) -> java.util.List['BeamProcess']: ...
    _filterResidentContexts__T = typing.TypeVar('_filterResidentContexts__T', bound='StandAloneContext')  # <T>
    @staticmethod
    def filterResidentContexts(collection: typing.Union[java.util.Collection[_filterResidentContexts__T], typing.Sequence[_filterResidentContexts__T]], boolean: bool) -> java.util.List[_filterResidentContexts__T]: ...
    _filterStandAloneContextsByClass__T = typing.TypeVar('_filterStandAloneContextsByClass__T', bound='StandAloneContext')  # <T>
    @staticmethod
    def filterStandAloneContextsByClass(collection: typing.Union[java.util.Collection['StandAloneContext'], typing.Sequence['StandAloneContext']], class_: typing.Type[_filterStandAloneContextsByClass__T]) -> java.util.Set['StandAloneContext']: ...
    @staticmethod
    def getBeamProcessTypeCategories(collection: typing.Union[java.util.Collection['BeamProcess'], typing.Sequence['BeamProcess']]) -> java.util.Set[cern.lsa.domain.settings.type.BeamProcessTypeCategory]: ...
    @typing.overload
    @staticmethod
    def getBeamProcesses(standAloneContext: 'StandAloneContext', collection: typing.Union[java.util.Collection['SubContext'], typing.Sequence['SubContext']]) -> java.util.List['BeamProcess']: ...
    @typing.overload
    @staticmethod
    def getBeamProcesses(collection: typing.Union[java.util.Collection['DrivableContext'], typing.Sequence['DrivableContext']]) -> java.util.List['BeamProcess']: ...
    @staticmethod
    def getBeamProcessesAt(standAloneContext: 'StandAloneContext', collection: typing.Union[java.util.Collection[cern.accsoft.commons.domain.particletransfers.ParticleTransfer], typing.Sequence[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]], double: float) -> java.util.List['BeamProcess']: ...
    _getCategories__T = typing.TypeVar('_getCategories__T', bound='StandAloneContext')  # <T>
    @staticmethod
    def getCategories(collection: typing.Union[java.util.Collection[_getCategories__T], typing.Sequence[_getCategories__T]]) -> java.util.Set[ContextCategory]: ...
    @staticmethod
    def getCompatibleBeamProcess(standAloneContext: 'StandAloneContext', parameter: 'Parameter') -> 'BeamProcess': ...
    @staticmethod
    def getCompatibleBeamProcesses(standAloneContext: 'StandAloneContext', parameter: 'Parameter') -> java.util.Set['BeamProcess']: ...
    @staticmethod
    def getCorrespondingBeamProcess(beamProcess: 'BeamProcess', parameter: 'Parameter') -> 'BeamProcess': ...
    @staticmethod
    def getCorrespondingBeamProcesses(beamProcess: 'BeamProcess', parameter: 'Parameter') -> java.util.List['BeamProcess']: ...
    @staticmethod
    def getCycle(beamProcess: 'BeamProcess') -> 'Cycle': ...
    @staticmethod
    def getDrivableContext(context: Context) -> 'DrivableContext': ...
    @typing.overload
    @staticmethod
    def getDrivableContextByUser(standAloneContext: 'StandAloneContext', string: str) -> 'DrivableContext': ...
    @typing.overload
    @staticmethod
    def getDrivableContextByUser(collection: typing.Union[java.util.Collection['StandAloneContext'], typing.Sequence['StandAloneContext']], string: str) -> 'DrivableContext': ...
    @typing.overload
    @staticmethod
    def getDrivableContexts(context: Context) -> java.util.Set['DrivableContext']: ...
    @typing.overload
    @staticmethod
    def getDrivableContexts(collection: typing.Union[java.util.Collection[Context], typing.Sequence[Context]]) -> java.util.Set['DrivableContext']: ...
    @staticmethod
    def getDrivableContextsByUsers(collection: typing.Union[java.util.Collection['StandAloneContext'], typing.Sequence['StandAloneContext']], collection2: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> java.util.Set['DrivableContext']: ...
    @staticmethod
    def getFollowingBeamProcess(beamProcess: 'BeamProcess') -> 'BeamProcess': ...
    @staticmethod
    def getFunctionBeamProcessAt(standAloneContext: 'StandAloneContext', particleTransfer: cern.accsoft.commons.domain.particletransfers.ParticleTransfer, double: float) -> 'BeamProcess': ...
    @typing.overload
    @staticmethod
    def getIntersectedBeamProcesses(beamProcess: 'BeamProcess', collection: typing.Union[java.util.Collection[cern.accsoft.commons.domain.particletransfers.ParticleTransfer], typing.Sequence[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]], beamProcessTypeCategoryArray: typing.List[cern.lsa.domain.settings.type.BeamProcessTypeCategory]) -> java.util.List['BeamProcess']: ...
    @typing.overload
    @staticmethod
    def getIntersectedBeamProcesses(context: Context) -> java.util.Set['BeamProcess']: ...
    @typing.overload
    @staticmethod
    def getIntersectedBeamProcesses(collection: typing.Union[java.util.Collection[Context], typing.Sequence[Context]]) -> java.util.Set['BeamProcess']: ...
    @staticmethod
    def getIntersectedCycles(collection: typing.Union[java.util.Collection['BeamProcess'], typing.Sequence['BeamProcess']]) -> java.util.Set['Cycle']: ...
    @staticmethod
    def getParticleTransfers(collection: typing.Union[java.util.Collection['StandAloneContext'], typing.Sequence['StandAloneContext']]) -> java.util.Set[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]: ...
    @staticmethod
    def getParticleTransfersFromBeamProcesses(collection: typing.Union[java.util.Collection['BeamProcess'], typing.Sequence['BeamProcess']]) -> java.util.Set[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]: ...
    @staticmethod
    def getPrecedingBeamProcess(beamProcess: 'BeamProcess') -> 'BeamProcess': ...
    @staticmethod
    def getStandAloneContext(context: Context) -> 'StandAloneContext': ...
    @staticmethod
    def getStandAloneContexts(collection: typing.Union[java.util.Collection[Context], typing.Sequence[Context]]) -> java.util.Set['StandAloneContext']: ...
    @staticmethod
    def getTypeNames(collection: typing.Union[java.util.Collection[Context], typing.Sequence[Context]]) -> java.util.Set[str]: ...
    @staticmethod
    def getUsers(standAloneContext: 'StandAloneContext') -> java.util.Set[str]: ...
    @staticmethod
    def getUsersForContexts(collection: typing.Union[java.util.Collection[Context], typing.Sequence[Context]]) -> java.util.List[str]: ...
    @staticmethod
    def isActual(beamProcess: 'BeamProcess') -> bool: ...
    @staticmethod
    def isActualBeamProcess(context: Context) -> bool: ...
    @staticmethod
    def isCompatible(beamProcess: 'BeamProcess', parameter: 'Parameter') -> bool: ...
    @staticmethod
    def isLastPoint(context: Context, int: int) -> bool: ...
    _sortByStartTime__T = typing.TypeVar('_sortByStartTime__T', bound='SubContext')  # <T>
    @staticmethod
    def sortByStartTime(list: java.util.List[_sortByStartTime__T]) -> None: ...

class CycleBeamProcessIntersection:
    """
    Java class 'cern.lsa.domain.settings.CycleBeamProcessIntersection'
    
    """
    def getBeamProcess(self) -> 'BeamProcess': ...
    def getCycle(self) -> 'Cycle': ...
    def getEndInBeamProcess(self) -> int: ...
    def getEndInCycle(self) -> int: ...
    def getParticleTransfer(self) -> cern.accsoft.commons.domain.particletransfers.ParticleTransfer: ...
    def getStartInBeamProcess(self) -> int: ...
    def getStartInCycle(self) -> int: ...

class DevicePropertyParameters:
    """
    Java class 'cern.lsa.domain.settings.DevicePropertyParameters'
    
    """
    def getDeviceClassName(self) -> str: ...
    def getDeviceName(self) -> str: ...
    def getDevicePropertyName(self) -> str: ...
    @typing.overload
    def getFieldNames(self) -> java.util.SortedSet[str]: ...
    @typing.overload
    def getFieldNames(self, boolean: bool) -> java.util.SortedSet[str]: ...
    @typing.overload
    def getParameters(self) -> java.util.SortedSet['Parameter']: ...
    @typing.overload
    def getParameters(self, boolean: bool) -> java.util.SortedSet['Parameter']: ...
    def getPropertyName(self) -> str: ...
    def getSignature(self) -> 'Parameter': ...
    def isCritical(self) -> bool: ...

class ErrorsAwareContextSettings:
    """
    Java class 'cern.lsa.domain.settings.ErrorsAwareContextSettings'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ErrorsAwareContextSettings(cern.lsa.domain.settings.ContextSettings)
        * ErrorsAwareContextSettings(cern.lsa.domain.settings.ContextSettings, java.util.Map)
    
    """
    @typing.overload
    def __init__(self, contextSettings: ContextSettings): ...
    @typing.overload
    def __init__(self, contextSettings: ContextSettings, map: typing.Union[java.util.Map['Parameter', java.lang.Exception], typing.Mapping['Parameter', java.lang.Exception]]): ...
    def getContextSettings(self) -> ContextSettings: ...
    def getParameter2Exception(self) -> java.util.Map['Parameter', java.lang.Exception]: ...

class FailedParametersStatus:
    """
    Java class 'cern.lsa.domain.settings.FailedParametersStatus'
    
    """
    def containsFailedParameters(self) -> bool: ...
    def getFailedContexts(self) -> java.util.Set[Context]: ...
    def getFailedParameters(self, context: Context) -> java.util.Map[str, java.lang.Exception]: ...

class GenerationException(cern.lsa.domain.LsaException):
    """
    Java class 'cern.lsa.domain.settings.GenerationException'
    
        Extends:
            cern.lsa.domain.LsaException
    
      Constructors:
        * GenerationException(java.lang.String)
        * GenerationException(java.lang.Exception)
        * GenerationException(java.lang.String, java.lang.Exception)
    
    """
    @typing.overload
    def __init__(self, exception: java.lang.Exception): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, exception: java.lang.Exception): ...

class HyperCycle(cern.accsoft.commons.util.Named, cern.lsa.domain.commons.IdentifiedEntity, java.lang.Comparable['HyperCycle']):
    """
    Java class 'cern.lsa.domain.settings.HyperCycle'
    
        Interfaces:
            cern.accsoft.commons.util.Named,
            cern.lsa.domain.commons.IdentifiedEntity, java.lang.Comparable
    
    """
    def getBeamProcessByUser(self, string: str) -> 'StandAloneBeamProcess': ...
    def getBeamProcessPosition(self, string: str, standAloneBeamProcess: 'StandAloneBeamProcess') -> int: ...
    def getDescription(self) -> str: ...
    def getFirstBeamProcess(self, string: str) -> 'StandAloneBeamProcess': ...
    def getLastBeamProcess(self, string: str) -> 'StandAloneBeamProcess': ...
    def getNextBeamProcess(self, string: str) -> 'StandAloneBeamProcess': ...
    def getPreviousBeamProcess(self, string: str) -> 'StandAloneBeamProcess': ...
    def getResidentBeamProcess(self, string: str) -> 'StandAloneBeamProcess': ...
    def getResidentBeamProcesses(self) -> java.util.Set['StandAloneBeamProcess']: ...
    @typing.overload
    def getScheduledBeamProcesses(self) -> java.util.List['StandAloneBeamProcess']: ...
    @typing.overload
    def getScheduledBeamProcesses(self, string: str) -> java.util.List['StandAloneBeamProcess']: ...
    def getUserCategories(self) -> java.util.SortedSet[str]: ...
    def getUserCategory(self, standAloneBeamProcess: 'StandAloneBeamProcess') -> str: ...
    def getUserForBeamProcess(self, standAloneBeamProcess: 'StandAloneBeamProcess') -> str: ...
    @typing.overload
    def getUsers(self, string: str) -> java.util.List[str]: ...
    @typing.overload
    def getUsers(self) -> java.util.Set[str]: ...
    def isActive(self) -> bool: ...

class HyperCycleMapping:
    """
    Java class 'cern.lsa.domain.settings.HyperCycleMapping'
    
    """
    @staticmethod
    def builder() -> 'DefaultHyperCycleMapping.Builder': ...
    def getBeamProcess(self) -> 'StandAloneBeamProcess': ...
    def getUser(self) -> AcceleratorUser: ...

class IncorporationRanges:
    """
    Java class 'cern.lsa.domain.settings.IncorporationRanges'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * IncorporationRanges()
    
    """
    def __init__(self): ...
    @staticmethod
    def assertRangesConsistentWithBeamProcessType(list: java.util.List[cern.lsa.domain.settings.type.IncorporationRange], beamProcessType: cern.lsa.domain.settings.type.BeamProcessType) -> None: ...
    @staticmethod
    def ensureConsistentRanges(collection: typing.Union[java.util.Collection[cern.lsa.domain.settings.type.IncorporationRange], typing.Sequence[cern.lsa.domain.settings.type.IncorporationRange]]) -> None: ...

class IncorporationSetting(java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.IncorporationSetting'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * IncorporationSetting(cern.lsa.domain.settings.Setting, double)
    
    """
    def __init__(self, setting: 'Setting', double: float): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getPointInTime(self) -> float: ...
    def getSetting(self) -> 'Setting': ...
    def hashCode(self) -> int: ...

class Intersections:
    """
    Java class 'cern.lsa.domain.settings.Intersections'
    
        Extends:
            java.lang.Object
    
      Attributes:
        TOLERANCE (double): final static field
        ERROR_MESSAGE_DISCONTINUITY (java.lang.String): final static field
    
    """
    TOLERANCE: typing.ClassVar[float] = ...
    ERROR_MESSAGE_DISCONTINUITY: typing.ClassVar[str] = ...
    @typing.overload
    @staticmethod
    def computeBeamProcessFunction(standAloneContext: 'StandAloneContext', beamProcess: 'BeamProcess', immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction) -> cern.accsoft.commons.value.DiscreteFunction: ...
    @typing.overload
    @staticmethod
    def computeBeamProcessFunction(standAloneContext: 'StandAloneContext', beamProcess: 'BeamProcess', immutableDiscreteFunctionsArray: cern.accsoft.commons.value.ImmutableDiscreteFunctionsArray) -> cern.accsoft.commons.value.DiscreteFunctionsArray: ...
    @typing.overload
    @staticmethod
    def concatenateFunctions(discreteFunction: cern.accsoft.commons.value.DiscreteFunction, discreteFunction2: cern.accsoft.commons.value.DiscreteFunction, double: float) -> None: ...
    @typing.overload
    @staticmethod
    def concatenateFunctions(discreteFunctionsArray: cern.accsoft.commons.value.DiscreteFunctionsArray, discreteFunctionsArray2: cern.accsoft.commons.value.DiscreteFunctionsArray, double: float) -> None: ...
    @staticmethod
    def getCycleBeamProcessIntersections(standAloneContext: 'StandAloneContext') -> java.util.SortedSet[CycleBeamProcessIntersection]: ...
    @staticmethod
    def getPrecedingBeamProcess(standAloneContext: 'StandAloneContext', beamProcess: 'BeamProcess') -> 'BeamProcess': ...
    @typing.overload
    @staticmethod
    def insertNaN(discreteFunction: cern.accsoft.commons.value.DiscreteFunction, discreteFunction2: cern.accsoft.commons.value.DiscreteFunction, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def insertNaN(discreteFunction: cern.accsoft.commons.value.DiscreteFunction, discreteFunction2: cern.accsoft.commons.value.DiscreteFunction, int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def insertNaN(discreteFunction: cern.accsoft.commons.value.DiscreteFunction, double: float, double2: float) -> None: ...
    @typing.overload
    @staticmethod
    def mergeFunctions(discreteFunction: cern.accsoft.commons.value.DiscreteFunction, immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction) -> None: ...
    @typing.overload
    @staticmethod
    def mergeFunctions(discreteFunctionsArray: cern.accsoft.commons.value.DiscreteFunctionsArray, discreteFunctionsArray2: cern.accsoft.commons.value.DiscreteFunctionsArray) -> None: ...
    @staticmethod
    def mutateSettingPart(setting: 'Setting', settingPartEnum: 'SettingPartEnum') -> cern.accsoft.commons.value.DiscreteFunction: ...
    @staticmethod
    def toBeamProcessFunctionsArrayMap(standAloneContext: 'StandAloneContext', collection: typing.Union[java.util.Collection[cern.accsoft.commons.domain.particletransfers.ParticleTransfer], typing.Sequence[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]], immutableDiscreteFunctionsArray: cern.accsoft.commons.value.ImmutableDiscreteFunctionsArray) -> java.util.Map['BeamProcess', cern.accsoft.commons.value.ImmutableDiscreteFunctionsArray]: ...
    @staticmethod
    def toBeamProcessFunctionsMap(standAloneContext: 'StandAloneContext', collection: typing.Union[java.util.Collection[cern.accsoft.commons.domain.particletransfers.ParticleTransfer], typing.Sequence[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]], immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction) -> java.util.Map['BeamProcess', cern.accsoft.commons.value.ImmutableDiscreteFunction]: ...
    @staticmethod
    def updateFunctionSetting(standAloneContext: 'StandAloneContext', parameterSettings: 'ParameterSettings', immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction, settingPartEnum: 'SettingPartEnum') -> None: ...

class KnobFactor(java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.KnobFactor'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * KnobFactor(java.lang.String, java.lang.String, double)
    
    """
    def __init__(self, string: str, string2: str, double: float): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getComponentName(self) -> str: ...
    def getFactor(self) -> float: ...
    def getOpticName(self) -> str: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class KnobFactors:
    """
    Java class 'cern.lsa.domain.settings.KnobFactors'
    
    """
    def containsFactor(self, string: str, string2: str) -> bool: ...
    def getComponentNames(self) -> java.util.Set[str]: ...
    def getFactor(self, string: str, string2: str) -> float: ...
    def getFactors(self) -> java.util.Set[KnobFactor]: ...
    def getFactorsForComponent(self, string: str) -> java.util.Set[KnobFactor]: ...
    def getFactorsForOptic(self, string: str) -> java.util.Set[KnobFactor]: ...
    def getOpticNames(self) -> java.util.Set[str]: ...

class LinkRuleAttribute(java.lang.Enum['LinkRuleAttribute']):
    """
    Java class 'cern.lsa.domain.settings.LinkRuleAttribute'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        START_VALUE (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        STOP_VALUE (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        START_DELAY (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        STOP_DELAY (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        DEGAUSS_VALUE (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        START_ROUND (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        STOP_ROUND (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        RAMP_SPEED (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        TIME_UNIT (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        POINT_DIST (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        BTOM_AS_PERCENT_IMAX (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        KEEP_SIGN (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        LEIR_ETL_BHN10_MIN_PLATEAU_LENGTH (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        LEIR_ETL_BHN10_MIN_PLATEAU_I (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        LEIR_ETL_BHN10_MIN_STABILIZATION_LENGTH (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
        LEIR_ETL_BHN10_START_END_CYCLE_I (cern.lsa.domain.settings.LinkRuleAttribute): final static enum constant
    
    """
    START_VALUE: typing.ClassVar['LinkRuleAttribute'] = ...
    STOP_VALUE: typing.ClassVar['LinkRuleAttribute'] = ...
    START_DELAY: typing.ClassVar['LinkRuleAttribute'] = ...
    STOP_DELAY: typing.ClassVar['LinkRuleAttribute'] = ...
    DEGAUSS_VALUE: typing.ClassVar['LinkRuleAttribute'] = ...
    START_ROUND: typing.ClassVar['LinkRuleAttribute'] = ...
    STOP_ROUND: typing.ClassVar['LinkRuleAttribute'] = ...
    RAMP_SPEED: typing.ClassVar['LinkRuleAttribute'] = ...
    TIME_UNIT: typing.ClassVar['LinkRuleAttribute'] = ...
    POINT_DIST: typing.ClassVar['LinkRuleAttribute'] = ...
    BTOM_AS_PERCENT_IMAX: typing.ClassVar['LinkRuleAttribute'] = ...
    KEEP_SIGN: typing.ClassVar['LinkRuleAttribute'] = ...
    LEIR_ETL_BHN10_MIN_PLATEAU_LENGTH: typing.ClassVar['LinkRuleAttribute'] = ...
    LEIR_ETL_BHN10_MIN_PLATEAU_I: typing.ClassVar['LinkRuleAttribute'] = ...
    LEIR_ETL_BHN10_MIN_STABILIZATION_LENGTH: typing.ClassVar['LinkRuleAttribute'] = ...
    LEIR_ETL_BHN10_START_END_CYCLE_I: typing.ClassVar['LinkRuleAttribute'] = ...
    def getAttributeName(self) -> str: ...
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'LinkRuleAttribute': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @staticmethod
    def values() -> typing.List['LinkRuleAttribute']: ...

class MisconfiguredParameterException(cern.lsa.domain.LsaException):
    """
    Java class 'cern.lsa.domain.settings.MisconfiguredParameterException'
    
        Extends:
            cern.lsa.domain.LsaException
    
      Constructors:
        * MisconfiguredParameterException(cern.lsa.domain.settings.Parameter, cern.lsa.domain.settings.DrivableContext)
    
    """
    def __init__(self, parameter: 'Parameter', drivableContext: 'DrivableContext'): ...

class NotIncorporatedParameters:
    """
    Java class 'cern.lsa.domain.settings.NotIncorporatedParameters'
    
    """
    def getNonCountinueParameters(self) -> java.util.Set[str]: ...
    def getParametersWithSettingsOnlyInFirstContext(self) -> java.util.Set[str]: ...

class Parameter(cern.accsoft.commons.util.Named, cern.lsa.domain.commons.IdentifiedEntity, java.lang.Comparable['Parameter']):
    """
    Java class 'cern.lsa.domain.settings.Parameter'
    
        Interfaces:
            cern.accsoft.commons.util.Named,
            cern.lsa.domain.commons.IdentifiedEntity, java.lang.Comparable
    
    """
    def belongsToFunctionBeamProcess(self) -> bool: ...
    def getAccelerator(self) -> cern.accsoft.commons.domain.Accelerator: ...
    def getDefaultHierarchy(self) -> str: ...
    def getDevice(self) -> cern.lsa.domain.devices.Device: ...
    def getParameterGroups(self) -> java.util.Set[str]: ...
    def getParameterType(self) -> 'ParameterType': ...
    def getParticleTransfers(self) -> java.util.Set[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]: ...
    def getPropertyField(self) -> cern.lsa.domain.devices.type.PropertyField: ...
    def getValueDescriptor(self) -> cern.accsoft.commons.value.ValueDescriptor: ...
    def getValueType(self) -> cern.accsoft.commons.value.Type: ...
    def isCritical(self) -> bool: ...
    def isCycleBound(self) -> bool: ...
    def isLsaImplementation(self) -> bool: ...
    def isMonitorable(self) -> bool: ...
    def isMultiplexed(self) -> bool: ...
    def isPropertySupportingPartialSet(self) -> bool: ...
    def isReadable(self) -> bool: ...
    def isReservedForOpExperts(self) -> bool: ...
    def isTrimable(self) -> bool: ...
    def isVirtual(self) -> bool: ...
    def isWritable(self) -> bool: ...

class ParameterAttributes(cern.accsoft.commons.util.Named, java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.ParameterAttributes'
    
        Interfaces:
            cern.accsoft.commons.util.Named, java.io.Serializable
    
    """
    def getAbsoluteTolerance(self) -> float: ...
    def getDefaultHierarchy(self) -> str: ...
    def getDevice(self) -> cern.lsa.domain.devices.Device: ...
    def getMaxValue(self) -> float: ...
    def getMinValue(self) -> float: ...
    def getParameterId(self) -> int: ...
    def getParameterName(self) -> str: ...
    def getParameterType(self) -> 'ParameterType': ...
    def getPropertyField(self) -> cern.lsa.domain.devices.type.PropertyField: ...
    def getRelativeTolerance(self) -> float: ...
    def getXPrecision(self) -> int: ...
    def getYPrecision(self) -> int: ...
    def isBelongsToFunctionBProc(self) -> bool: ...
    def isReservedForOpExperts(self) -> bool: ...
    def isTrimable(self) -> bool: ...
    def setAbsoluteTolerance(self, double: float) -> None: ...
    def setBelongsToFunctionBProc(self, boolean: bool) -> None: ...
    def setDefaultHierarchy(self, string: str) -> None: ...
    def setMaxValue(self, double: float) -> None: ...
    def setMinValue(self, double: float) -> None: ...
    def setParameterId(self, long: int) -> None: ...
    def setParameterName(self, string: str) -> None: ...
    def setRelativeTolerance(self, double: float) -> None: ...
    def setReservedForOpExperts(self, boolean: bool) -> None: ...
    def setTrimable(self, boolean: bool) -> None: ...
    def setXPrecision(self, integer: int) -> None: ...
    def setYPrecision(self, integer: int) -> None: ...

class ParameterForEditing(cern.accsoft.commons.util.Named, java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.ParameterForEditing'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.accsoft.commons.util.Named, java.io.Serializable
    
      Constructors:
        * ParameterForEditing(cern.lsa.domain.settings.Parameter, cern.lsa.domain.settings.ParameterAttributes)
    
    """
    def __init__(self, parameter: Parameter, parameterAttributes: ParameterAttributes): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getName(self) -> str: ...
    def getParameter(self) -> Parameter: ...
    def getParameterAttributes(self) -> ParameterAttributes: ...
    def hashCode(self) -> int: ...

class ParameterGroup(cern.accsoft.commons.util.Named, cern.lsa.domain.commons.IdentifiedEntity):
    """
    Java class 'cern.lsa.domain.settings.ParameterGroup'
    
        Interfaces:
            cern.accsoft.commons.util.Named,
            cern.lsa.domain.commons.IdentifiedEntity
    
    """
    def getAccelerator(self) -> cern.accsoft.commons.domain.Accelerator: ...
    def getCreateDate(self) -> java.util.Date: ...
    def getCreator(self) -> str: ...
    def getDescription(self) -> str: ...

class ParameterNotFoundException(java.lang.RuntimeException):
    """
    Java class 'cern.lsa.domain.settings.ParameterNotFoundException'
    
        Extends:
            java.lang.RuntimeException
    
      Constructors:
        * ParameterNotFoundException(java.lang.Throwable, java.util.Collection)
        * ParameterNotFoundException(java.util.Collection)
        * ParameterNotFoundException(java.lang.String)
        * ParameterNotFoundException(java.lang.String, java.lang.Throwable)
    
    """
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable, collection: typing.Union[java.util.Collection[str], typing.Sequence[str]]): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[str], typing.Sequence[str]]): ...
    def getParameterNames(self) -> java.util.SortedSet[str]: ...

class ParameterSettings:
    """
    Java class 'cern.lsa.domain.settings.ParameterSettings'
    
    """
    def getCurrentBeamProcesses(self) -> java.util.Set['BeamProcess']: ...
    def getCurrentSetting(self, beamProcess: 'BeamProcess') -> 'Setting': ...
    def getCurrentSettings(self) -> java.util.Set['Setting']: ...
    def getParameter(self) -> Parameter: ...
    def getParticleTransfers(self) -> java.util.Set[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]: ...
    def getSetting(self, beamProcess: 'BeamProcess') -> 'Setting': ...
    def getSettings(self) -> java.util.Set['Setting']: ...
    def getUpdatedBeamProcesses(self) -> java.util.Set['BeamProcess']: ...
    def getUpdatedSetting(self, beamProcess: 'BeamProcess') -> 'Setting': ...
    def getUpdatedSettings(self) -> java.util.Set['Setting']: ...
    def getValueType(self) -> cern.accsoft.commons.value.Type: ...
    def isEmpty(self) -> bool: ...
    @typing.overload
    def isUpdated(self) -> bool: ...
    @typing.overload
    def isUpdated(self, beamProcess: 'BeamProcess') -> bool: ...
    def round(self) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def updateSetting(self, beamProcess: 'BeamProcess', immutableValue: cern.accsoft.commons.value.ImmutableValue, settingPartEnum: 'SettingPartEnum') -> None: ...
    @typing.overload
    def updateSetting(self, beamProcess: 'BeamProcess', setting: 'Setting') -> None: ...

class ParameterTreeNode(cern.accsoft.commons.util.Named):
    """
    Java class 'cern.lsa.domain.settings.ParameterTreeNode'
    
        Interfaces:
            cern.accsoft.commons.util.Named
    
    """
    def findNode(self, string: str) -> 'ParameterTreeNode': ...
    def getAllChildren(self) -> java.util.List['ParameterTreeNode']: ...
    def getAllParents(self) -> java.util.List['ParameterTreeNode']: ...
    def getChildren(self) -> java.util.List['ParameterTreeNode']: ...
    @typing.overload
    def getNodes(self) -> java.util.List['ParameterTreeNode']: ...
    @typing.overload
    def getNodes(self, boolean: bool) -> java.util.List['ParameterTreeNode']: ...
    def getParameter(self) -> Parameter: ...
    def getParameters(self) -> java.util.List[Parameter]: ...
    def getParametersFromThisNodeAndAllChildren(self) -> java.util.List[Parameter]: ...
    def getParametersFromThisNodeAndAllParents(self) -> java.util.List[Parameter]: ...
    def getParents(self) -> java.util.List['ParameterTreeNode']: ...
    def getThisNodeAndAllChildren(self) -> java.util.List['ParameterTreeNode']: ...
    def getThisNodeAndAllParents(self) -> java.util.List['ParameterTreeNode']: ...
    def isLeaf(self) -> bool: ...
    def isRoot(self) -> bool: ...
    def isSource(self) -> bool: ...

class ParameterTreesRequest:
    """
    Java class 'cern.lsa.domain.settings.ParameterTreesRequest'
    
    """
    @staticmethod
    def builder() -> cern.lsa.domain.settings.factory.ParameterTreesRequestBuilder: ...
    def getHierarchy(self) -> str: ...
    def getParameterNames(self) -> java.util.Set[str]: ...
    def getParameters(self) -> java.util.Set[Parameter]: ...
    def getTreeDirection(self) -> 'ParameterTreesRequest.TreeDirection': ...
    class TreeDirection(java.lang.Enum['ParameterTreesRequest.TreeDirection']):
        """
        Java class 'cern.lsa.domain.settings.ParameterTreesRequest$TreeDirection'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            SOURCE_TREE (cern.lsa.domain.settings.ParameterTreesRequest$TreeDirection): final static enum constant
            DEPENDENT_TREE (cern.lsa.domain.settings.ParameterTreesRequest$TreeDirection): final static enum constant
        
        """
        SOURCE_TREE: typing.ClassVar['ParameterTreesRequest.TreeDirection'] = ...
        DEPENDENT_TREE: typing.ClassVar['ParameterTreesRequest.TreeDirection'] = ...
        _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'ParameterTreesRequest.TreeDirection': ...
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
        @staticmethod
        def values() -> typing.List['ParameterTreesRequest.TreeDirection']: ...

class ParameterType(cern.accsoft.commons.util.Named, cern.lsa.domain.commons.IdentifiedEntity, java.lang.Comparable['ParameterType']):
    """
    Java class 'cern.lsa.domain.settings.ParameterType'
    
        Interfaces:
            cern.accsoft.commons.util.Named,
            cern.lsa.domain.commons.IdentifiedEntity, java.lang.Comparable
    
    """
    def getCategory(self) -> 'ParameterTypeCategory': ...
    def isLinkRuleApplicable(self) -> bool: ...

class ParameterTypeCategory(java.lang.Enum['ParameterTypeCategory']):
    """
    Java class 'cern.lsa.domain.settings.ParameterTypeCategory'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        PHYSICS (cern.lsa.domain.settings.ParameterTypeCategory): final static enum constant
        HW_MAGNITUDE (cern.lsa.domain.settings.ParameterTypeCategory): final static enum constant
        HW_SETTINGS (cern.lsa.domain.settings.ParameterTypeCategory): final static enum constant
        HW_REFERENCE (cern.lsa.domain.settings.ParameterTypeCategory): final static enum constant
    
    """
    PHYSICS: typing.ClassVar['ParameterTypeCategory'] = ...
    HW_MAGNITUDE: typing.ClassVar['ParameterTypeCategory'] = ...
    HW_SETTINGS: typing.ClassVar['ParameterTypeCategory'] = ...
    HW_REFERENCE: typing.ClassVar['ParameterTypeCategory'] = ...
    def getCategoryOrder(self) -> int: ...
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'ParameterTypeCategory': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @staticmethod
    def values() -> typing.List['ParameterTypeCategory']: ...

class ParameterTypeGroup(cern.accsoft.commons.util.Named):
    """
    Java class 'cern.lsa.domain.settings.ParameterTypeGroup'
    
        Interfaces:
            cern.accsoft.commons.util.Named
    
    """
    def getParameterTypes(self) -> java.util.Set[ParameterType]: ...

class ParameterTypes:
    """
    Java class 'cern.lsa.domain.settings.ParameterTypes'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * ParameterTypes()
    
      Attributes:
        PARAMETERS_WITH_META_DATA (cern.accsoft.commons.util.Filters$Filter): final static field
    
    """
    PARAMETERS_WITH_META_DATA: typing.ClassVar[cern.accsoft.commons.util.Filters.Filter] = ...
    def __init__(self): ...
    @staticmethod
    def createParameterType(deviceTypeVersion: cern.lsa.domain.devices.DeviceTypeVersion, string: str, collection: typing.Union[java.util.Collection[str], typing.Sequence[str]], collection2: typing.Union[java.util.Collection[cern.lsa.domain.devices.type.PropertyVersion], typing.Sequence[cern.lsa.domain.devices.type.PropertyVersion]]) -> java.util.List[ParameterType]: ...
    @staticmethod
    def generateParameterTypeName(string: str, string2: str, string3: str) -> str: ...

class ParameterTypesRequest:
    """
    Java class 'cern.lsa.domain.settings.ParameterTypesRequest'
    
    """
    @staticmethod
    def builder() -> cern.lsa.domain.settings.factory.ParameterTypesRequestBuilder: ...
    def getParameterTypeNames(self) -> java.util.Set[str]: ...
    def isAllParameterTypesRequested(self) -> bool: ...

class Parameters:
    """
    Java class 'cern.lsa.domain.settings.Parameters'
    
        Extends:
            java.lang.Object
    
      Attributes:
        DEFAULT_FIELD_NAME (java.lang.String): final static field
        DEFAULT_PARAMETER_HIERARCHY (java.lang.String): final static field
        NOT_SUPPORTING_PARTIAL_SET (cern.accsoft.commons.util.Filters$Filter): final static field
        NON_LSA_IMPLEMENTATION (cern.accsoft.commons.util.Filters$Filter): final static field
        LSA_IMPLEMENTATION (cern.accsoft.commons.util.Filters$Filter): final static field
        SETTING (cern.accsoft.commons.util.Filters$Filter): final static field
        CRITICAL (cern.accsoft.commons.util.Filters$Filter): final static field
        READABLE (cern.accsoft.commons.util.Filters$Filter): final static field
        WRITABLE (cern.accsoft.commons.util.Filters$Filter): final static field
        MONITORABLE (cern.accsoft.commons.util.Filters$Filter): final static field
        READABLE_AND_WRITABLE (cern.accsoft.commons.util.Filters$Filter): final static field
        NON_MULTIPLEXED (cern.accsoft.commons.util.Filters$Filter): final static field
        FEC_NAME (cern.accsoft.commons.util.Mappers$Mapper): final static field
        FIELD_NAME (cern.accsoft.commons.util.Mappers$Mapper): final static field
    
    """
    DEFAULT_FIELD_NAME: typing.ClassVar[str] = ...
    DEFAULT_PARAMETER_HIERARCHY: typing.ClassVar[str] = ...
    NOT_SUPPORTING_PARTIAL_SET: typing.ClassVar[cern.accsoft.commons.util.Filters.Filter] = ...
    NON_LSA_IMPLEMENTATION: typing.ClassVar[cern.accsoft.commons.util.Filters.Filter] = ...
    LSA_IMPLEMENTATION: typing.ClassVar[cern.accsoft.commons.util.Filters.Filter] = ...
    SETTING: typing.ClassVar[cern.accsoft.commons.util.Filters.Filter] = ...
    CRITICAL: typing.ClassVar[cern.accsoft.commons.util.Filters.Filter] = ...
    READABLE: typing.ClassVar[cern.accsoft.commons.util.Filters.Filter] = ...
    WRITABLE: typing.ClassVar[cern.accsoft.commons.util.Filters.Filter] = ...
    MONITORABLE: typing.ClassVar[cern.accsoft.commons.util.Filters.Filter] = ...
    READABLE_AND_WRITABLE: typing.ClassVar[cern.accsoft.commons.util.Filters.Filter] = ...
    NON_MULTIPLEXED: typing.ClassVar[cern.accsoft.commons.util.Filters.Filter] = ...
    FEC_NAME: typing.ClassVar[cern.accsoft.commons.util.Mappers.Mapper] = ...
    FIELD_NAME: typing.ClassVar[cern.accsoft.commons.util.Mappers.Mapper] = ...
    @staticmethod
    def assertParametersDefined(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], collection2: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> None: ...
    @staticmethod
    def atLeastOneIsMultiplexed(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> bool: ...
    @staticmethod
    def atLeastOneIsReadable(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> bool: ...
    @staticmethod
    def atLeastOneIsWritable(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> bool: ...
    @staticmethod
    def belongsToParticleTransfer(parameter: Parameter, particleTransfer: cern.accsoft.commons.domain.particletransfers.ParticleTransfer) -> bool: ...
    @staticmethod
    def constructParameterName(string: str, string2: str, string3: str) -> str: ...
    @staticmethod
    def containsField(string: str) -> bool: ...
    @staticmethod
    def deviceIn(collection: typing.Union[java.util.Collection[cern.lsa.domain.devices.Device], typing.Sequence[cern.lsa.domain.devices.Device]]) -> cern.accsoft.commons.util.Filters.Filter[Parameter]: ...
    @staticmethod
    def deviceNameIn(collection: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> cern.accsoft.commons.util.Filters.Filter[Parameter]: ...
    @staticmethod
    def deviceTypeNameIn(collection: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> cern.accsoft.commons.util.Filters.Filter[Parameter]: ...
    @staticmethod
    def extractDefaultHierarchies(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[str]: ...
    @staticmethod
    def extractDeviceName(string: str) -> str: ...
    @staticmethod
    def extractDeviceNames(collection: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> java.util.Set[str]: ...
    @staticmethod
    def extractParameterName(string: str) -> str: ...
    @staticmethod
    def extractParameterNames(collection: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> java.util.Set[str]: ...
    @staticmethod
    def extractPropertyField(string: str) -> str: ...
    @staticmethod
    def extractPropertyName(string: str) -> str: ...
    @staticmethod
    def extractPropertyNames(collection: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> java.util.Set[str]: ...
    @staticmethod
    def filterCriticalParameters(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterLeafNodes(collection: typing.Union[java.util.Collection[ParameterTreeNode], typing.Sequence[ParameterTreeNode]]) -> java.util.Set[ParameterTreeNode]: ...
    @staticmethod
    def filterLsaImplementationParameters(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterMonitorableParameters(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterNonLsaImplementationParameters(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterNonSignatureParameters(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByAccessMode(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], collection2: typing.Union[java.util.Collection['PropertyAccessMode'], typing.Sequence['PropertyAccessMode']]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByDeviceNames(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], collection2: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByDeviceProperties(set: java.util.Set[Parameter], set2: java.util.Set[str]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByDeviceTypeNames(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], collection2: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByDevices(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], collection2: typing.Union[java.util.Collection[cern.lsa.domain.devices.Device], typing.Sequence[cern.lsa.domain.devices.Device]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByImplementation(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], collection2: typing.Union[java.util.Collection[cern.lsa.domain.devices.DeviceTypeImplementation], typing.Sequence[cern.lsa.domain.devices.DeviceTypeImplementation]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByMultiplexingCriteria(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], boolean: bool) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByParameterGroups(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], collection2: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByParticleTransfers(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], collection2: typing.Union[java.util.Collection[cern.accsoft.commons.domain.particletransfers.ParticleTransfer], typing.Sequence[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByPropertyNames(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], collection2: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByTrimableCriteria(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], boolean: bool) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersByTypes(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], collection2: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterParametersNotBelongingToDeviceProperties(set: java.util.Set[Parameter], set2: java.util.Set[str]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterReadableParameters(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterRootNodes(collection: typing.Union[java.util.Collection[ParameterTreeNode], typing.Sequence[ParameterTreeNode]]) -> java.util.Set[ParameterTreeNode]: ...
    @staticmethod
    def filterSettingParameters(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def filterWritableParameters(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def getAllParameters(collection: typing.Union[java.util.Collection[ParameterTreeNode], typing.Sequence[ParameterTreeNode]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def getAncestors(collection: typing.Union[java.util.Collection[ParameterTreeNode], typing.Sequence[ParameterTreeNode]]) -> java.util.Set[ParameterTreeNode]: ...
    @staticmethod
    def getColumnCount(parameter: Parameter) -> int: ...
    @staticmethod
    def getDescendants(collection: typing.Union[java.util.Collection[ParameterTreeNode], typing.Sequence[ParameterTreeNode]]) -> java.util.Set[ParameterTreeNode]: ...
    @staticmethod
    def getDeviceNames(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[str]: ...
    @staticmethod
    def getDeviceProperties(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[str]: ...
    @staticmethod
    def getDeviceProperty(parameter: Parameter) -> str: ...
    @staticmethod
    def getDeviceTypeNames(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[str]: ...
    @staticmethod
    def getDevices(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[cern.lsa.domain.devices.Device]: ...
    @staticmethod
    def getFieldName(parameter: Parameter) -> str: ...
    @staticmethod
    def getFieldNames(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[str]: ...
    @staticmethod
    def getParameterByTypeName(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]], string: str) -> Parameter: ...
    @staticmethod
    def getParameterGroups(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[str]: ...
    @staticmethod
    def getParameterGroupsOrNoGroup(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[str]: ...
    @staticmethod
    def getParameterTypes(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[ParameterType]: ...
    @typing.overload
    @staticmethod
    def getParameters(collection: typing.Union[java.util.Collection[ParameterTreeNode], typing.Sequence[ParameterTreeNode]]) -> java.util.List[Parameter]: ...
    @typing.overload
    @staticmethod
    def getParameters(map: typing.Union[java.util.Map[str, DevicePropertyParameters], typing.Mapping[str, DevicePropertyParameters]]) -> java.util.Set[Parameter]: ...
    @staticmethod
    def getParticleTransfers(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]: ...
    @staticmethod
    def getPropertyName(parameter: Parameter) -> str: ...
    @staticmethod
    def getPropertyNames(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Set[str]: ...
    @staticmethod
    def getRowCount(parameter: Parameter) -> int: ...
    @staticmethod
    def groupDevicePropertiesByDeviceType(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Map[str, java.util.Set[str]]: ...
    @staticmethod
    def groupParametersByDefaultHierarchy(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.SortedMap[str, java.util.Set[Parameter]]: ...
    @staticmethod
    def groupParametersByDeviceNames(set: java.util.Set[Parameter]) -> java.util.Map[str, java.util.Set[Parameter]]: ...
    @staticmethod
    def groupParametersByDeviceProperty(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Map[str, DevicePropertyParameters]: ...
    @staticmethod
    def groupParametersByDevices(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Map[cern.lsa.domain.devices.Device, java.util.Set[Parameter]]: ...
    @staticmethod
    def groupParametersByParticleTransfers(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Map[cern.accsoft.commons.domain.particletransfers.ParticleTransfer, java.util.Set[Parameter]]: ...
    @staticmethod
    def groupToParameterTypeGroups(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.List[ParameterTypeGroup]: ...
    @staticmethod
    def hasField(parameter: Parameter) -> bool: ...
    @staticmethod
    def implementationIn(collection: typing.Union[java.util.Collection[cern.lsa.domain.devices.DeviceTypeImplementation], typing.Sequence[cern.lsa.domain.devices.DeviceTypeImplementation]]) -> cern.accsoft.commons.util.Filters.Filter[Parameter]: ...
    @staticmethod
    def isCommandParameter(parameter: Parameter) -> bool: ...
    @staticmethod
    def isSettingParameter(parameter: Parameter) -> bool: ...
    @staticmethod
    def isSignatureParameter(parameter: Parameter) -> bool: ...
    @staticmethod
    def isSimpleProperty(set: java.util.Set[Parameter]) -> bool: ...
    @typing.overload
    @staticmethod
    def mapByDeviceName(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> java.util.Map[str, Parameter]: ...
    @typing.overload
    @staticmethod
    def mapByDeviceName(set: java.util.Set[Parameter]) -> java.util.Map[str, Parameter]: ...
    @staticmethod
    def mapByParameterTypeNames(set: java.util.Set[Parameter]) -> java.util.Map[str, Parameter]: ...
    @staticmethod
    def parameterTypeNameIn(collection: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> cern.accsoft.commons.util.Filters.Filter[Parameter]: ...
    @staticmethod
    def particleTransferIn(collection: typing.Union[java.util.Collection[cern.accsoft.commons.domain.particletransfers.ParticleTransfer], typing.Sequence[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]]) -> cern.accsoft.commons.util.Filters.Filter[Parameter]: ...
    @staticmethod
    def propertyNameIn(collection: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> cern.accsoft.commons.util.Filters.Filter[Parameter]: ...
    @staticmethod
    def toArray(collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> typing.List[Parameter]: ...

class ParametersRequest:
    """
    Java class 'cern.lsa.domain.settings.ParametersRequest'
    
    """
    @staticmethod
    def builder() -> cern.lsa.domain.settings.factory.ParametersRequestBuilder: ...
    def getAccelerator(self) -> cern.accsoft.commons.domain.Accelerator: ...
    def getAcceleratorZones(self) -> java.util.Set[cern.accsoft.commons.domain.zones.AcceleratorZone]: ...
    def getDeviceNames(self) -> java.util.Set[str]: ...
    def getDevices(self) -> java.util.Set[cern.lsa.domain.devices.Device]: ...
    def getParameterGroups(self) -> java.util.Set[str]: ...
    def getParameterNamePattern(self) -> str: ...
    def getParameterNames(self) -> java.util.Set[str]: ...
    def getParameterTypeNames(self) -> java.util.Set[str]: ...
    def getParticleTransfers(self) -> java.util.Set[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]: ...
    def getPropertyFields(self) -> java.util.Set[cern.lsa.domain.devices.type.PropertyField]: ...
    def getPropertyNames(self) -> java.util.Set[str]: ...
    def getValueTypes(self) -> java.util.Set[cern.accsoft.commons.value.Type]: ...
    def isCritical(self) -> bool: ...
    def isIncludeSignatures(self) -> bool: ...
    def isLsaImplementation(self) -> bool: ...
    def isMultiplexed(self) -> bool: ...
    def isReadable(self) -> bool: ...
    def isWritable(self) -> bool: ...

class PropertyAccessMode(java.lang.Enum['PropertyAccessMode']):
    """
    Java class 'cern.lsa.domain.settings.PropertyAccessMode'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        WRITABLE (cern.lsa.domain.settings.PropertyAccessMode): final static enum constant
        READABLE (cern.lsa.domain.settings.PropertyAccessMode): final static enum constant
        MONITORABLE (cern.lsa.domain.settings.PropertyAccessMode): final static enum constant
        MULTIPLEXED (cern.lsa.domain.settings.PropertyAccessMode): final static enum constant
    
    """
    WRITABLE: typing.ClassVar['PropertyAccessMode'] = ...
    READABLE: typing.ClassVar['PropertyAccessMode'] = ...
    MONITORABLE: typing.ClassVar['PropertyAccessMode'] = ...
    MULTIPLEXED: typing.ClassVar['PropertyAccessMode'] = ...
    def hasTheSameAccessMode(self, parameter: Parameter) -> bool: ...
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'PropertyAccessMode': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @staticmethod
    def values() -> typing.List['PropertyAccessMode']: ...

class Setting(cern.lsa.domain.commons.IdentifiedEntity):
    """
    Java class 'cern.lsa.domain.settings.Setting'
    
        Interfaces:
            cern.lsa.domain.commons.IdentifiedEntity
    
    """
    def clone(self) -> 'Setting': ...
    def getArray2DValue(self) -> cern.accsoft.commons.value.ImmutableScalarArray2D: ...
    def getArrayValue(self) -> cern.accsoft.commons.value.ImmutableScalarArray: ...
    def getBeamProcess(self) -> 'BeamProcess': ...
    def getCorrectionFunctionValue(self) -> cern.accsoft.commons.value.ImmutableDiscreteFunction: ...
    def getCorrectionFunctionsArrayValue(self) -> cern.accsoft.commons.value.ImmutableDiscreteFunctionsArray: ...
    def getCorrectionScalarValue(self) -> cern.accsoft.commons.value.ImmutableScalar: ...
    def getCorrectionValue(self) -> cern.accsoft.commons.value.ImmutableValue: ...
    def getCreationDate(self) -> java.util.Date: ...
    def getFunctionValue(self) -> cern.accsoft.commons.value.ImmutableDiscreteFunction: ...
    def getFunctionsArrayValue(self) -> cern.accsoft.commons.value.ImmutableDiscreteFunctionsArray: ...
    def getParameter(self) -> Parameter: ...
    def getScalarValue(self) -> cern.accsoft.commons.value.ImmutableScalar: ...
    def getTargetFunctionValue(self) -> cern.accsoft.commons.value.ImmutableDiscreteFunction: ...
    def getTargetFunctionsArrayValue(self) -> cern.accsoft.commons.value.ImmutableDiscreteFunctionsArray: ...
    def getTargetScalarValue(self) -> cern.accsoft.commons.value.ImmutableScalar: ...
    def getTargetValue(self) -> cern.accsoft.commons.value.ImmutableValue: ...
    def getTrimId(self) -> int: ...
    def getValue(self) -> cern.accsoft.commons.value.ImmutableValue: ...
    def getValueType(self) -> cern.accsoft.commons.value.Type: ...
    @typing.overload
    def updateValue(self, immutableValue: cern.accsoft.commons.value.ImmutableValue, settingPartEnum: 'SettingPartEnum') -> None: ...
    @typing.overload
    def updateValue(self, setting: 'Setting') -> None: ...

class SettingComparisonParameterResult:
    """
    Java class 'cern.lsa.domain.settings.SettingComparisonParameterResult'
    
    """
    def getDestinationBeamProcesses(self) -> java.util.List['BeamProcess']: ...
    def getDestinationDetailedException(self, beamProcess: 'BeamProcess') -> java.lang.Exception: ...
    def getDestinationException(self) -> java.lang.Exception: ...
    def getDestinationSettings(self) -> ParameterSettings: ...
    def getDetailedResultType(self, beamProcess: 'BeamProcess', beamProcess2: 'BeamProcess') -> 'SettingComparisonResultType': ...
    def getDetailedResultTypes(self) -> java.util.Map[cern.accsoft.commons.util.value.Pair['BeamProcess', 'BeamProcess'], 'SettingComparisonResultType']: ...
    def getParameter(self) -> Parameter: ...
    def getResultType(self) -> 'SettingComparisonResultType': ...
    def getSourceBeamProcesses(self) -> java.util.List['BeamProcess']: ...
    def getSourceDetailedException(self, beamProcess: 'BeamProcess') -> java.lang.Exception: ...
    def getSourceException(self) -> java.lang.Exception: ...
    def getSourceSettings(self) -> ParameterSettings: ...

class SettingComparisonRequest:
    """
    Java class 'cern.lsa.domain.settings.SettingComparisonRequest'
    
    """
    def compareAllParameters(self) -> bool: ...
    def getDestinationBeamProcesses(self) -> java.util.List['BeamProcess']: ...
    def getDestinationSettingsSource(self) -> 'SettingsSource': ...
    def getParameters(self) -> java.util.Set[Parameter]: ...
    def getPointInDestFunction(self) -> int: ...
    def getPointInSourceFunction(self) -> int: ...
    def getSourceBeamProcesses(self) -> java.util.List['BeamProcess']: ...
    def getSourceSettingsSource(self) -> 'SettingsSource': ...
    def ignoreFlatFunctionsLength(self) -> bool: ...

class SettingComparisonResponse:
    """
    Java class 'cern.lsa.domain.settings.SettingComparisonResponse'
    
    """
    def getSettingComparisonRequest(self) -> SettingComparisonRequest: ...
    def getSettingComparisonResult(self) -> 'SettingComparisonResult': ...

class SettingComparisonResult:
    """
    Java class 'cern.lsa.domain.settings.SettingComparisonResult'
    
    """
    def getComparedParameters(self) -> java.util.Set[Parameter]: ...
    def getSettingComparisonParameterResult(self, parameter: Parameter) -> SettingComparisonParameterResult: ...
    def getSettingComparisonParameterResults(self) -> java.util.Map[Parameter, SettingComparisonParameterResult]: ...

class SettingComparisonResultType(java.lang.Enum['SettingComparisonResultType']):
    """
    Java class 'cern.lsa.domain.settings.SettingComparisonResultType'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        MATCH (cern.lsa.domain.settings.SettingComparisonResultType): final static enum constant
        MISMATCH (cern.lsa.domain.settings.SettingComparisonResultType): final static enum constant
        NO_SETTINGS (cern.lsa.domain.settings.SettingComparisonResultType): final static enum constant
        NO_SETTINGS_IN_SOURCE (cern.lsa.domain.settings.SettingComparisonResultType): final static enum constant
        NO_SETTINGS_IN_DEST (cern.lsa.domain.settings.SettingComparisonResultType): final static enum constant
        NOT_COMPARABLE (cern.lsa.domain.settings.SettingComparisonResultType): final static enum constant
        ERROR (cern.lsa.domain.settings.SettingComparisonResultType): final static enum constant
        FILTERED_OUT (cern.lsa.domain.settings.SettingComparisonResultType): final static enum constant
        UNDEFINED (cern.lsa.domain.settings.SettingComparisonResultType): final static enum constant
    
    """
    MATCH: typing.ClassVar['SettingComparisonResultType'] = ...
    MISMATCH: typing.ClassVar['SettingComparisonResultType'] = ...
    NO_SETTINGS: typing.ClassVar['SettingComparisonResultType'] = ...
    NO_SETTINGS_IN_SOURCE: typing.ClassVar['SettingComparisonResultType'] = ...
    NO_SETTINGS_IN_DEST: typing.ClassVar['SettingComparisonResultType'] = ...
    NOT_COMPARABLE: typing.ClassVar['SettingComparisonResultType'] = ...
    ERROR: typing.ClassVar['SettingComparisonResultType'] = ...
    FILTERED_OUT: typing.ClassVar['SettingComparisonResultType'] = ...
    UNDEFINED: typing.ClassVar['SettingComparisonResultType'] = ...
    @staticmethod
    def mostRepresentative(settingComparisonResultType: 'SettingComparisonResultType', settingComparisonResultType2: 'SettingComparisonResultType') -> 'SettingComparisonResultType': ...
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'SettingComparisonResultType': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @staticmethod
    def values() -> typing.List['SettingComparisonResultType']: ...

class SettingFactory:
    """
    Java class 'cern.lsa.domain.settings.SettingFactory'
    
        Extends:
            java.lang.Object
    
    """
    @typing.overload
    @staticmethod
    def newInitialSetting(beamProcess: 'BeamProcess', parameter: Parameter) -> Setting: ...
    @typing.overload
    @staticmethod
    def newInitialSetting(beamProcess: 'BeamProcess', parameter: Parameter, type: cern.accsoft.commons.value.Type) -> Setting: ...
    @typing.overload
    @staticmethod
    def newSetting(beamProcess: 'BeamProcess', parameter: Parameter) -> Setting: ...
    @typing.overload
    @staticmethod
    def newSetting(beamProcess: 'BeamProcess', parameter: Parameter, immutableValue: cern.accsoft.commons.value.ImmutableValue) -> Setting: ...
    @typing.overload
    @staticmethod
    def newSetting(beamProcess: 'BeamProcess', parameter: Parameter, immutableValue: cern.accsoft.commons.value.ImmutableValue, immutableValue2: cern.accsoft.commons.value.ImmutableValue) -> Setting: ...
    @typing.overload
    @staticmethod
    def newSetting(beamProcess: 'BeamProcess', parameter: Parameter, type: cern.accsoft.commons.value.Type) -> Setting: ...
    @typing.overload
    @staticmethod
    def newSetting(type: cern.accsoft.commons.value.Type) -> cern.lsa.domain.settings.spi.AbstractSetting: ...

class SettingPartEnum(java.lang.Enum['SettingPartEnum']):
    """
    Java class 'cern.lsa.domain.settings.SettingPartEnum'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        NONE (cern.lsa.domain.settings.SettingPartEnum): final static enum constant
        CORRECTION (cern.lsa.domain.settings.SettingPartEnum): final static enum constant
        TARGET (cern.lsa.domain.settings.SettingPartEnum): final static enum constant
        VALUE (cern.lsa.domain.settings.SettingPartEnum): final static enum constant
        UPDATE_TARGET_NO_CORRECTION (cern.lsa.domain.settings.SettingPartEnum): final static enum constant
        TARGET_AND_CORRECTION (cern.lsa.domain.settings.SettingPartEnum): final static enum constant
        UPDATE_VALUE_ON_TARGET (cern.lsa.domain.settings.SettingPartEnum): final static enum constant
    
    """
    NONE: typing.ClassVar['SettingPartEnum'] = ...
    CORRECTION: typing.ClassVar['SettingPartEnum'] = ...
    TARGET: typing.ClassVar['SettingPartEnum'] = ...
    VALUE: typing.ClassVar['SettingPartEnum'] = ...
    UPDATE_TARGET_NO_CORRECTION: typing.ClassVar['SettingPartEnum'] = ...
    TARGET_AND_CORRECTION: typing.ClassVar['SettingPartEnum'] = ...
    UPDATE_VALUE_ON_TARGET: typing.ClassVar['SettingPartEnum'] = ...
    def getTypeName(self) -> str: ...
    def getValue(self) -> int: ...
    def toString(self) -> str: ...
    _valueOf_2__T = typing.TypeVar('_valueOf_2__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(int: int) -> 'SettingPartEnum': ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'SettingPartEnum': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_2__T], string: str) -> _valueOf_2__T: ...
    @staticmethod
    def values() -> typing.List['SettingPartEnum']: ...

class Settings:
    """
    Java class 'cern.lsa.domain.settings.Settings'
    
        Extends:
            java.lang.Object
    
    """
    @staticmethod
    def computeContextBeamInValue(standAloneContext: 'StandAloneContext', parameterSettings: ParameterSettings, settingPartEnum: SettingPartEnum) -> cern.accsoft.commons.value.ImmutableValue: ...
    @typing.overload
    @staticmethod
    def computeContextValue(context: Context, parameterSettings: ParameterSettings) -> cern.accsoft.commons.value.ImmutableValue: ...
    @typing.overload
    @staticmethod
    def computeContextValue(context: Context, parameterSettings: ParameterSettings, settingPartEnum: SettingPartEnum) -> cern.accsoft.commons.value.ImmutableValue: ...
    @typing.overload
    @staticmethod
    def computeContextValue(standAloneContext: 'StandAloneContext', collection: typing.Union[java.util.Collection[Context], typing.Sequence[Context]], parameterSettings: ParameterSettings, settingPartEnum: SettingPartEnum) -> cern.accsoft.commons.value.ImmutableValue: ...
    @typing.overload
    @staticmethod
    def computeContextValue(collection: typing.Union[java.util.Collection[Context], typing.Sequence[Context]], parameterSettings: ParameterSettings, settingPartEnum: SettingPartEnum) -> cern.accsoft.commons.value.ImmutableValue: ...
    @staticmethod
    def filterNonCommandSettings(collection: typing.Union[java.util.Collection[Setting], typing.Sequence[Setting]]) -> java.util.List[Setting]: ...
    @staticmethod
    def filterNonSignatureSettings(collection: typing.Union[java.util.Collection[Setting], typing.Sequence[Setting]]) -> java.util.Set[Setting]: ...
    @staticmethod
    def filterSignatureSettings(collection: typing.Union[java.util.Collection[Setting], typing.Sequence[Setting]]) -> java.util.Set[Setting]: ...
    @staticmethod
    def getBeamProcesses(collection: typing.Union[java.util.Collection[Setting], typing.Sequence[Setting]]) -> java.util.Set['BeamProcess']: ...
    @staticmethod
    def getFunction(contextSettings: ContextSettings, parameter: Parameter) -> cern.accsoft.commons.value.ImmutableDiscreteFunction: ...
    @staticmethod
    def getFunctionList(contextSettings: ContextSettings, parameter: Parameter) -> cern.accsoft.commons.value.ImmutableDiscreteFunctionList: ...
    @staticmethod
    def getFunctionValue(setting: Setting, settingPartEnum: SettingPartEnum) -> cern.accsoft.commons.value.ImmutableDiscreteFunction: ...
    @staticmethod
    def getFunctionsArrayValue(setting: Setting, settingPartEnum: SettingPartEnum) -> cern.accsoft.commons.value.ImmutableDiscreteFunctionsArray: ...
    @staticmethod
    def getPolynomialValue(setting: Setting, settingPartEnum: SettingPartEnum) -> cern.accsoft.commons.value.ImmutableDiscreteFunction: ...
    @staticmethod
    def getScalar(contextSettings: ContextSettings, parameter: Parameter) -> cern.accsoft.commons.value.ImmutableScalar: ...
    @staticmethod
    def getScalarArray(contextSettings: ContextSettings, parameter: Parameter) -> cern.accsoft.commons.value.ImmutableScalarArray: ...
    @staticmethod
    def getScalarArray2D(contextSettings: ContextSettings, parameter: Parameter) -> cern.accsoft.commons.value.ImmutableScalarArray2D: ...
    @staticmethod
    def getScalarValue(setting: Setting, settingPartEnum: SettingPartEnum) -> cern.accsoft.commons.value.ImmutableScalar: ...
    @staticmethod
    def getUpdatedDrivableContexts(contextSettings: ContextSettings) -> java.util.Set['DrivableContext']: ...
    @typing.overload
    @staticmethod
    def getValue(contextSettings: ContextSettings, parameter: Parameter) -> cern.accsoft.commons.value.ImmutableValue: ...
    @typing.overload
    @staticmethod
    def getValue(setting: Setting, settingPartEnum: SettingPartEnum) -> cern.accsoft.commons.value.ImmutableValue: ...
    @staticmethod
    def groupSettingsByValueType(collection: typing.Union[java.util.Collection[Setting], typing.Sequence[Setting]]) -> java.util.Map[cern.accsoft.commons.value.Type, java.util.List[Setting]]: ...
    @staticmethod
    def hasCorrectLength(setting: Setting) -> bool: ...
    @staticmethod
    def hasUpdatedSetting(contextSettings: ContextSettings, set: java.util.Set[Parameter], beamProcess: 'BeamProcess') -> bool: ...
    @typing.overload
    @staticmethod
    def isContinue(immutableDiscreteFunction: cern.accsoft.commons.value.ImmutableDiscreteFunction, immutableDiscreteFunction2: cern.accsoft.commons.value.ImmutableDiscreteFunction) -> bool: ...
    @typing.overload
    @staticmethod
    def isContinue(setting: Setting, setting2: Setting) -> bool: ...
    @staticmethod
    def isInLimits(immutableValue: cern.accsoft.commons.value.ImmutableValue) -> bool: ...
    @staticmethod
    def updateScalar(immutableScalar: cern.accsoft.commons.value.ImmutableScalar, immutableScalar2: cern.accsoft.commons.value.ImmutableScalar, boolean: bool) -> cern.accsoft.commons.util.value.Pair[bool, cern.accsoft.commons.value.ImmutableScalar]: ...
    @staticmethod
    def valuesAreEqual(immutableValue: cern.accsoft.commons.value.ImmutableValue, immutableValue2: cern.accsoft.commons.value.ImmutableValue) -> bool: ...

class SettingsDeletionRequest:
    """
    Java class 'cern.lsa.domain.settings.SettingsDeletionRequest'
    
    """
    @staticmethod
    def builder() -> 'DefaultSettingsDeletionRequest.Builder': ...
    @staticmethod
    def byStandAloneContextAndParameters(standAloneContext: 'StandAloneContext', collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> 'SettingsDeletionRequest': ...
    def getContext(self) -> 'StandAloneContext': ...
    def getParameters(self) -> java.util.Set[Parameter]: ...

class SettingsSource(java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.SettingsSource'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
    """
    @staticmethod
    def forArchiveVersionSettings(archiveVersion: ArchiveVersion) -> 'SettingsSource': ...
    @staticmethod
    def forCurrentSettings() -> 'SettingsSource': ...
    @staticmethod
    def forHardwareSettings() -> 'SettingsSource': ...
    @staticmethod
    def forHistoricalSettings(date: java.util.Date) -> 'SettingsSource': ...
    @staticmethod
    def forReferenceSettings() -> 'SettingsSource': ...
    @staticmethod
    def forTrimSettings(trimHeader: 'TrimHeader') -> 'SettingsSource': ...
    @staticmethod
    def formatSettingsSource(settingsSource: 'SettingsSource') -> str: ...
    def getArchiveVersion(self) -> ArchiveVersion: ...
    def getDate(self) -> java.util.Date: ...
    def getTrimHeader(self) -> 'TrimHeader': ...
    def getType(self) -> 'SettingsSource.SettingsSourceType': ...
    def isValid(self) -> bool: ...
    def toString(self) -> str: ...
    class SettingsSourceType(java.lang.Enum['SettingsSource.SettingsSourceType']):
        """
        Java class 'cern.lsa.domain.settings.SettingsSource$SettingsSourceType'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            CURRENT_SETTINGS (cern.lsa.domain.settings.SettingsSource$SettingsSourceType): final static enum constant
            HISTORICAL_SETTINGS (cern.lsa.domain.settings.SettingsSource$SettingsSourceType): final static enum constant
            TRIM (cern.lsa.domain.settings.SettingsSource$SettingsSourceType): final static enum constant
            ARCHIVE_VERSION (cern.lsa.domain.settings.SettingsSource$SettingsSourceType): final static enum constant
            REFERENCE (cern.lsa.domain.settings.SettingsSource$SettingsSourceType): final static enum constant
            HARDWARE (cern.lsa.domain.settings.SettingsSource$SettingsSourceType): final static enum constant
        
        """
        CURRENT_SETTINGS: typing.ClassVar['SettingsSource.SettingsSourceType'] = ...
        HISTORICAL_SETTINGS: typing.ClassVar['SettingsSource.SettingsSourceType'] = ...
        TRIM: typing.ClassVar['SettingsSource.SettingsSourceType'] = ...
        ARCHIVE_VERSION: typing.ClassVar['SettingsSource.SettingsSourceType'] = ...
        REFERENCE: typing.ClassVar['SettingsSource.SettingsSourceType'] = ...
        HARDWARE: typing.ClassVar['SettingsSource.SettingsSourceType'] = ...
        _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'SettingsSource.SettingsSourceType': ...
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
        @staticmethod
        def values() -> typing.List['SettingsSource.SettingsSourceType']: ...

class StandAloneContextCloneRequest:
    """
    Java class 'cern.lsa.domain.settings.StandAloneContextCloneRequest'
    
    """
    def getAttributes(self) -> java.util.Set[cern.lsa.domain.commons.Attribute]: ...
    def getCloneName(self) -> str: ...
    def getContextCategory(self) -> ContextCategory: ...
    def getDescription(self) -> str: ...
    def getHistoryCutOff(self) -> java.time.Instant: ...
    def getSource(self) -> 'StandAloneContext': ...
    def shouldCloneType(self) -> bool: ...
    def withHistory(self) -> bool: ...

class StandAloneContextCreationRequest:
    """
    Java class 'cern.lsa.domain.settings.StandAloneContextCreationRequest'
    
    """
    def getAttributes(self) -> java.util.Set[cern.lsa.domain.commons.Attribute]: ...
    def getContextCategory(self) -> ContextCategory: ...
    def getContextType(self) -> cern.lsa.domain.settings.type.ContextType: ...
    def getDescription(self) -> str: ...
    def getLength(self) -> int: ...
    def getName(self) -> str: ...
    def isMultiplexed(self) -> bool: ...

class StandAloneContextFilter(cern.accsoft.commons.util.Filters.Filter['StandAloneContext']):
    """
    Java class 'cern.lsa.domain.settings.StandAloneContextFilter'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.accsoft.commons.util.Filters.Filter
    
      Constructors:
        * StandAloneContextFilter()
    
    """
    def __init__(self): ...
    def accepts(self, standAloneContext: 'StandAloneContext') -> bool: ...
    @staticmethod
    def categoryIn(collection: typing.Union[java.util.Collection[ContextCategory], typing.Sequence[ContextCategory]]) -> 'StandAloneContextFilter': ...
    def setCategories(self, collection: typing.Union[java.util.Collection[ContextCategory], typing.Sequence[ContextCategory]]) -> 'StandAloneContextFilter': ...

class TrimException(cern.lsa.domain.LsaException):
    """
    Java class 'cern.lsa.domain.settings.TrimException'
    
        Extends:
            cern.lsa.domain.LsaException
    
      Constructors:
        * TrimException(java.lang.String)
        * TrimException(java.lang.Exception)
        * TrimException(java.lang.String, java.lang.Exception)
    
    """
    @typing.overload
    def __init__(self, exception: java.lang.Exception): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, exception: java.lang.Exception): ...

class TrimHeader(cern.lsa.domain.commons.IdentifiedEntity):
    """
    Java class 'cern.lsa.domain.settings.TrimHeader'
    
        Interfaces:
            cern.lsa.domain.commons.IdentifiedEntity
    
    """
    def getBeamProcesses(self) -> java.util.List['BeamProcess']: ...
    def getClientInfo(self) -> str: ...
    def getCreatedDate(self) -> java.util.Date: ...
    def getDescription(self) -> str: ...

class TrimHeadersRequest(java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.TrimHeadersRequest'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
    """
    @staticmethod
    def builder() -> 'TrimHeadersRequestBuilder': ...
    @staticmethod
    def byBeamProcessesAndParameters(collection: typing.Union[java.util.Collection['BeamProcess'], typing.Sequence['BeamProcess']], collection2: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> 'TrimHeadersRequest': ...
    def getBeamProcesses(self) -> java.util.Collection['BeamProcess']: ...
    def getMaxLastTrimsNumber(self) -> int: ...
    def getParameters(self) -> java.util.Collection[Parameter]: ...
    def getStartingFrom(self) -> java.time.Instant: ...
    def toString(self) -> str: ...

class TrimHeadersRequestBuilder:
    """
    Java class 'cern.lsa.domain.settings.TrimHeadersRequestBuilder'
    
        Extends:
            java.lang.Object
    
      Constructors:
        * TrimHeadersRequestBuilder()
    
    """
    def __init__(self): ...
    def beamProcesses(self, collection: typing.Union[java.util.Collection['BeamProcess'], typing.Sequence['BeamProcess']]) -> 'TrimHeadersRequestBuilder': ...
    def build(self) -> TrimHeadersRequest: ...
    @staticmethod
    def byBeamProcessesAndParameters(collection: typing.Union[java.util.Collection['BeamProcess'], typing.Sequence['BeamProcess']], collection2: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> TrimHeadersRequest: ...
    def maxLastTrimsNumber(self, integer: int) -> 'TrimHeadersRequestBuilder': ...
    def parameters(self, collection: typing.Union[java.util.Collection[Parameter], typing.Sequence[Parameter]]) -> 'TrimHeadersRequestBuilder': ...
    def startingFrom(self, instant: typing.Union[java.time.Instant, datetime.datetime]) -> 'TrimHeadersRequestBuilder': ...

class TrimRequest:
    """
    Java class 'cern.lsa.domain.settings.TrimRequest'
    
    """
    @typing.overload
    @staticmethod
    def builder() -> cern.lsa.domain.settings.factory.TrimRequestBuilder: ...
    @typing.overload
    @staticmethod
    def builder(trimRequest: 'TrimRequest') -> cern.lsa.domain.settings.factory.TrimRequestBuilder: ...
    def getAttribute(self, string: str) -> typing.Any: ...
    def getAttributes(self) -> java.util.Map[str, typing.Any]: ...
    def getChildSettingPart(self) -> SettingPartEnum: ...
    def getContext(self) -> 'StandAloneContext': ...
    def getContextSettings(self) -> ContextSettings: ...
    def getCustomSettingPart(self, parameter: Parameter) -> SettingPartEnum: ...
    def getCustomSettingPartMap(self) -> java.util.Map[Parameter, SettingPartEnum]: ...
    def getDescription(self) -> str: ...
    def getParameters(self) -> java.util.Set[Parameter]: ...
    def getSettingPart(self) -> SettingPartEnum: ...
    def isCommit(self) -> bool: ...
    def isDrive(self) -> bool: ...
    def isForceDrive(self) -> bool: ...
    def isForceProcessing(self) -> bool: ...
    def isIgnoreErrors(self) -> bool: ...
    def isLenientDrive(self) -> bool: ...
    def isPersistSettings(self) -> bool: ...
    def isPropagateToChildren(self) -> bool: ...
    def isRelative(self) -> bool: ...
    def isReturnSettings(self) -> bool: ...
    def isSkipProcessing(self) -> bool: ...
    def setAttribute(self, string: str, object: typing.Any) -> None: ...
    def setSettingPart(self, settingPartEnum: SettingPartEnum) -> None: ...

class TrimResponse:
    """
    Java class 'cern.lsa.domain.settings.TrimResponse'
    
    """
    def getDriveResult(self) -> cern.lsa.domain.exploitation.DriveResult: ...
    def getTrimResult(self) -> 'TrimResult': ...
    def isDrivePerformed(self) -> bool: ...

class TrimResult:
    """
    Java class 'cern.lsa.domain.settings.TrimResult'
    
    """
    def getAttribute(self, string: str) -> java.io.Serializable: ...
    def getContext(self) -> 'StandAloneContext': ...
    def getContextSettings(self) -> ContextSettings: ...
    def getTrimHeader(self) -> TrimHeader: ...
    def getTrimRequest(self) -> TrimRequest: ...
    def getWarnings(self) -> java.util.List[cern.accsoft.commons.util.value.Pair[str, java.lang.Throwable]]: ...

class UserContextMapping:
    """
    Java class 'cern.lsa.domain.settings.UserContextMapping'
    
    """
    def equalByName(self, userContextMapping: 'UserContextMapping') -> bool: ...
    def getContextName(self) -> str: ...
    def getContextParent(self) -> str: ...
    def getMappingTimestamp(self) -> int: ...
    def getOperationType(self) -> 'UserContextMapping.OperationType': ...
    def getUser(self) -> str: ...
    def isResident(self) -> bool: ...
    class OperationType(java.lang.Enum['UserContextMapping.OperationType']):
        """
        Java class 'cern.lsa.domain.settings.UserContextMapping$OperationType'
        
            Extends:
                java.lang.Enum
        
          Attributes:
            INSERT (cern.lsa.domain.settings.UserContextMapping$OperationType): final static enum constant
            DELETE (cern.lsa.domain.settings.UserContextMapping$OperationType): final static enum constant
            UPDATE (cern.lsa.domain.settings.UserContextMapping$OperationType): final static enum constant
        
        """
        INSERT: typing.ClassVar['UserContextMapping.OperationType'] = ...
        DELETE: typing.ClassVar['UserContextMapping.OperationType'] = ...
        UPDATE: typing.ClassVar['UserContextMapping.OperationType'] = ...
        @staticmethod
        def fromString(string: str) -> 'UserContextMapping.OperationType': ...
        _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'UserContextMapping.OperationType': ...
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
        @staticmethod
        def values() -> typing.List['UserContextMapping.OperationType']: ...

class CopySettingsRequest(TrimRequest):
    """
    Java class 'cern.lsa.domain.settings.CopySettingsRequest'
    
        Interfaces:
            cern.lsa.domain.settings.TrimRequest
    
    """
    @staticmethod
    def builder() -> cern.lsa.domain.settings.factory.CopySettingsRequestBuilder: ...
    def getDestinationContexts(self) -> java.util.List[Context]: ...
    def getDestinationParameters(self) -> java.util.Set[Parameter]: ...
    def getSettingsSource(self) -> SettingsSource: ...
    def getSourceContexts(self) -> java.util.List[Context]: ...

class CriticalParameterException(TrimException):
    """
    Java class 'cern.lsa.domain.settings.CriticalParameterException'
    
        Extends:
            cern.lsa.domain.settings.TrimException
    
      Constructors:
        * CriticalParameterException(java.lang.String)
        * CriticalParameterException(java.lang.Exception)
        * CriticalParameterException(java.lang.String, java.lang.Exception)
    
    """
    @typing.overload
    def __init__(self, exception: java.lang.Exception): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, exception: java.lang.Exception): ...

class CycleIntersections(ContextIntersections):
    """
    Java class 'cern.lsa.domain.settings.CycleIntersections'
    
        Interfaces:
            cern.lsa.domain.settings.ContextIntersections
    
    """
    def getBeamProcesses(self) -> java.util.Set['BeamProcess']: ...
    def getCycleName(self) -> str: ...
    def getFollowingBeamProcess(self, beamProcess: 'BeamProcess') -> 'BeamProcess': ...
    def getIntersectedBeamProcesses(self, particleTransfer: cern.accsoft.commons.domain.particletransfers.ParticleTransfer) -> java.util.Set['BeamProcess']: ...
    def getIntersectedFunctionBeamProcess(self, particleTransfer: cern.accsoft.commons.domain.particletransfers.ParticleTransfer, double: float) -> BeamProcessIntersection: ...
    def getIntersectedFunctionBeamProcesses(self, particleTransfer: cern.accsoft.commons.domain.particletransfers.ParticleTransfer, double: float) -> java.util.List[BeamProcessIntersection]: ...
    def getParticleTransfers(self) -> java.util.Set[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]: ...
    def getPrecedingBeamProcess(self, beamProcess: 'BeamProcess') -> 'BeamProcess': ...
    def size(self) -> int: ...

class DefaultAcceleratorUser(AcceleratorUser, java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.DefaultAcceleratorUser'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.lsa.domain.settings.AcceleratorUser, java.io.Serializable
    
    """
    @staticmethod
    def builder() -> 'DefaultAcceleratorUser.Builder': ...
    @staticmethod
    def copyOf(acceleratorUser: AcceleratorUser) -> 'DefaultAcceleratorUser': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAccelerator(self) -> cern.accsoft.commons.domain.Accelerator: ...
    def getAcceleratorUserGroup(self) -> AcceleratorUserGroup: ...
    def getId(self) -> int: ...
    def getName(self) -> str: ...
    def hashCode(self) -> int: ...
    def isMultiplexed(self) -> bool: ...
    def toString(self) -> str: ...
    def withAccelerator(self, accelerator: cern.accsoft.commons.domain.Accelerator) -> 'DefaultAcceleratorUser': ...
    def withAcceleratorUserGroup(self, acceleratorUserGroup: AcceleratorUserGroup) -> 'DefaultAcceleratorUser': ...
    def withId(self, long: int) -> 'DefaultAcceleratorUser': ...
    def withMultiplexed(self, boolean: bool) -> 'DefaultAcceleratorUser': ...
    def withName(self, string: str) -> 'DefaultAcceleratorUser': ...
    class Builder:
        """
        Java class 'cern.lsa.domain.settings.DefaultAcceleratorUser$Builder'
        
            Extends:
                java.lang.Object
        
        """
        def accelerator(self, accelerator: cern.accsoft.commons.domain.Accelerator) -> 'DefaultAcceleratorUser.Builder': ...
        def acceleratorUserGroup(self, acceleratorUserGroup: AcceleratorUserGroup) -> 'DefaultAcceleratorUser.Builder': ...
        def build(self) -> 'DefaultAcceleratorUser': ...
        def id(self, long: int) -> 'DefaultAcceleratorUser.Builder': ...
        def multiplexed(self, boolean: bool) -> 'DefaultAcceleratorUser.Builder': ...
        def name(self, string: str) -> 'DefaultAcceleratorUser.Builder': ...

class DefaultAcceleratorUserGroup(AcceleratorUserGroup, java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.DefaultAcceleratorUserGroup'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.lsa.domain.settings.AcceleratorUserGroup,
            java.io.Serializable
    
    """
    @staticmethod
    def builder() -> 'DefaultAcceleratorUserGroup.Builder': ...
    @staticmethod
    def copyOf(acceleratorUserGroup: AcceleratorUserGroup) -> 'DefaultAcceleratorUserGroup': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDescription(self) -> str: ...
    def getId(self) -> int: ...
    def getName(self) -> str: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...
    def withDescription(self, string: str) -> 'DefaultAcceleratorUserGroup': ...
    def withId(self, long: int) -> 'DefaultAcceleratorUserGroup': ...
    def withName(self, string: str) -> 'DefaultAcceleratorUserGroup': ...
    class Builder:
        """
        Java class 'cern.lsa.domain.settings.DefaultAcceleratorUserGroup$Builder'
        
            Extends:
                java.lang.Object
        
        """
        def build(self) -> 'DefaultAcceleratorUserGroup': ...
        def description(self, string: str) -> 'DefaultAcceleratorUserGroup.Builder': ...
        def id(self, long: int) -> 'DefaultAcceleratorUserGroup.Builder': ...
        def name(self, string: str) -> 'DefaultAcceleratorUserGroup.Builder': ...

class DefaultAcceleratorUsersRequest(AcceleratorUsersRequest, java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.DefaultAcceleratorUsersRequest'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.lsa.domain.settings.AcceleratorUsersRequest,
            java.io.Serializable
    
    """
    @staticmethod
    def builder() -> 'DefaultAcceleratorUsersRequest.Builder': ...
    @staticmethod
    def copyOf(acceleratorUsersRequest: AcceleratorUsersRequest) -> 'DefaultAcceleratorUsersRequest': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAccelerator(self) -> cern.accsoft.commons.domain.Accelerator: ...
    def getAcceleratorUserGroupName(self) -> str: ...
    def getAcceleratorUserNames(self) -> com.google.common.collect.ImmutableSet[str]: ...
    def getIds(self) -> com.google.common.collect.ImmutableSet[int]: ...
    def hashCode(self) -> int: ...
    def isMultiplexed(self) -> bool: ...
    def toString(self) -> str: ...
    def withAccelerator(self, accelerator: cern.accsoft.commons.domain.Accelerator) -> 'DefaultAcceleratorUsersRequest': ...
    def withAcceleratorUserGroupName(self, string: str) -> 'DefaultAcceleratorUsersRequest': ...
    @typing.overload
    def withAcceleratorUserNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultAcceleratorUsersRequest': ...
    @typing.overload
    def withAcceleratorUserNames(self, stringArray: typing.List[str]) -> 'DefaultAcceleratorUsersRequest': ...
    @typing.overload
    def withIds(self, iterable: java.lang.Iterable[int]) -> 'DefaultAcceleratorUsersRequest': ...
    @typing.overload
    def withIds(self, longArray: typing.List[int]) -> 'DefaultAcceleratorUsersRequest': ...
    def withMultiplexed(self, boolean: bool) -> 'DefaultAcceleratorUsersRequest': ...
    class Builder:
        """
        Java class 'cern.lsa.domain.settings.DefaultAcceleratorUsersRequest$Builder'
        
            Extends:
                java.lang.Object
        
        """
        def accelerator(self, accelerator: cern.accsoft.commons.domain.Accelerator) -> 'DefaultAcceleratorUsersRequest.Builder': ...
        def acceleratorUserGroupName(self, string: str) -> 'DefaultAcceleratorUsersRequest.Builder': ...
        def acceleratorUserNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultAcceleratorUsersRequest.Builder': ...
        def addAcceleratorUserName(self, string: str) -> 'DefaultAcceleratorUsersRequest.Builder': ...
        def addAcceleratorUserNames(self, stringArray: typing.List[str]) -> 'DefaultAcceleratorUsersRequest.Builder': ...
        def addAllAcceleratorUserNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultAcceleratorUsersRequest.Builder': ...
        def addAllIds(self, iterable: java.lang.Iterable[int]) -> 'DefaultAcceleratorUsersRequest.Builder': ...
        def addId(self, long: int) -> 'DefaultAcceleratorUsersRequest.Builder': ...
        def addIds(self, longArray: typing.List[int]) -> 'DefaultAcceleratorUsersRequest.Builder': ...
        def build(self) -> 'DefaultAcceleratorUsersRequest': ...
        def ids(self, iterable: java.lang.Iterable[int]) -> 'DefaultAcceleratorUsersRequest.Builder': ...
        def multiplexed(self, boolean: bool) -> 'DefaultAcceleratorUsersRequest.Builder': ...

class DefaultHyperCycleMapping(HyperCycleMapping, java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.DefaultHyperCycleMapping'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.lsa.domain.settings.HyperCycleMapping,
            java.io.Serializable
    
    """
    @staticmethod
    def builder() -> 'DefaultHyperCycleMapping.Builder': ...
    @staticmethod
    def copyOf(hyperCycleMapping: HyperCycleMapping) -> 'DefaultHyperCycleMapping': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getBeamProcess(self) -> 'StandAloneBeamProcess': ...
    def getUser(self) -> AcceleratorUser: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...
    def withBeamProcess(self, standAloneBeamProcess: 'StandAloneBeamProcess') -> 'DefaultHyperCycleMapping': ...
    def withUser(self, acceleratorUser: AcceleratorUser) -> 'DefaultHyperCycleMapping': ...
    class Builder:
        """
        Java class 'cern.lsa.domain.settings.DefaultHyperCycleMapping$Builder'
        
            Extends:
                java.lang.Object
        
        """
        def beamProcess(self, standAloneBeamProcess: 'StandAloneBeamProcess') -> 'DefaultHyperCycleMapping.Builder': ...
        def build(self) -> 'DefaultHyperCycleMapping': ...
        def user(self, acceleratorUser: AcceleratorUser) -> 'DefaultHyperCycleMapping.Builder': ...

class DefaultSettingsDeletionRequest(SettingsDeletionRequest, java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.DefaultSettingsDeletionRequest'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.lsa.domain.settings.SettingsDeletionRequest,
            java.io.Serializable
    
    """
    @staticmethod
    def builder() -> 'DefaultSettingsDeletionRequest.Builder': ...
    @staticmethod
    def copyOf(settingsDeletionRequest: SettingsDeletionRequest) -> 'DefaultSettingsDeletionRequest': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getContext(self) -> 'StandAloneContext': ...
    def getParameters(self) -> com.google.common.collect.ImmutableSet[Parameter]: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...
    def withContext(self, standAloneContext: 'StandAloneContext') -> 'DefaultSettingsDeletionRequest': ...
    @typing.overload
    def withParameters(self, parameterArray: typing.List[Parameter]) -> 'DefaultSettingsDeletionRequest': ...
    @typing.overload
    def withParameters(self, iterable: java.lang.Iterable[Parameter]) -> 'DefaultSettingsDeletionRequest': ...
    class Builder:
        """
        Java class 'cern.lsa.domain.settings.DefaultSettingsDeletionRequest$Builder'
        
            Extends:
                java.lang.Object
        
        """
        def addAllParameters(self, iterable: java.lang.Iterable[Parameter]) -> 'DefaultSettingsDeletionRequest.Builder': ...
        def addParameter(self, parameter: Parameter) -> 'DefaultSettingsDeletionRequest.Builder': ...
        def addParameters(self, parameterArray: typing.List[Parameter]) -> 'DefaultSettingsDeletionRequest.Builder': ...
        def build(self) -> 'DefaultSettingsDeletionRequest': ...
        def context(self, standAloneContext: 'StandAloneContext') -> 'DefaultSettingsDeletionRequest.Builder': ...
        def parameters(self, iterable: java.lang.Iterable[Parameter]) -> 'DefaultSettingsDeletionRequest.Builder': ...

class DrivableContext(Context):
    """
    Java class 'cern.lsa.domain.settings.DrivableContext'
    
        Interfaces:
            cern.lsa.domain.settings.Context
    
    """
    def getUser(self) -> str: ...

class IncorporationRequest(TrimRequest):
    """
    Java class 'cern.lsa.domain.settings.IncorporationRequest'
    
        Interfaces:
            cern.lsa.domain.settings.TrimRequest
    
    """
    @staticmethod
    def builder() -> cern.lsa.domain.settings.factory.IncorporationRequestBuilder: ...
    def getIncorporationSettings(self) -> java.util.Set[IncorporationSetting]: ...
    def shouldIncorporate(self, parameter: Parameter) -> bool: ...

class Knob(Parameter):
    """
    Java class 'cern.lsa.domain.settings.Knob'
    
        Interfaces:
            cern.lsa.domain.settings.Parameter
    
    """
    def getComponentNames(self) -> java.util.Set[str]: ...
    def getKnobFactors(self) -> KnobFactors: ...
    def getOpticNames(self) -> java.util.Set[str]: ...

class RevertTrimRequest(TrimRequest):
    """
    Java class 'cern.lsa.domain.settings.RevertTrimRequest'
    
        Interfaces:
            cern.lsa.domain.settings.TrimRequest
    
    """
    @staticmethod
    def builder() -> cern.lsa.domain.settings.factory.RevertTrimRequestBuilder: ...
    def getBeamProcesses(self) -> java.util.Set['BeamProcess']: ...
    def getTrimHeader(self) -> TrimHeader: ...

class SettingsGenerationRequest(TrimRequest):
    """
    Java class 'cern.lsa.domain.settings.SettingsGenerationRequest'
    
        Interfaces:
            cern.lsa.domain.settings.TrimRequest
    
    """
    @staticmethod
    def builder() -> cern.lsa.domain.settings.factory.SettingsGenerationRequestBuilder: ...
    def getSubContexts(self) -> java.util.Set['SubContext']: ...
    def isGenerateZeroSettings(self) -> bool: ...

class SettingsRestoreStatus(FailedParametersStatus):
    """
    Java class 'cern.lsa.domain.settings.SettingsRestoreStatus'
    
        Interfaces:
            cern.lsa.domain.settings.FailedParametersStatus
    
    """
    def getSettings(self) -> CompositeContextSettings: ...

class StandAloneContext(Context, cern.lsa.domain.commons.AttributeAware):
    """
    Java class 'cern.lsa.domain.settings.StandAloneContext'
    
        Interfaces:
            cern.lsa.domain.settings.Context,
            cern.lsa.domain.commons.AttributeAware
    
    """
    def getBeamProcesses(self) -> java.util.List['BeamProcess']: ...
    def getContextCategory(self) -> ContextCategory: ...
    def getParticleTransfers(self) -> java.util.Set[cern.accsoft.commons.domain.particletransfers.ParticleTransfer]: ...
    def isResident(self) -> bool: ...

class SubContext(Context):
    """
    Java class 'cern.lsa.domain.settings.SubContext'
    
        Interfaces:
            cern.lsa.domain.settings.Context
    
    """
    def getStartTime(self) -> int: ...

class BeamProcess(SubContext):
    """
    Java class 'cern.lsa.domain.settings.BeamProcess'
    
        Interfaces:
            cern.lsa.domain.settings.SubContext
    
    """
    def getCategory(self) -> cern.lsa.domain.settings.type.BeamProcessTypeCategory: ...
    def getParticleTransfer(self) -> cern.accsoft.commons.domain.particletransfers.ParticleTransfer: ...
    def getPurpose(self) -> cern.lsa.domain.settings.type.BeamProcessPurpose: ...

class BeamProductionChain(SubContext):
    """
    Java class 'cern.lsa.domain.settings.BeamProductionChain'
    
        Interfaces:
            cern.lsa.domain.settings.SubContext
    
    """
    def getBeamProcesses(self) -> java.util.List['DrivableBeamProcess']: ...

class Cycle(SubContext, DrivableContext): ...

class Pattern(StandAloneContext):
    """
    Java class 'cern.lsa.domain.settings.Pattern'
    
        Interfaces:
            cern.lsa.domain.settings.StandAloneContext
    
    """
    def getDrivableBeamProcesses(self) -> java.util.List['DrivableBeamProcess']: ...

class DrivableBeamProcess(BeamProcess, DrivableContext): ...

class StandAloneCycle(StandAloneContext, Cycle):
    """
    Java class 'cern.lsa.domain.settings.StandAloneCycle'
    
        Interfaces:
            cern.lsa.domain.settings.StandAloneContext,
            cern.lsa.domain.settings.Cycle
    
    """
    def getIntersections(self) -> CycleIntersections: ...

class StandAloneBeamProcess(StandAloneContext, DrivableBeamProcess):
    """
    Java class 'cern.lsa.domain.settings.StandAloneBeamProcess'
    
        Interfaces:
            cern.lsa.domain.settings.StandAloneContext,
            cern.lsa.domain.settings.DrivableBeamProcess
    
    """
    def getActualBeamProcessInfo(self) -> ActualBeamProcessInfo: ...
    def isActual(self) -> bool: ...

class DefaultStandAloneBeamProcessesRequest(cern.lsa.domain.settings.StandAloneBeamProcessesRequest, java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.DefaultStandAloneBeamProcessesRequest'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.lsa.domain.settings.StandAloneBeamProcessesRequest,
            java.io.Serializable
    
    """
    @staticmethod
    def builder() -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...
    @staticmethod
    def copyOf(standAloneBeamProcessesRequest: 'StandAloneBeamProcessesRequest') -> 'DefaultStandAloneBeamProcessesRequest': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAccelerator(self) -> cern.accsoft.commons.domain.Accelerator: ...
    def getBeamProcessNames(self) -> com.google.common.collect.ImmutableSet[str]: ...
    def getIds(self) -> com.google.common.collect.ImmutableSet[int]: ...
    def hashCode(self) -> int: ...
    def isMultiplexed(self) -> bool: ...
    def isResident(self) -> bool: ...
    def toString(self) -> str: ...
    def withAccelerator(self, accelerator: cern.accsoft.commons.domain.Accelerator) -> 'DefaultStandAloneBeamProcessesRequest': ...
    @typing.overload
    def withBeamProcessNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultStandAloneBeamProcessesRequest': ...
    @typing.overload
    def withBeamProcessNames(self, stringArray: typing.List[str]) -> 'DefaultStandAloneBeamProcessesRequest': ...
    @typing.overload
    def withIds(self, iterable: java.lang.Iterable[int]) -> 'DefaultStandAloneBeamProcessesRequest': ...
    @typing.overload
    def withIds(self, longArray: typing.List[int]) -> 'DefaultStandAloneBeamProcessesRequest': ...
    def withMultiplexed(self, boolean: bool) -> 'DefaultStandAloneBeamProcessesRequest': ...
    def withResident(self, boolean: bool) -> 'DefaultStandAloneBeamProcessesRequest': ...
    class Builder:
        """
        Java class 'cern.lsa.domain.settings.DefaultStandAloneBeamProcessesRequest$Builder'
        
            Extends:
                java.lang.Object
        
        """
        def accelerator(self, accelerator: cern.accsoft.commons.domain.Accelerator) -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...
        def addAllBeamProcessNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...
        def addAllIds(self, iterable: java.lang.Iterable[int]) -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...
        def addBeamProcessName(self, string: str) -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...
        def addBeamProcessNames(self, stringArray: typing.List[str]) -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...
        def addId(self, long: int) -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...
        def addIds(self, longArray: typing.List[int]) -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...
        def beamProcessNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...
        def build(self) -> 'DefaultStandAloneBeamProcessesRequest': ...
        def ids(self, iterable: java.lang.Iterable[int]) -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...
        def multiplexed(self, boolean: bool) -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...
        def resident(self, boolean: bool) -> 'DefaultStandAloneBeamProcessesRequest.Builder': ...

class DefaultStandAloneContextsRequest(cern.lsa.domain.settings.StandAloneContextsRequest, java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.DefaultStandAloneContextsRequest'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.lsa.domain.settings.StandAloneContextsRequest,
            java.io.Serializable
    
    """
    @staticmethod
    def builder() -> 'DefaultStandAloneContextsRequest.Builder': ...
    @staticmethod
    def copyOf(standAloneContextsRequest: 'StandAloneContextsRequest') -> 'DefaultStandAloneContextsRequest': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAccelerator(self) -> cern.accsoft.commons.domain.Accelerator: ...
    def getContextNames(self) -> com.google.common.collect.ImmutableSet[str]: ...
    def getIds(self) -> com.google.common.collect.ImmutableSet[int]: ...
    def hashCode(self) -> int: ...
    def isMultiplexed(self) -> bool: ...
    def isResident(self) -> bool: ...
    def toString(self) -> str: ...
    def withAccelerator(self, accelerator: cern.accsoft.commons.domain.Accelerator) -> 'DefaultStandAloneContextsRequest': ...
    @typing.overload
    def withContextNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultStandAloneContextsRequest': ...
    @typing.overload
    def withContextNames(self, stringArray: typing.List[str]) -> 'DefaultStandAloneContextsRequest': ...
    @typing.overload
    def withIds(self, iterable: java.lang.Iterable[int]) -> 'DefaultStandAloneContextsRequest': ...
    @typing.overload
    def withIds(self, longArray: typing.List[int]) -> 'DefaultStandAloneContextsRequest': ...
    def withMultiplexed(self, boolean: bool) -> 'DefaultStandAloneContextsRequest': ...
    def withResident(self, boolean: bool) -> 'DefaultStandAloneContextsRequest': ...
    class Builder:
        """
        Java class 'cern.lsa.domain.settings.DefaultStandAloneContextsRequest$Builder'
        
            Extends:
                java.lang.Object
        
        """
        def accelerator(self, accelerator: cern.accsoft.commons.domain.Accelerator) -> 'DefaultStandAloneContextsRequest.Builder': ...
        def addAllContextNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultStandAloneContextsRequest.Builder': ...
        def addAllIds(self, iterable: java.lang.Iterable[int]) -> 'DefaultStandAloneContextsRequest.Builder': ...
        def addContextName(self, string: str) -> 'DefaultStandAloneContextsRequest.Builder': ...
        def addContextNames(self, stringArray: typing.List[str]) -> 'DefaultStandAloneContextsRequest.Builder': ...
        def addId(self, long: int) -> 'DefaultStandAloneContextsRequest.Builder': ...
        def addIds(self, longArray: typing.List[int]) -> 'DefaultStandAloneContextsRequest.Builder': ...
        def build(self) -> 'DefaultStandAloneContextsRequest': ...
        def contextNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultStandAloneContextsRequest.Builder': ...
        def ids(self, iterable: java.lang.Iterable[int]) -> 'DefaultStandAloneContextsRequest.Builder': ...
        def multiplexed(self, boolean: bool) -> 'DefaultStandAloneContextsRequest.Builder': ...
        def resident(self, boolean: bool) -> 'DefaultStandAloneContextsRequest.Builder': ...

class DefaultStandAloneCyclesRequest(cern.lsa.domain.settings.StandAloneCyclesRequest, java.io.Serializable):
    """
    Java class 'cern.lsa.domain.settings.DefaultStandAloneCyclesRequest'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            cern.lsa.domain.settings.StandAloneCyclesRequest,
            java.io.Serializable
    
    """
    @staticmethod
    def builder() -> 'DefaultStandAloneCyclesRequest.Builder': ...
    @staticmethod
    def copyOf(standAloneCyclesRequest: 'StandAloneCyclesRequest') -> 'DefaultStandAloneCyclesRequest': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAccelerator(self) -> cern.accsoft.commons.domain.Accelerator: ...
    def getCycleNames(self) -> com.google.common.collect.ImmutableSet[str]: ...
    def getIds(self) -> com.google.common.collect.ImmutableSet[int]: ...
    def hashCode(self) -> int: ...
    def isMultiplexed(self) -> bool: ...
    def isResident(self) -> bool: ...
    def toString(self) -> str: ...
    def withAccelerator(self, accelerator: cern.accsoft.commons.domain.Accelerator) -> 'DefaultStandAloneCyclesRequest': ...
    @typing.overload
    def withCycleNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultStandAloneCyclesRequest': ...
    @typing.overload
    def withCycleNames(self, stringArray: typing.List[str]) -> 'DefaultStandAloneCyclesRequest': ...
    @typing.overload
    def withIds(self, iterable: java.lang.Iterable[int]) -> 'DefaultStandAloneCyclesRequest': ...
    @typing.overload
    def withIds(self, longArray: typing.List[int]) -> 'DefaultStandAloneCyclesRequest': ...
    def withMultiplexed(self, boolean: bool) -> 'DefaultStandAloneCyclesRequest': ...
    def withResident(self, boolean: bool) -> 'DefaultStandAloneCyclesRequest': ...
    class Builder:
        """
        Java class 'cern.lsa.domain.settings.DefaultStandAloneCyclesRequest$Builder'
        
            Extends:
                java.lang.Object
        
        """
        def accelerator(self, accelerator: cern.accsoft.commons.domain.Accelerator) -> 'DefaultStandAloneCyclesRequest.Builder': ...
        def addAllCycleNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultStandAloneCyclesRequest.Builder': ...
        def addAllIds(self, iterable: java.lang.Iterable[int]) -> 'DefaultStandAloneCyclesRequest.Builder': ...
        def addCycleName(self, string: str) -> 'DefaultStandAloneCyclesRequest.Builder': ...
        def addCycleNames(self, stringArray: typing.List[str]) -> 'DefaultStandAloneCyclesRequest.Builder': ...
        def addId(self, long: int) -> 'DefaultStandAloneCyclesRequest.Builder': ...
        def addIds(self, longArray: typing.List[int]) -> 'DefaultStandAloneCyclesRequest.Builder': ...
        def build(self) -> 'DefaultStandAloneCyclesRequest': ...
        def cycleNames(self, iterable: java.lang.Iterable[str]) -> 'DefaultStandAloneCyclesRequest.Builder': ...
        def ids(self, iterable: java.lang.Iterable[int]) -> 'DefaultStandAloneCyclesRequest.Builder': ...
        def multiplexed(self, boolean: bool) -> 'DefaultStandAloneCyclesRequest.Builder': ...
        def resident(self, boolean: bool) -> 'DefaultStandAloneCyclesRequest.Builder': ...

class StandAloneBeamProcessesRequest(cern.lsa.domain.settings.BaseStandAloneContextsRequest):
    """
    Java class 'cern.lsa.domain.settings.StandAloneBeamProcessesRequest'
    
        Interfaces:
            cern.lsa.domain.settings.BaseStandAloneContextsRequest
    
    """
    @staticmethod
    def builder() -> DefaultStandAloneBeamProcessesRequest.Builder: ...
    @staticmethod
    def byAccelerator(accelerator: cern.accsoft.commons.domain.Accelerator) -> 'StandAloneBeamProcessesRequest': ...
    @staticmethod
    def byBeamProcessName(string: str) -> 'StandAloneBeamProcessesRequest': ...
    def getBeamProcessNames(self) -> java.util.Set[str]: ...

class StandAloneContextsRequest(cern.lsa.domain.settings.BaseStandAloneContextsRequest):
    """
    Java class 'cern.lsa.domain.settings.StandAloneContextsRequest'
    
        Interfaces:
            cern.lsa.domain.settings.BaseStandAloneContextsRequest
    
    """
    @staticmethod
    def builder() -> DefaultStandAloneContextsRequest.Builder: ...
    @staticmethod
    def byAccelerator(accelerator: cern.accsoft.commons.domain.Accelerator) -> 'StandAloneContextsRequest': ...
    @staticmethod
    def byContextName(string: str) -> 'StandAloneContextsRequest': ...
    def getContextNames(self) -> java.util.Set[str]: ...

class StandAloneCyclesRequest(cern.lsa.domain.settings.BaseStandAloneContextsRequest):
    """
    Java class 'cern.lsa.domain.settings.StandAloneCyclesRequest'
    
        Interfaces:
            cern.lsa.domain.settings.BaseStandAloneContextsRequest
    
    """
    @staticmethod
    def builder() -> DefaultStandAloneCyclesRequest.Builder: ...
    @staticmethod
    def byAccelerator(accelerator: cern.accsoft.commons.domain.Accelerator) -> 'StandAloneCyclesRequest': ...
    @staticmethod
    def byCycleName(string: str) -> 'StandAloneCyclesRequest': ...
    def getCycleNames(self) -> java.util.Set[str]: ...

class BaseStandAloneContextsRequest: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("cern.lsa.domain.settings")``.

    AcceleratorUser: typing.Type[AcceleratorUser]
    AcceleratorUserGroup: typing.Type[AcceleratorUserGroup]
    AcceleratorUsersRequest: typing.Type[AcceleratorUsersRequest]
    ActualBeamProcessInfo: typing.Type[ActualBeamProcessInfo]
    Archive: typing.Type[Archive]
    ArchiveVersion: typing.Type[ArchiveVersion]
    BaseStandAloneContextsRequest: typing.Type[BaseStandAloneContextsRequest]
    BeamProcess: typing.Type[BeamProcess]
    BeamProcessIncorporationRequest: typing.Type[BeamProcessIncorporationRequest]
    BeamProcessIntersection: typing.Type[BeamProcessIntersection]
    BeamProductionChain: typing.Type[BeamProductionChain]
    CompositeContextSettings: typing.Type[CompositeContextSettings]
    Context: typing.Type[Context]
    ContextCategory: typing.Type[ContextCategory]
    ContextFamily: typing.Type[ContextFamily]
    ContextIntersections: typing.Type[ContextIntersections]
    ContextOptics: typing.Type[ContextOptics]
    ContextSettings: typing.Type[ContextSettings]
    ContextSettingsRequest: typing.Type[ContextSettingsRequest]
    ContextSettingsRequestBuilder: typing.Type[ContextSettingsRequestBuilder]
    ContextTypeFilter: typing.Type[ContextTypeFilter]
    ContextTypes: typing.Type[ContextTypes]
    Contexts: typing.Type[Contexts]
    CopySettingsRequest: typing.Type[CopySettingsRequest]
    CriticalParameterException: typing.Type[CriticalParameterException]
    Cycle: typing.Type[Cycle]
    CycleBeamProcessIntersection: typing.Type[CycleBeamProcessIntersection]
    CycleIntersections: typing.Type[CycleIntersections]
    DefaultAcceleratorUser: typing.Type[DefaultAcceleratorUser]
    DefaultAcceleratorUserGroup: typing.Type[DefaultAcceleratorUserGroup]
    DefaultAcceleratorUsersRequest: typing.Type[DefaultAcceleratorUsersRequest]
    DefaultHyperCycleMapping: typing.Type[DefaultHyperCycleMapping]
    DefaultSettingsDeletionRequest: typing.Type[DefaultSettingsDeletionRequest]
    DefaultStandAloneBeamProcessesRequest: typing.Type[DefaultStandAloneBeamProcessesRequest]
    DefaultStandAloneContextsRequest: typing.Type[DefaultStandAloneContextsRequest]
    DefaultStandAloneCyclesRequest: typing.Type[DefaultStandAloneCyclesRequest]
    DevicePropertyParameters: typing.Type[DevicePropertyParameters]
    DrivableBeamProcess: typing.Type[DrivableBeamProcess]
    DrivableContext: typing.Type[DrivableContext]
    ErrorsAwareContextSettings: typing.Type[ErrorsAwareContextSettings]
    FailedParametersStatus: typing.Type[FailedParametersStatus]
    GenerationException: typing.Type[GenerationException]
    HyperCycle: typing.Type[HyperCycle]
    HyperCycleMapping: typing.Type[HyperCycleMapping]
    IncorporationRanges: typing.Type[IncorporationRanges]
    IncorporationRequest: typing.Type[IncorporationRequest]
    IncorporationSetting: typing.Type[IncorporationSetting]
    Intersections: typing.Type[Intersections]
    Knob: typing.Type[Knob]
    KnobFactor: typing.Type[KnobFactor]
    KnobFactors: typing.Type[KnobFactors]
    LinkRuleAttribute: typing.Type[LinkRuleAttribute]
    MisconfiguredParameterException: typing.Type[MisconfiguredParameterException]
    NotIncorporatedParameters: typing.Type[NotIncorporatedParameters]
    Parameter: typing.Type[Parameter]
    ParameterAttributes: typing.Type[ParameterAttributes]
    ParameterForEditing: typing.Type[ParameterForEditing]
    ParameterGroup: typing.Type[ParameterGroup]
    ParameterNotFoundException: typing.Type[ParameterNotFoundException]
    ParameterSettings: typing.Type[ParameterSettings]
    ParameterTreeNode: typing.Type[ParameterTreeNode]
    ParameterTreesRequest: typing.Type[ParameterTreesRequest]
    ParameterType: typing.Type[ParameterType]
    ParameterTypeCategory: typing.Type[ParameterTypeCategory]
    ParameterTypeGroup: typing.Type[ParameterTypeGroup]
    ParameterTypes: typing.Type[ParameterTypes]
    ParameterTypesRequest: typing.Type[ParameterTypesRequest]
    Parameters: typing.Type[Parameters]
    ParametersRequest: typing.Type[ParametersRequest]
    Pattern: typing.Type[Pattern]
    PropertyAccessMode: typing.Type[PropertyAccessMode]
    RevertTrimRequest: typing.Type[RevertTrimRequest]
    Setting: typing.Type[Setting]
    SettingComparisonParameterResult: typing.Type[SettingComparisonParameterResult]
    SettingComparisonRequest: typing.Type[SettingComparisonRequest]
    SettingComparisonResponse: typing.Type[SettingComparisonResponse]
    SettingComparisonResult: typing.Type[SettingComparisonResult]
    SettingComparisonResultType: typing.Type[SettingComparisonResultType]
    SettingFactory: typing.Type[SettingFactory]
    SettingPartEnum: typing.Type[SettingPartEnum]
    Settings: typing.Type[Settings]
    SettingsDeletionRequest: typing.Type[SettingsDeletionRequest]
    SettingsGenerationRequest: typing.Type[SettingsGenerationRequest]
    SettingsRestoreStatus: typing.Type[SettingsRestoreStatus]
    SettingsSource: typing.Type[SettingsSource]
    StandAloneBeamProcess: typing.Type[StandAloneBeamProcess]
    StandAloneBeamProcessesRequest: typing.Type[StandAloneBeamProcessesRequest]
    StandAloneContext: typing.Type[StandAloneContext]
    StandAloneContextCloneRequest: typing.Type[StandAloneContextCloneRequest]
    StandAloneContextCreationRequest: typing.Type[StandAloneContextCreationRequest]
    StandAloneContextFilter: typing.Type[StandAloneContextFilter]
    StandAloneContextsRequest: typing.Type[StandAloneContextsRequest]
    StandAloneCycle: typing.Type[StandAloneCycle]
    StandAloneCyclesRequest: typing.Type[StandAloneCyclesRequest]
    SubContext: typing.Type[SubContext]
    TrimException: typing.Type[TrimException]
    TrimHeader: typing.Type[TrimHeader]
    TrimHeadersRequest: typing.Type[TrimHeadersRequest]
    TrimHeadersRequestBuilder: typing.Type[TrimHeadersRequestBuilder]
    TrimRequest: typing.Type[TrimRequest]
    TrimResponse: typing.Type[TrimResponse]
    TrimResult: typing.Type[TrimResult]
    UserContextMapping: typing.Type[UserContextMapping]
    factory: cern.lsa.domain.settings.factory.__module_protocol__
    parameter: cern.lsa.domain.settings.parameter.__module_protocol__
    spi: cern.lsa.domain.settings.spi.__module_protocol__
    type: cern.lsa.domain.settings.type.__module_protocol__
