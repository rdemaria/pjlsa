import cern.accsoft.commons.util
import cern.accsoft.commons.value
import cern.japc.core
import cern.lsa.domain.devices.type
import cern.lsa.domain.exploitation
import cern.lsa.domain.settings
import java.io
import java.lang
import java.util
import typing



class CommandType(java.lang.Enum['CommandType']):
    """
    Java class 'cern.lsa.domain.exploitation.command.CommandType'
    
        Extends:
            java.lang.Enum
    
      Attributes:
        READ (cern.lsa.domain.exploitation.command.CommandType): final static enum constant
        STATE (cern.lsa.domain.exploitation.command.CommandType): final static enum constant
        WRITE (cern.lsa.domain.exploitation.command.CommandType): final static enum constant
        LOAD (cern.lsa.domain.exploitation.command.CommandType): final static enum constant
        CHECK_SETTINGS (cern.lsa.domain.exploitation.command.CommandType): final static enum constant
    
    """
    READ: typing.ClassVar['CommandType'] = ...
    STATE: typing.ClassVar['CommandType'] = ...
    WRITE: typing.ClassVar['CommandType'] = ...
    LOAD: typing.ClassVar['CommandType'] = ...
    CHECK_SETTINGS: typing.ClassVar['CommandType'] = ...
    def getType(self) -> str: ...
    def isWriteType(self) -> bool: ...
    def toString(self) -> str: ...
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'CommandType': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @staticmethod
    def valueOfType(string: str) -> 'CommandType': ...
    @staticmethod
    def values() -> typing.List['CommandType']: ...

class HwCommand(cern.accsoft.commons.util.Named):
    """
    Java class 'cern.lsa.domain.exploitation.command.HwCommand'
    
        Interfaces:
            cern.accsoft.commons.util.Named
    
    """
    def createExecutionRequest(self) -> 'HwCommandExecutionRequest': ...
    def createTemplateArgumentsMap(self) -> java.util.Map[str, cern.accsoft.commons.value.ImmutableScalar]: ...
    def getArgumentParameters(self) -> java.util.List['HwCommandParameter']: ...
    def getDeviceType(self) -> str: ...
    def getDisplayMode(self) -> cern.lsa.domain.exploitation.DisplayMode: ...
    def getDisplayName(self) -> str: ...
    def getParameter(self, string: str) -> 'HwCommandParameter': ...
    def getProperties(self) -> java.util.Set[cern.lsa.domain.devices.type.PropertyVersion]: ...
    def getRank(self) -> int: ...
    def getReadBackCommand(self) -> 'HwCommand': ...
    def getResultParameters(self) -> java.util.List['HwCommandParameter']: ...
    def getShortCommandName(self) -> str: ...
    def getType(self) -> CommandType: ...
    def isContextDependent(self) -> bool: ...
    def isCustomCommand(self) -> bool: ...

class HwCommandExecutionRequest:
    """
    Java class 'cern.lsa.domain.exploitation.command.HwCommandExecutionRequest'
    
    """
    def areNonResidentContextsEnabled(self) -> bool: ...
    def getCommand(self) -> HwCommand: ...
    def getContexts(self) -> java.util.Set[cern.lsa.domain.settings.DrivableContext]: ...
    def getDeviceNames(self) -> java.util.List[str]: ...
    def getHardwareGroups(self) -> java.util.List[str]: ...
    def getParameters(self) -> java.util.Map[str, cern.accsoft.commons.value.ImmutableScalar]: ...
    def setContexts(self, collection: typing.Union[java.util.Collection[cern.lsa.domain.settings.DrivableContext], typing.Sequence[cern.lsa.domain.settings.DrivableContext]]) -> None: ...
    def setDeviceNames(self, collection: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> None: ...
    def setHardwareGroups(self, collection: typing.Union[java.util.Collection[str], typing.Sequence[str]]) -> None: ...
    def setNonResidentContextsEnabled(self, boolean: bool) -> None: ...
    @typing.overload
    def setParameter(self, string: str, immutableScalar: cern.accsoft.commons.value.ImmutableScalar) -> None: ...
    @typing.overload
    def setParameter(self, string: str, string2: str) -> None: ...
    def setParameters(self, map: typing.Union[java.util.Map[str, cern.accsoft.commons.value.ImmutableScalar], typing.Mapping[str, cern.accsoft.commons.value.ImmutableScalar]]) -> None: ...

class HwCommandExecutionResponse:
    """
    Java class 'cern.lsa.domain.exploitation.command.HwCommandExecutionResponse'
    
    """
    def getCommand(self) -> HwCommand: ...
    def getContexts(self) -> java.util.Set[cern.lsa.domain.settings.DrivableContext]: ...
    def getDeviceNames(self) -> java.util.List[str]: ...
    def getDeviceResponses(self) -> java.util.List[cern.japc.core.FailSafeParameterValue]: ...

class HwCommandParameter(cern.accsoft.commons.util.Named):
    """
    Java class 'cern.lsa.domain.exploitation.command.HwCommandParameter'
    
        Interfaces:
            cern.accsoft.commons.util.Named
    
    """
    def getCommandName(self) -> str: ...
    def getDefaultValue(self) -> cern.accsoft.commons.value.ImmutableScalar: ...
    def getDeviceTypeName(self) -> str: ...
    def getDisplayAttribute(self) -> str: ...
    def getDisplayName(self) -> str: ...
    def getOrder(self) -> int: ...
    def getValueDescriptor(self) -> cern.accsoft.commons.value.ValueDescriptor: ...
    def getValueType(self) -> cern.accsoft.commons.value.Type: ...
    def isArgument(self) -> bool: ...
    def isConstant(self) -> bool: ...

class HwCommandSet(java.io.Serializable):
    """
    Java class 'cern.lsa.domain.exploitation.command.HwCommandSet'
    
        Extends:
            java.lang.Object
    
        Interfaces:
            java.io.Serializable
    
      Constructors:
        * HwCommandSet()
    
    """
    def __init__(self): ...
    def addReadCommand(self, hwCommand: HwCommand) -> None: ...
    def addStateCommand(self, hwCommand: HwCommand) -> None: ...
    def addWriteCommand(self, hwCommand: HwCommand) -> None: ...
    def getCommand(self, string: str) -> HwCommand: ...
    @typing.overload
    def getReadCommands(self) -> java.util.SortedSet[HwCommand]: ...
    @typing.overload
    def getReadCommands(self, boolean: bool) -> java.util.SortedSet[HwCommand]: ...
    @typing.overload
    def getStateCommands(self) -> java.util.SortedSet[HwCommand]: ...
    @typing.overload
    def getStateCommands(self, boolean: bool) -> java.util.SortedSet[HwCommand]: ...
    @typing.overload
    def getWriteCommands(self) -> java.util.SortedSet[HwCommand]: ...
    @typing.overload
    def getWriteCommands(self, boolean: bool) -> java.util.SortedSet[HwCommand]: ...
    @staticmethod
    def valueOf(hwCommandArray: typing.List[HwCommand]) -> 'HwCommandSet': ...

class HwCommands:
    """
    Java class 'cern.lsa.domain.exploitation.command.HwCommands'
    
        Extends:
            java.lang.Object
    
      Attributes:
        SIGNATURE_CHECK_PARAMETER_NAME (java.lang.String): final static field
        HARDWARE_CHECK_PARAMETER_NAME (java.lang.String): final static field
        NAME_SEPARATOR (java.lang.String): final static field
    
    """
    SIGNATURE_CHECK_PARAMETER_NAME: typing.ClassVar[str] = ...
    HARDWARE_CHECK_PARAMETER_NAME: typing.ClassVar[str] = ...
    NAME_SEPARATOR: typing.ClassVar[str] = ...
    @typing.overload
    @staticmethod
    def buildCommandName(string: str, string2: str) -> str: ...
    @typing.overload
    @staticmethod
    def buildCommandName(string: str, string2: str, commandType: CommandType) -> str: ...
    @staticmethod
    def getCorrespondingReadCommandName(string: str) -> str: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("cern.lsa.domain.exploitation.command")``.

    CommandType: typing.Type[CommandType]
    HwCommand: typing.Type[HwCommand]
    HwCommandExecutionRequest: typing.Type[HwCommandExecutionRequest]
    HwCommandExecutionResponse: typing.Type[HwCommandExecutionResponse]
    HwCommandParameter: typing.Type[HwCommandParameter]
    HwCommandSet: typing.Type[HwCommandSet]
    HwCommands: typing.Type[HwCommands]
