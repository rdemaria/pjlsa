from typing import Any as _py_Any
from typing import List as _py_List
from typing import TypeVar as _py_TypeVar
from typing import Type as _py_Type
from typing import ClassVar as _py_ClassVar
from typing import overload
import java.io
import java.lang
import java.lang.annotation
import java.lang.reflect
import java.util
import jdk.internal.org.objectweb.asm


class AbstractValidatingLambdaMetafactory: ...

class CallSite:
    def dynamicInvoker(self) -> 'MethodHandle': ...
    def getTarget(self) -> 'MethodHandle': ...
    def setTarget(self, methodHandle: 'MethodHandle') -> None: ...
    def type(self) -> 'MethodType': ...

class DontInline(java.lang.annotation.Annotation):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class ForceInline(java.lang.annotation.Annotation):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class InjectedProfile(java.lang.annotation.Annotation):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class InvokeDynamic: ...

class InvokerBytecodeGenerator: ...

class Invokers:
    def toString(self) -> str: ...

class LambdaConversionException(java.lang.Exception):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...
    @overload
    def __init__(self, string: str, throwable: java.lang.Throwable, boolean: bool, boolean2: bool): ...
    @overload
    def __init__(self, throwable: java.lang.Throwable): ...

class LambdaForm:
    VOID_RESULT: _py_ClassVar[int] = ...
    LAST_RESULT: _py_ClassVar[int] = ...
    @classmethod
    def basicTypeSignature(cls, methodType: 'MethodType') -> str: ...
    @overload
    def equals(self, object: _py_Any) -> bool: ...
    @overload
    def equals(self, lambdaForm: 'LambdaForm') -> bool: ...
    def hashCode(self) -> int: ...
    def prepare(self) -> None: ...
    @classmethod
    def shortenSignature(cls, string: str) -> str: ...
    def toString(self) -> str: ...

class LambdaFormBuffer: ...

class LambdaFormEditor: ...

class LambdaMetafactory:
    FLAG_SERIALIZABLE: _py_ClassVar[int] = ...
    FLAG_MARKERS: _py_ClassVar[int] = ...
    FLAG_BRIDGES: _py_ClassVar[int] = ...
    def __init__(self): ...
    @classmethod
    def altMetafactory(cls, lookup: 'MethodHandles.Lookup', string: str, methodType: 'MethodType', objectArray: _py_List[_py_Any]) -> CallSite: ...
    @classmethod
    def metafactory(cls, lookup: 'MethodHandles.Lookup', string: str, methodType: 'MethodType', methodType2: 'MethodType', methodHandle: 'MethodHandle', methodType3: 'MethodType') -> CallSite: ...

class MemberName(java.lang.reflect.Member, java.lang.Cloneable):
    @overload
    def __init__(self, byte: int, class_: _py_Type[_py_Any], string: str, object: _py_Any): ...
    @overload
    def __init__(self, class_: _py_Type[_py_Any]): ...
    @overload
    def __init__(self, class_: _py_Type[_py_Any], string: str, class2: _py_Type[_py_Any], byte: int): ...
    @overload
    def __init__(self, class_: _py_Type[_py_Any], string: str, methodType: 'MethodType', byte: int): ...
    @overload
    def __init__(self, constructor: java.lang.reflect.Constructor[_py_Any]): ...
    @overload
    def __init__(self, field: java.lang.reflect.Field): ...
    @overload
    def __init__(self, field: java.lang.reflect.Field, boolean: bool): ...
    @overload
    def __init__(self, method: java.lang.reflect.Method): ...
    @overload
    def __init__(self, method: java.lang.reflect.Method, boolean: bool): ...
    def asConstructor(self) -> 'MemberName': ...
    def asNormalOriginal(self) -> 'MemberName': ...
    def asSetter(self) -> 'MemberName': ...
    def asSpecial(self) -> 'MemberName': ...
    def canBeStaticallyBound(self) -> bool: ...
    @overload
    def equals(self, object: _py_Any) -> bool: ...
    @overload
    def equals(self, memberName: 'MemberName') -> bool: ...
    def getClassLoader(self) -> java.lang.ClassLoader: ...
    def getDeclaringClass(self) -> _py_Type[_py_Any]: ...
    def getDefinition(self) -> 'MemberName': ...
    def getFieldType(self) -> _py_Type[_py_Any]: ...
    def getInvocationType(self) -> 'MethodType': ...
    def getMethodOrFieldType(self) -> 'MethodType': ...
    def getMethodType(self) -> 'MethodType': ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getParameterTypes(self) -> _py_List[_py_Type[_py_Any]]: ...
    def getReferenceKind(self) -> int: ...
    def getReturnType(self) -> _py_Type[_py_Any]: ...
    def getSignature(self) -> str: ...
    def getType(self) -> _py_Any: ...
    def hasReceiverTypeDispatch(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isAbstract(self) -> bool: ...
    def isAccessibleFrom(self, class_: _py_Type[_py_Any]) -> bool: ...
    def isBridge(self) -> bool: ...
    def isCallerSensitive(self) -> bool: ...
    def isConstructor(self) -> bool: ...
    def isField(self) -> bool: ...
    def isFieldOrMethod(self) -> bool: ...
    def isFinal(self) -> bool: ...
    def isGetter(self) -> bool: ...
    def isInvocable(self) -> bool: ...
    def isMethod(self) -> bool: ...
    def isMethodHandleInvoke(self) -> bool: ...
    @classmethod
    def isMethodHandleInvokeName(cls, string: str) -> bool: ...
    def isNative(self) -> bool: ...
    def isPackage(self) -> bool: ...
    def isPrivate(self) -> bool: ...
    def isProtected(self) -> bool: ...
    def isPublic(self) -> bool: ...
    def isResolved(self) -> bool: ...
    def isSetter(self) -> bool: ...
    def isStatic(self) -> bool: ...
    def isSynthetic(self) -> bool: ...
    def isType(self) -> bool: ...
    def isVarargs(self) -> bool: ...
    def isVolatile(self) -> bool: ...
    @overload
    def makeAccessException(self, string: str, object: _py_Any) -> java.lang.IllegalAccessException: ...
    @overload
    def makeAccessException(self) -> java.lang.ReflectiveOperationException: ...
    def toString(self) -> str: ...

class MethodHandle:
    def asCollector(self, class_: _py_Type[_py_Any], int: int) -> 'MethodHandle': ...
    def asFixedArity(self) -> 'MethodHandle': ...
    def asSpreader(self, class_: _py_Type[_py_Any], int: int) -> 'MethodHandle': ...
    def asType(self, methodType: 'MethodType') -> 'MethodHandle': ...
    def asVarargsCollector(self, class_: _py_Type[_py_Any]) -> 'MethodHandle': ...
    def bindTo(self, object: _py_Any) -> 'MethodHandle': ...
    def invoke(self, objectArray: _py_List[_py_Any]) -> _py_Any: ...
    def invokeExact(self, objectArray: _py_List[_py_Any]) -> _py_Any: ...
    @overload
    def invokeWithArguments(self, objectArray: _py_List[_py_Any]) -> _py_Any: ...
    @overload
    def invokeWithArguments(self, list: java.util.List[_py_Any]) -> _py_Any: ...
    def isVarargsCollector(self) -> bool: ...
    def toString(self) -> str: ...
    def type(self) -> 'MethodType': ...

class MethodHandleImpl: ...

class MethodHandleInfo:
    REF_getField: _py_ClassVar[int] = ...
    REF_getStatic: _py_ClassVar[int] = ...
    REF_putField: _py_ClassVar[int] = ...
    REF_putStatic: _py_ClassVar[int] = ...
    REF_invokeVirtual: _py_ClassVar[int] = ...
    REF_invokeStatic: _py_ClassVar[int] = ...
    REF_invokeSpecial: _py_ClassVar[int] = ...
    REF_newInvokeSpecial: _py_ClassVar[int] = ...
    REF_invokeInterface: _py_ClassVar[int] = ...
    def getDeclaringClass(self) -> _py_Type[_py_Any]: ...
    def getMethodType(self) -> 'MethodType': ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getReferenceKind(self) -> int: ...
    def isVarArgs(self) -> bool: ...
    @classmethod
    def referenceKindToString(cls, int: int) -> str: ...
    _reflectAs__T = _py_TypeVar('_reflectAs__T', bound=java.lang.reflect.Member)  # <T>
    def reflectAs(self, class_: _py_Type[_reflectAs__T], lookup: 'MethodHandles.Lookup') -> _reflectAs__T: ...
    @classmethod
    def toString(cls, int: int, class_: _py_Type[_py_Any], string: str, methodType: 'MethodType') -> str: ...

class MethodHandleNatives: ...

class MethodHandleProxies:
    _asInterfaceInstance__T = _py_TypeVar('_asInterfaceInstance__T')  # <T>
    @classmethod
    def asInterfaceInstance(cls, class_: _py_Type[_asInterfaceInstance__T], methodHandle: MethodHandle) -> _asInterfaceInstance__T: ...
    @classmethod
    def isWrapperInstance(cls, object: _py_Any) -> bool: ...
    @classmethod
    def wrapperInstanceTarget(cls, object: _py_Any) -> MethodHandle: ...
    @classmethod
    def wrapperInstanceType(cls, object: _py_Any) -> _py_Type[_py_Any]: ...

class MethodHandleStatics: ...

class MethodHandles:
    @classmethod
    def arrayElementGetter(cls, class_: _py_Type[_py_Any]) -> MethodHandle: ...
    @classmethod
    def arrayElementSetter(cls, class_: _py_Type[_py_Any]) -> MethodHandle: ...
    @classmethod
    def catchException(cls, methodHandle: MethodHandle, class_: _py_Type[java.lang.Throwable], methodHandle2: MethodHandle) -> MethodHandle: ...
    @classmethod
    def collectArguments(cls, methodHandle: MethodHandle, int: int, methodHandle2: MethodHandle) -> MethodHandle: ...
    @classmethod
    def constant(cls, class_: _py_Type[_py_Any], object: _py_Any) -> MethodHandle: ...
    @classmethod
    @overload
    def dropArguments(cls, methodHandle: MethodHandle, int: int, classArray: _py_List[_py_Type[_py_Any]]) -> MethodHandle: ...
    @classmethod
    @overload
    def dropArguments(cls, methodHandle: MethodHandle, int: int, list: java.util.List[_py_Type[_py_Any]]) -> MethodHandle: ...
    @classmethod
    def exactInvoker(cls, methodType: 'MethodType') -> MethodHandle: ...
    @classmethod
    def explicitCastArguments(cls, methodHandle: MethodHandle, methodType: 'MethodType') -> MethodHandle: ...
    @classmethod
    def filterArguments(cls, methodHandle: MethodHandle, int: int, methodHandleArray: _py_List[MethodHandle]) -> MethodHandle: ...
    @classmethod
    def filterReturnValue(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle) -> MethodHandle: ...
    @classmethod
    def foldArguments(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle) -> MethodHandle: ...
    @classmethod
    def guardWithTest(cls, methodHandle: MethodHandle, methodHandle2: MethodHandle, methodHandle3: MethodHandle) -> MethodHandle: ...
    @classmethod
    def identity(cls, class_: _py_Type[_py_Any]) -> MethodHandle: ...
    @classmethod
    def insertArguments(cls, methodHandle: MethodHandle, int: int, objectArray: _py_List[_py_Any]) -> MethodHandle: ...
    @classmethod
    def invoker(cls, methodType: 'MethodType') -> MethodHandle: ...
    @classmethod
    def lookup(cls) -> 'MethodHandles.Lookup': ...
    @classmethod
    def permuteArguments(cls, methodHandle: MethodHandle, methodType: 'MethodType', intArray: _py_List[int]) -> MethodHandle: ...
    @classmethod
    def publicLookup(cls) -> 'MethodHandles.Lookup': ...
    _reflectAs__T = _py_TypeVar('_reflectAs__T', bound=java.lang.reflect.Member)  # <T>
    @classmethod
    def reflectAs(cls, class_: _py_Type[_reflectAs__T], methodHandle: MethodHandle) -> _reflectAs__T: ...
    @classmethod
    def spreadInvoker(cls, methodType: 'MethodType', int: int) -> MethodHandle: ...
    @classmethod
    def throwException(cls, class_: _py_Type[_py_Any], class2: _py_Type[java.lang.Throwable]) -> MethodHandle: ...
    class Lookup:
        PUBLIC: _py_ClassVar[int] = ...
        PRIVATE: _py_ClassVar[int] = ...
        PROTECTED: _py_ClassVar[int] = ...
        PACKAGE: _py_ClassVar[int] = ...
        def bind(self, object: _py_Any, string: str, methodType: 'MethodType') -> MethodHandle: ...
        def findConstructor(self, class_: _py_Type[_py_Any], methodType: 'MethodType') -> MethodHandle: ...
        def findGetter(self, class_: _py_Type[_py_Any], string: str, class2: _py_Type[_py_Any]) -> MethodHandle: ...
        def findSetter(self, class_: _py_Type[_py_Any], string: str, class2: _py_Type[_py_Any]) -> MethodHandle: ...
        def findSpecial(self, class_: _py_Type[_py_Any], string: str, methodType: 'MethodType', class2: _py_Type[_py_Any]) -> MethodHandle: ...
        def findStatic(self, class_: _py_Type[_py_Any], string: str, methodType: 'MethodType') -> MethodHandle: ...
        def findStaticGetter(self, class_: _py_Type[_py_Any], string: str, class2: _py_Type[_py_Any]) -> MethodHandle: ...
        def findStaticSetter(self, class_: _py_Type[_py_Any], string: str, class2: _py_Type[_py_Any]) -> MethodHandle: ...
        def findVirtual(self, class_: _py_Type[_py_Any], string: str, methodType: 'MethodType') -> MethodHandle: ...
        def lookupClass(self) -> _py_Type[_py_Any]: ...
        def lookupModes(self) -> int: ...
        def revealDirect(self, methodHandle: MethodHandle) -> MethodHandleInfo: ...
        def toString(self) -> str: ...
        def unreflect(self, method: java.lang.reflect.Method) -> MethodHandle: ...
        def unreflectConstructor(self, constructor: java.lang.reflect.Constructor[_py_Any]) -> MethodHandle: ...
        def unreflectGetter(self, field: java.lang.reflect.Field) -> MethodHandle: ...
        def unreflectSetter(self, field: java.lang.reflect.Field) -> MethodHandle: ...
        def unreflectSpecial(self, method: java.lang.reflect.Method, class_: _py_Type[_py_Any]) -> MethodHandle: ...

class MethodType(java.io.Serializable):
    @overload
    def appendParameterTypes(self, classArray: _py_List[_py_Type[_py_Any]]) -> 'MethodType': ...
    @overload
    def appendParameterTypes(self, list: java.util.List[_py_Type[_py_Any]]) -> 'MethodType': ...
    def changeParameterType(self, int: int, class_: _py_Type[_py_Any]) -> 'MethodType': ...
    def changeReturnType(self, class_: _py_Type[_py_Any]) -> 'MethodType': ...
    def dropParameterTypes(self, int: int, int2: int) -> 'MethodType': ...
    def equals(self, object: _py_Any) -> bool: ...
    def erase(self) -> 'MethodType': ...
    @classmethod
    def fromMethodDescriptorString(cls, string: str, classLoader: java.lang.ClassLoader) -> 'MethodType': ...
    def generic(self) -> 'MethodType': ...
    @classmethod
    @overload
    def genericMethodType(cls, int: int) -> 'MethodType': ...
    @classmethod
    @overload
    def genericMethodType(cls, int: int, boolean: bool) -> 'MethodType': ...
    def hasPrimitives(self) -> bool: ...
    def hasWrappers(self) -> bool: ...
    def hashCode(self) -> int: ...
    @overload
    def insertParameterTypes(self, int: int, classArray: _py_List[_py_Type[_py_Any]]) -> 'MethodType': ...
    @overload
    def insertParameterTypes(self, int: int, list: java.util.List[_py_Type[_py_Any]]) -> 'MethodType': ...
    @classmethod
    @overload
    def methodType(cls, class_: _py_Type[_py_Any]) -> 'MethodType': ...
    @classmethod
    @overload
    def methodType(cls, class_: _py_Type[_py_Any], class2: _py_Type[_py_Any]) -> 'MethodType': ...
    @classmethod
    @overload
    def methodType(cls, class_: _py_Type[_py_Any], class2: _py_Type[_py_Any], classArray: _py_List[_py_Type[_py_Any]]) -> 'MethodType': ...
    @classmethod
    @overload
    def methodType(cls, class_: _py_Type[_py_Any], classArray: _py_List[_py_Type[_py_Any]]) -> 'MethodType': ...
    @classmethod
    @overload
    def methodType(cls, class_: _py_Type[_py_Any], methodType: 'MethodType') -> 'MethodType': ...
    @classmethod
    @overload
    def methodType(cls, class_: _py_Type[_py_Any], list: java.util.List[_py_Type[_py_Any]]) -> 'MethodType': ...
    def parameterArray(self) -> _py_List[_py_Type[_py_Any]]: ...
    def parameterCount(self) -> int: ...
    def parameterList(self) -> java.util.List[_py_Type[_py_Any]]: ...
    def parameterType(self, int: int) -> _py_Type[_py_Any]: ...
    def returnType(self) -> _py_Type[_py_Any]: ...
    def toMethodDescriptorString(self) -> str: ...
    def toString(self) -> str: ...
    def unwrap(self) -> 'MethodType': ...
    def wrap(self) -> 'MethodType': ...

class MethodTypeForm:
    NO_CHANGE: _py_ClassVar[int] = ...
    ERASE: _py_ClassVar[int] = ...
    WRAP: _py_ClassVar[int] = ...
    UNWRAP: _py_ClassVar[int] = ...
    INTS: _py_ClassVar[int] = ...
    LONGS: _py_ClassVar[int] = ...
    RAW_RETURN: _py_ClassVar[int] = ...
    def argSlotToParameter(self, int: int) -> int: ...
    def basicType(self) -> MethodType: ...
    def cachedLambdaForm(self, int: int) -> LambdaForm: ...
    def cachedMethodHandle(self, int: int) -> MethodHandle: ...
    @classmethod
    def canonicalize(cls, methodType: MethodType, int: int, int2: int) -> MethodType: ...
    def erasedType(self) -> MethodType: ...
    def hasLongPrimitives(self) -> bool: ...
    def hasNonVoidPrimitives(self) -> bool: ...
    def hasPrimitives(self) -> bool: ...
    def longPrimitiveParameterCount(self) -> int: ...
    def longPrimitiveReturnCount(self) -> int: ...
    def parameterCount(self) -> int: ...
    def parameterSlotCount(self) -> int: ...
    def parameterToArgSlot(self, int: int) -> int: ...
    def primitiveParameterCount(self) -> int: ...
    def primitiveReturnCount(self) -> int: ...
    def returnCount(self) -> int: ...
    def returnSlotCount(self) -> int: ...
    def setCachedLambdaForm(self, int: int, lambdaForm: LambdaForm) -> LambdaForm: ...
    def setCachedMethodHandle(self, int: int, methodHandle: MethodHandle) -> MethodHandle: ...
    def toString(self) -> str: ...

class ProxyClassesDumper:
    def dumpClass(self, string: str, byteArray: _py_List[int]) -> None: ...
    @classmethod
    def encodeForFilename(cls, string: str) -> str: ...
    @classmethod
    def getInstance(cls, string: str) -> 'ProxyClassesDumper': ...

class SerializedLambda(java.io.Serializable):
    def __init__(self, class_: _py_Type[_py_Any], string: str, string2: str, string3: str, int: int, string4: str, string5: str, string6: str, string7: str, objectArray: _py_List[_py_Any]): ...
    def getCapturedArg(self, int: int) -> _py_Any: ...
    def getCapturedArgCount(self) -> int: ...
    def getCapturingClass(self) -> str: ...
    def getFunctionalInterfaceClass(self) -> str: ...
    def getFunctionalInterfaceMethodName(self) -> str: ...
    def getFunctionalInterfaceMethodSignature(self) -> str: ...
    def getImplClass(self) -> str: ...
    def getImplMethodKind(self) -> int: ...
    def getImplMethodName(self) -> str: ...
    def getImplMethodSignature(self) -> str: ...
    def getInstantiatedMethodType(self) -> str: ...
    def toString(self) -> str: ...

class Stable(java.lang.annotation.Annotation):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class SwitchPoint:
    def __init__(self): ...
    def guardWithTest(self, methodHandle: MethodHandle, methodHandle2: MethodHandle) -> MethodHandle: ...
    def hasBeenInvalidated(self) -> bool: ...
    @classmethod
    def invalidateAll(cls, switchPointArray: _py_List['SwitchPoint']) -> None: ...

class TypeConvertingMethodAdapter(jdk.internal.org.objectweb.asm.MethodVisitor): ...

class WrongMethodTypeException(java.lang.RuntimeException):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str): ...

class BoundMethodHandle(MethodHandle): ...

class ConstantCallSite(CallSite):
    def __init__(self, methodHandle: MethodHandle): ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, methodHandle: MethodHandle) -> None: ...

class DelegatingMethodHandle(MethodHandle): ...

class DirectMethodHandle(MethodHandle): ...

class InfoFromMemberName(MethodHandleInfo):
    def getDeclaringClass(self) -> _py_Type[_py_Any]: ...
    def getMethodType(self) -> MethodType: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getReferenceKind(self) -> int: ...
    _reflectAs__T = _py_TypeVar('_reflectAs__T', bound=java.lang.reflect.Member)  # <T>
    def reflectAs(self, class_: _py_Type[_reflectAs__T], lookup: 'MethodHandles.Lookup') -> _reflectAs__T: ...
    def toString(self) -> str: ...

class InnerClassLambdaMetafactory(AbstractValidatingLambdaMetafactory):
    def __init__(self, lookup: 'MethodHandles.Lookup', methodType: MethodType, string: str, methodType2: MethodType, methodHandle: MethodHandle, methodType3: MethodType, boolean: bool, classArray: _py_List[_py_Type[_py_Any]], methodTypeArray: _py_List[MethodType]): ...

class MutableCallSite(CallSite):
    @overload
    def __init__(self, methodHandle: MethodHandle): ...
    @overload
    def __init__(self, methodType: MethodType): ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, methodHandle: MethodHandle) -> None: ...
    @classmethod
    def syncAll(cls, mutableCallSiteArray: _py_List['MutableCallSite']) -> None: ...

class VolatileCallSite(CallSite):
    @overload
    def __init__(self, methodHandle: MethodHandle): ...
    @overload
    def __init__(self, methodType: MethodType): ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, methodHandle: MethodHandle) -> None: ...

class SimpleMethodHandle(BoundMethodHandle):
    def fieldCount(self) -> int: ...
    def speciesData(self) -> 'BoundMethodHandle.SpeciesData': ...
