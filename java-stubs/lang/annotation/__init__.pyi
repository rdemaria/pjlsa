from typing import Any as _py_Any
from typing import List as _py_List
from typing import TypeVar as _py_TypeVar
from typing import Type as _py_Type
from typing import ClassVar as _py_ClassVar
from typing import overload
import java.lang
import java.lang.reflect


class Annotation:
    def annotationType(self) -> _py_Type['Annotation']: ...
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class AnnotationFormatError(java.lang.Error):
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...
    @overload
    def __init__(self, throwable: java.lang.Throwable): ...

class AnnotationTypeMismatchException(java.lang.RuntimeException):
    def __init__(self, method: java.lang.reflect.Method, string: str): ...
    def element(self) -> java.lang.reflect.Method: ...
    def foundType(self) -> str: ...

class ElementType(java.lang.Enum['ElementType']):
    TYPE: _py_ClassVar['ElementType'] = ...
    FIELD: _py_ClassVar['ElementType'] = ...
    METHOD: _py_ClassVar['ElementType'] = ...
    PARAMETER: _py_ClassVar['ElementType'] = ...
    CONSTRUCTOR: _py_ClassVar['ElementType'] = ...
    LOCAL_VARIABLE: _py_ClassVar['ElementType'] = ...
    ANNOTATION_TYPE: _py_ClassVar['ElementType'] = ...
    PACKAGE: _py_ClassVar['ElementType'] = ...
    TYPE_PARAMETER: _py_ClassVar['ElementType'] = ...
    TYPE_USE: _py_ClassVar['ElementType'] = ...
    _valueOf_0__T = _py_TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @overload
    def valueOf(cls, class_: _py_Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @classmethod
    @overload
    def valueOf(cls, string: str) -> 'ElementType': ...
    @classmethod
    def values(cls) -> _py_List['ElementType']: ...

class IncompleteAnnotationException(java.lang.RuntimeException):
    def __init__(self, class_: _py_Type[Annotation], string: str): ...
    def annotationType(self) -> _py_Type[Annotation]: ...
    def elementName(self) -> str: ...

class RetentionPolicy(java.lang.Enum['RetentionPolicy']):
    SOURCE: _py_ClassVar['RetentionPolicy'] = ...
    CLASS: _py_ClassVar['RetentionPolicy'] = ...
    RUNTIME: _py_ClassVar['RetentionPolicy'] = ...
    _valueOf_0__T = _py_TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @classmethod
    @overload
    def valueOf(cls, class_: _py_Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @classmethod
    @overload
    def valueOf(cls, string: str) -> 'RetentionPolicy': ...
    @classmethod
    def values(cls) -> _py_List['RetentionPolicy']: ...

class Documented(Annotation):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class Inherited(Annotation):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class Native(Annotation):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class Repeatable(Annotation):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...
    def value(self) -> _py_Type[Annotation]: ...

class Retention(Annotation):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...
    def value(self) -> RetentionPolicy: ...

class Target(Annotation):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...
    def value(self) -> _py_List[ElementType]: ...
