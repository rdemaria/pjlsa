from typing import Any as _py_Any
from typing import List as _py_List
from typing import TypeVar as _py_TypeVar
from typing import Type as _py_Type
from typing import ClassVar as _py_ClassVar
from typing import Generic as _py_Generic
from typing import Set as _py_Set
from typing import Collection as _py_Collection
from typing import Mapping as _py_Mapping
from typing import overload
import java.io
import java.lang
import java.math
import java.nio
import java.nio.channels
import java.nio.file
import java.security
import java.time
import java.util.function
import java.util.regex
import java.util.stream


class ArrayPrefixHelpers: ...

class Arrays:
    _asList__T = _py_TypeVar('_asList__T')  # <T>
    @classmethod
    def asList(cls, tArray: _py_List[_asList__T]) -> 'List'[_asList__T]: ...
    @classmethod
    @overload
    def binarySearch(cls, intArray: _py_List[int], int2: int, int3: int, int4: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, intArray: _py_List[int], int2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, longArray: _py_List[int], int: int, int2: int, long2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, longArray: _py_List[int], long2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, objectArray: _py_List[_py_Any], object2: _py_Any) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, floatArray: _py_List[float], int: int, int2: int, float2: float) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, floatArray: _py_List[float], float2: float) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, doubleArray: _py_List[float], int: int, int2: int, double2: float) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, objectArray: _py_List[_py_Any], int: int, int2: int, object2: _py_Any) -> int: ...
    _binarySearch_9__T = _py_TypeVar('_binarySearch_9__T')  # <T>
    @classmethod
    @overload
    def binarySearch(cls, tArray: _py_List[_binarySearch_9__T], t2: _binarySearch_9__T, comparator: 'Comparator'[_binarySearch_9__T]) -> int: ...
    _binarySearch_10__T = _py_TypeVar('_binarySearch_10__T')  # <T>
    @classmethod
    @overload
    def binarySearch(cls, tArray: _py_List[_binarySearch_10__T], int: int, int2: int, t2: _binarySearch_10__T, comparator: 'Comparator'[_binarySearch_10__T]) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, shortArray: _py_List[int], short2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, shortArray: _py_List[int], int: int, int2: int, short2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, charArray: _py_List[str], char2: str) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, charArray: _py_List[str], int: int, int2: int, char2: str) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, byteArray: _py_List[int], byte2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, byteArray: _py_List[int], int: int, int2: int, byte2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, doubleArray: _py_List[float], double2: float) -> int: ...
    @classmethod
    @overload
    def copyOf(cls, floatArray: _py_List[float], int: int) -> _py_List[float]: ...
    @classmethod
    @overload
    def copyOf(cls, charArray: _py_List[str], int: int) -> _py_List[str]: ...
    @classmethod
    @overload
    def copyOf(cls, longArray: _py_List[int], int: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOf(cls, doubleArray: _py_List[float], int: int) -> _py_List[float]: ...
    @classmethod
    @overload
    def copyOf(cls, booleanArray: _py_List[bool], int: int) -> _py_List[bool]: ...
    _copyOf_5__T = _py_TypeVar('_copyOf_5__T')  # <T>
    @classmethod
    @overload
    def copyOf(cls, tArray: _py_List[_copyOf_5__T], int: int) -> _py_List[_copyOf_5__T]: ...
    _copyOf_6__T = _py_TypeVar('_copyOf_6__T')  # <T>
    _copyOf_6__U = _py_TypeVar('_copyOf_6__U')  # <U>
    @classmethod
    @overload
    def copyOf(cls, uArray: _py_List[_copyOf_6__U], int: int, class_: _py_Type[_py_List[_copyOf_6__T]]) -> _py_List[_copyOf_6__T]: ...
    @classmethod
    @overload
    def copyOf(cls, byteArray: _py_List[int], int: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOf(cls, shortArray: _py_List[int], int: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOf(cls, intArray: _py_List[int], int2: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOfRange(cls, byteArray: _py_List[int], int: int, int2: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOfRange(cls, shortArray: _py_List[int], int: int, int2: int) -> _py_List[int]: ...
    _copyOfRange_2__T = _py_TypeVar('_copyOfRange_2__T')  # <T>
    _copyOfRange_2__U = _py_TypeVar('_copyOfRange_2__U')  # <U>
    @classmethod
    @overload
    def copyOfRange(cls, uArray: _py_List[_copyOfRange_2__U], int: int, int2: int, class_: _py_Type[_py_List[_copyOfRange_2__T]]) -> _py_List[_copyOfRange_2__T]: ...
    _copyOfRange_3__T = _py_TypeVar('_copyOfRange_3__T')  # <T>
    @classmethod
    @overload
    def copyOfRange(cls, tArray: _py_List[_copyOfRange_3__T], int: int, int2: int) -> _py_List[_copyOfRange_3__T]: ...
    @classmethod
    @overload
    def copyOfRange(cls, booleanArray: _py_List[bool], int: int, int2: int) -> _py_List[bool]: ...
    @classmethod
    @overload
    def copyOfRange(cls, doubleArray: _py_List[float], int: int, int2: int) -> _py_List[float]: ...
    @classmethod
    @overload
    def copyOfRange(cls, floatArray: _py_List[float], int: int, int2: int) -> _py_List[float]: ...
    @classmethod
    @overload
    def copyOfRange(cls, intArray: _py_List[int], int2: int, int3: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOfRange(cls, longArray: _py_List[int], int: int, int2: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOfRange(cls, charArray: _py_List[str], int: int, int2: int) -> _py_List[str]: ...
    @classmethod
    def deepEquals(cls, objectArray: _py_List[_py_Any], objectArray2: _py_List[_py_Any]) -> bool: ...
    @classmethod
    def deepHashCode(cls, objectArray: _py_List[_py_Any]) -> int: ...
    @classmethod
    def deepToString(cls, objectArray: _py_List[_py_Any]) -> str: ...
    @classmethod
    @overload
    def equals(cls, byteArray: _py_List[int], byteArray2: _py_List[int]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, booleanArray: _py_List[bool], booleanArray2: _py_List[bool]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, doubleArray: _py_List[float], doubleArray2: _py_List[float]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, floatArray: _py_List[float], floatArray2: _py_List[float]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, objectArray: _py_List[_py_Any], objectArray2: _py_List[_py_Any]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, shortArray: _py_List[int], shortArray2: _py_List[int]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, intArray: _py_List[int], intArray2: _py_List[int]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, longArray: _py_List[int], longArray2: _py_List[int]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, charArray: _py_List[str], charArray2: _py_List[str]) -> bool: ...
    @overload
    def equals(self, object: _py_Any) -> bool: ...
    @classmethod
    @overload
    def fill(cls, doubleArray: _py_List[float], int: int, int2: int, double2: float) -> None: ...
    @classmethod
    @overload
    def fill(cls, floatArray: _py_List[float], float2: float) -> None: ...
    @classmethod
    @overload
    def fill(cls, doubleArray: _py_List[float], double2: float) -> None: ...
    @classmethod
    @overload
    def fill(cls, longArray: _py_List[int], long2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, booleanArray: _py_List[bool], int: int, int2: int, boolean2: bool) -> None: ...
    @classmethod
    @overload
    def fill(cls, objectArray: _py_List[_py_Any], int: int, int2: int, object2: _py_Any) -> None: ...
    @classmethod
    @overload
    def fill(cls, objectArray: _py_List[_py_Any], object2: _py_Any) -> None: ...
    @classmethod
    @overload
    def fill(cls, floatArray: _py_List[float], int: int, int2: int, float2: float) -> None: ...
    @classmethod
    @overload
    def fill(cls, charArray: _py_List[str], char2: str) -> None: ...
    @classmethod
    @overload
    def fill(cls, charArray: _py_List[str], int: int, int2: int, char2: str) -> None: ...
    @classmethod
    @overload
    def fill(cls, byteArray: _py_List[int], byte2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, byteArray: _py_List[int], int: int, int2: int, byte2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, booleanArray: _py_List[bool], boolean2: bool) -> None: ...
    @classmethod
    @overload
    def fill(cls, longArray: _py_List[int], int: int, int2: int, long2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, intArray: _py_List[int], int2: int, int3: int, int4: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, shortArray: _py_List[int], short2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, shortArray: _py_List[int], int: int, int2: int, short2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, intArray: _py_List[int], int2: int) -> None: ...
    @classmethod
    @overload
    def hashCode(cls, byteArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, booleanArray: _py_List[bool]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, floatArray: _py_List[float]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, doubleArray: _py_List[float]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, longArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, intArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, shortArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, charArray: _py_List[str]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, objectArray: _py_List[_py_Any]) -> int: ...
    @overload
    def hashCode(self) -> int: ...
    _parallelPrefix_0__T = _py_TypeVar('_parallelPrefix_0__T')  # <T>
    @classmethod
    @overload
    def parallelPrefix(cls, tArray: _py_List[_parallelPrefix_0__T], int: int, int2: int, binaryOperator: java.util.function.BinaryOperator[_parallelPrefix_0__T]) -> None: ...
    @classmethod
    @overload
    def parallelPrefix(cls, doubleArray: _py_List[float], doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> None: ...
    @classmethod
    @overload
    def parallelPrefix(cls, longArray: _py_List[int], int: int, int2: int, longBinaryOperator: java.util.function.LongBinaryOperator) -> None: ...
    @classmethod
    @overload
    def parallelPrefix(cls, longArray: _py_List[int], longBinaryOperator: java.util.function.LongBinaryOperator) -> None: ...
    @classmethod
    @overload
    def parallelPrefix(cls, intArray: _py_List[int], int2: int, int3: int, intBinaryOperator: java.util.function.IntBinaryOperator) -> None: ...
    @classmethod
    @overload
    def parallelPrefix(cls, intArray: _py_List[int], intBinaryOperator: java.util.function.IntBinaryOperator) -> None: ...
    @classmethod
    @overload
    def parallelPrefix(cls, doubleArray: _py_List[float], int: int, int2: int, doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> None: ...
    _parallelPrefix_7__T = _py_TypeVar('_parallelPrefix_7__T')  # <T>
    @classmethod
    @overload
    def parallelPrefix(cls, tArray: _py_List[_parallelPrefix_7__T], binaryOperator: java.util.function.BinaryOperator[_parallelPrefix_7__T]) -> None: ...
    @classmethod
    @overload
    def parallelSetAll(cls, longArray: _py_List[int], intToLongFunction: java.util.function.IntToLongFunction) -> None: ...
    @classmethod
    @overload
    def parallelSetAll(cls, doubleArray: _py_List[float], intToDoubleFunction: java.util.function.IntToDoubleFunction) -> None: ...
    @classmethod
    @overload
    def parallelSetAll(cls, intArray: _py_List[int], intUnaryOperator: java.util.function.IntUnaryOperator) -> None: ...
    _parallelSetAll_3__T = _py_TypeVar('_parallelSetAll_3__T')  # <T>
    @classmethod
    @overload
    def parallelSetAll(cls, tArray: _py_List[_parallelSetAll_3__T], intFunction: java.util.function.IntFunction[_parallelSetAll_3__T]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, longArray: _py_List[int], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, floatArray: _py_List[float]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, floatArray: _py_List[float], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, longArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, intArray: _py_List[int], int2: int, int3: int) -> None: ...
    _parallelSort_5__T = _py_TypeVar('_parallelSort_5__T')  # <T>
    @classmethod
    @overload
    def parallelSort(cls, tArray: _py_List[_parallelSort_5__T], comparator: 'Comparator'[_parallelSort_5__T]) -> None: ...
    _parallelSort_6__T = _py_TypeVar('_parallelSort_6__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    @overload
    def parallelSort(cls, tArray: _py_List[_parallelSort_6__T], int: int, int2: int) -> None: ...
    _parallelSort_7__T = _py_TypeVar('_parallelSort_7__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    @overload
    def parallelSort(cls, tArray: _py_List[_parallelSort_7__T]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, doubleArray: _py_List[float], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, doubleArray: _py_List[float]) -> None: ...
    _parallelSort_10__T = _py_TypeVar('_parallelSort_10__T')  # <T>
    @classmethod
    @overload
    def parallelSort(cls, tArray: _py_List[_parallelSort_10__T], int: int, int2: int, comparator: 'Comparator'[_parallelSort_10__T]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, charArray: _py_List[str]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, byteArray: _py_List[int], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, intArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, byteArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, shortArray: _py_List[int], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, shortArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, charArray: _py_List[str], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def setAll(cls, doubleArray: _py_List[float], intToDoubleFunction: java.util.function.IntToDoubleFunction) -> None: ...
    @classmethod
    @overload
    def setAll(cls, longArray: _py_List[int], intToLongFunction: java.util.function.IntToLongFunction) -> None: ...
    @classmethod
    @overload
    def setAll(cls, intArray: _py_List[int], intUnaryOperator: java.util.function.IntUnaryOperator) -> None: ...
    _setAll_3__T = _py_TypeVar('_setAll_3__T')  # <T>
    @classmethod
    @overload
    def setAll(cls, tArray: _py_List[_setAll_3__T], intFunction: java.util.function.IntFunction[_setAll_3__T]) -> None: ...
    @classmethod
    @overload
    def sort(cls, longArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def sort(cls, longArray: _py_List[int], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, byteArray: _py_List[int], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, floatArray: _py_List[float]) -> None: ...
    @classmethod
    @overload
    def sort(cls, floatArray: _py_List[float], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, charArray: _py_List[str]) -> None: ...
    @classmethod
    @overload
    def sort(cls, charArray: _py_List[str], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, shortArray: _py_List[int], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, shortArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def sort(cls, byteArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def sort(cls, objectArray: _py_List[_py_Any]) -> None: ...
    _sort_11__T = _py_TypeVar('_sort_11__T')  # <T>
    @classmethod
    @overload
    def sort(cls, tArray: _py_List[_sort_11__T], int: int, int2: int, comparator: 'Comparator'[_sort_11__T]) -> None: ...
    @classmethod
    @overload
    def sort(cls, intArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def sort(cls, objectArray: _py_List[_py_Any], int: int, int2: int) -> None: ...
    _sort_14__T = _py_TypeVar('_sort_14__T')  # <T>
    @classmethod
    @overload
    def sort(cls, tArray: _py_List[_sort_14__T], comparator: 'Comparator'[_sort_14__T]) -> None: ...
    @classmethod
    @overload
    def sort(cls, doubleArray: _py_List[float]) -> None: ...
    @classmethod
    @overload
    def sort(cls, doubleArray: _py_List[float], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, intArray: _py_List[int], int2: int, int3: int) -> None: ...
    @classmethod
    @overload
    def spliterator(cls, longArray: _py_List[int], int: int, int2: int) -> 'Spliterator.OfLong': ...
    @classmethod
    @overload
    def spliterator(cls, longArray: _py_List[int]) -> 'Spliterator.OfLong': ...
    @classmethod
    @overload
    def spliterator(cls, intArray: _py_List[int], int2: int, int3: int) -> 'Spliterator.OfInt': ...
    @classmethod
    @overload
    def spliterator(cls, doubleArray: _py_List[float]) -> 'Spliterator.OfDouble': ...
    @classmethod
    @overload
    def spliterator(cls, doubleArray: _py_List[float], int: int, int2: int) -> 'Spliterator.OfDouble': ...
    _spliterator_5__T = _py_TypeVar('_spliterator_5__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, tArray: _py_List[_spliterator_5__T]) -> 'Spliterator'[_spliterator_5__T]: ...
    _spliterator_6__T = _py_TypeVar('_spliterator_6__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, tArray: _py_List[_spliterator_6__T], int: int, int2: int) -> 'Spliterator'[_spliterator_6__T]: ...
    @classmethod
    @overload
    def spliterator(cls, intArray: _py_List[int]) -> 'Spliterator.OfInt': ...
    @classmethod
    @overload
    def stream(cls, intArray: _py_List[int]) -> java.util.stream.IntStream: ...
    _stream_1__T = _py_TypeVar('_stream_1__T')  # <T>
    @classmethod
    @overload
    def stream(cls, tArray: _py_List[_stream_1__T], int: int, int2: int) -> java.util.stream.Stream[_stream_1__T]: ...
    _stream_2__T = _py_TypeVar('_stream_2__T')  # <T>
    @classmethod
    @overload
    def stream(cls, tArray: _py_List[_stream_2__T]) -> java.util.stream.Stream[_stream_2__T]: ...
    @classmethod
    @overload
    def stream(cls, doubleArray: _py_List[float]) -> java.util.stream.DoubleStream: ...
    @classmethod
    @overload
    def stream(cls, intArray: _py_List[int], int2: int, int3: int) -> java.util.stream.IntStream: ...
    @classmethod
    @overload
    def stream(cls, longArray: _py_List[int]) -> java.util.stream.LongStream: ...
    @classmethod
    @overload
    def stream(cls, longArray: _py_List[int], int: int, int2: int) -> java.util.stream.LongStream: ...
    @classmethod
    @overload
    def stream(cls, doubleArray: _py_List[float], int: int, int2: int) -> java.util.stream.DoubleStream: ...
    @classmethod
    @overload
    def toString(cls, booleanArray: _py_List[bool]) -> str: ...
    @classmethod
    @overload
    def toString(cls, byteArray: _py_List[int]) -> str: ...
    @classmethod
    @overload
    def toString(cls, floatArray: _py_List[float]) -> str: ...
    @classmethod
    @overload
    def toString(cls, doubleArray: _py_List[float]) -> str: ...
    @classmethod
    @overload
    def toString(cls, longArray: _py_List[int]) -> str: ...
    @classmethod
    @overload
    def toString(cls, intArray: _py_List[int]) -> str: ...
    @classmethod
    @overload
    def toString(cls, shortArray: _py_List[int]) -> str: ...
    @classmethod
    @overload
    def toString(cls, charArray: _py_List[str]) -> str: ...
    @classmethod
    @overload
    def toString(cls, objectArray: _py_List[_py_Any]) -> str: ...
    @overload
    def toString(self) -> str: ...

class ArraysParallelSortHelpers: ...

class Base64:
    @classmethod
    def getDecoder(cls) -> 'Base64.Decoder': ...
    @classmethod
    def getEncoder(cls) -> 'Base64.Encoder': ...
    @classmethod
    def getMimeDecoder(cls) -> 'Base64.Decoder': ...
    @classmethod
    @overload
    def getMimeEncoder(cls) -> 'Base64.Encoder': ...
    @classmethod
    @overload
    def getMimeEncoder(cls, int: int, byteArray: _py_List[int]) -> 'Base64.Encoder': ...
    @classmethod
    def getUrlDecoder(cls) -> 'Base64.Decoder': ...
    @classmethod
    def getUrlEncoder(cls) -> 'Base64.Encoder': ...
    class Decoder:
        @overload
        def decode(self, byteArray: _py_List[int]) -> _py_List[int]: ...
        @overload
        def decode(self, string: str) -> _py_List[int]: ...
        @overload
        def decode(self, byteArray: _py_List[int], byteArray2: _py_List[int]) -> int: ...
        @overload
        def decode(self, byteBuffer: java.nio.ByteBuffer) -> java.nio.ByteBuffer: ...
        def wrap(self, inputStream: java.io.InputStream) -> java.io.InputStream: ...
    class Encoder:
        @overload
        def encode(self, byteArray: _py_List[int]) -> _py_List[int]: ...
        @overload
        def encode(self, byteArray: _py_List[int], byteArray2: _py_List[int]) -> int: ...
        @overload
        def encode(self, byteBuffer: java.nio.ByteBuffer) -> java.nio.ByteBuffer: ...
        def encodeToString(self, byteArray: _py_List[int]) -> str: ...
        def withoutPadding(self) -> 'Base64.Encoder': ...
        def wrap(self, outputStream: java.io.OutputStream) -> java.io.OutputStream: ...

class BitSet(java.lang.Cloneable, java.io.Serializable):
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self): ...
    def andNot(self, bitSet: 'BitSet') -> None: ...
    def cardinality(self) -> int: ...
    @overload
    def clear(self, int: int, int2: int) -> None: ...
    @overload
    def clear(self, int: int) -> None: ...
    @overload
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def equals(self, object: _py_Any) -> bool: ...
    @overload
    def flip(self, int: int, int2: int) -> None: ...
    @overload
    def flip(self, int: int) -> None: ...
    @overload
    def get(self, int: int, int2: int) -> 'BitSet': ...
    @overload
    def get(self, int: int) -> bool: ...
    def hashCode(self) -> int: ...
    def intersects(self, bitSet: 'BitSet') -> bool: ...
    def isEmpty(self) -> bool: ...
    def length(self) -> int: ...
    def nextClearBit(self, int: int) -> int: ...
    def nextSetBit(self, int: int) -> int: ...
    def previousClearBit(self, int: int) -> int: ...
    def previousSetBit(self, int: int) -> int: ...
    @overload
    def set(self, int: int) -> None: ...
    @overload
    def set(self, int: int, boolean: bool) -> None: ...
    @overload
    def set(self, int: int, int2: int, boolean: bool) -> None: ...
    @overload
    def set(self, int: int, int2: int) -> None: ...
    def size(self) -> int: ...
    def stream(self) -> java.util.stream.IntStream: ...
    def toByteArray(self) -> _py_List[int]: ...
    def toLongArray(self) -> _py_List[int]: ...
    def toString(self) -> str: ...
    @classmethod
    @overload
    def valueOf(cls, longArray: _py_List[int]) -> 'BitSet': ...
    @classmethod
    @overload
    def valueOf(cls, longBuffer: java.nio.LongBuffer) -> 'BitSet': ...
    @classmethod
    @overload
    def valueOf(cls, byteArray: _py_List[int]) -> 'BitSet': ...
    @classmethod
    @overload
    def valueOf(cls, byteBuffer: java.nio.ByteBuffer) -> 'BitSet': ...
    def xor(self, bitSet: 'BitSet') -> None: ...

class Calendar(java.io.Serializable, java.lang.Cloneable, java.lang.Comparable['Calendar']):
    ERA: _py_ClassVar[int] = ...
    YEAR: _py_ClassVar[int] = ...
    MONTH: _py_ClassVar[int] = ...
    WEEK_OF_YEAR: _py_ClassVar[int] = ...
    WEEK_OF_MONTH: _py_ClassVar[int] = ...
    DATE: _py_ClassVar[int] = ...
    DAY_OF_MONTH: _py_ClassVar[int] = ...
    DAY_OF_YEAR: _py_ClassVar[int] = ...
    DAY_OF_WEEK: _py_ClassVar[int] = ...
    DAY_OF_WEEK_IN_MONTH: _py_ClassVar[int] = ...
    AM_PM: _py_ClassVar[int] = ...
    HOUR: _py_ClassVar[int] = ...
    HOUR_OF_DAY: _py_ClassVar[int] = ...
    MINUTE: _py_ClassVar[int] = ...
    SECOND: _py_ClassVar[int] = ...
    MILLISECOND: _py_ClassVar[int] = ...
    ZONE_OFFSET: _py_ClassVar[int] = ...
    DST_OFFSET: _py_ClassVar[int] = ...
    FIELD_COUNT: _py_ClassVar[int] = ...
    SUNDAY: _py_ClassVar[int] = ...
    MONDAY: _py_ClassVar[int] = ...
    TUESDAY: _py_ClassVar[int] = ...
    WEDNESDAY: _py_ClassVar[int] = ...
    THURSDAY: _py_ClassVar[int] = ...
    FRIDAY: _py_ClassVar[int] = ...
    SATURDAY: _py_ClassVar[int] = ...
    JANUARY: _py_ClassVar[int] = ...
    FEBRUARY: _py_ClassVar[int] = ...
    MARCH: _py_ClassVar[int] = ...
    APRIL: _py_ClassVar[int] = ...
    MAY: _py_ClassVar[int] = ...
    JUNE: _py_ClassVar[int] = ...
    JULY: _py_ClassVar[int] = ...
    AUGUST: _py_ClassVar[int] = ...
    SEPTEMBER: _py_ClassVar[int] = ...
    OCTOBER: _py_ClassVar[int] = ...
    NOVEMBER: _py_ClassVar[int] = ...
    DECEMBER: _py_ClassVar[int] = ...
    UNDECIMBER: _py_ClassVar[int] = ...
    AM: _py_ClassVar[int] = ...
    PM: _py_ClassVar[int] = ...
    ALL_STYLES: _py_ClassVar[int] = ...
    SHORT: _py_ClassVar[int] = ...
    LONG: _py_ClassVar[int] = ...
    NARROW_FORMAT: _py_ClassVar[int] = ...
    NARROW_STANDALONE: _py_ClassVar[int] = ...
    SHORT_FORMAT: _py_ClassVar[int] = ...
    LONG_FORMAT: _py_ClassVar[int] = ...
    SHORT_STANDALONE: _py_ClassVar[int] = ...
    LONG_STANDALONE: _py_ClassVar[int] = ...
    def add(self, int: int, int2: int) -> None: ...
    def after(self, object: _py_Any) -> bool: ...
    def before(self, object: _py_Any) -> bool: ...
    @overload
    def clear(self, int: int) -> None: ...
    @overload
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    @overload
    def compareTo(self, calendar: 'Calendar') -> int: ...
    @overload
    def compareTo(self, object: _py_Any) -> int: ...
    def equals(self, object: _py_Any) -> bool: ...
    def get(self, int: int) -> int: ...
    def getActualMaximum(self, int: int) -> int: ...
    def getActualMinimum(self, int: int) -> int: ...
    @classmethod
    def getAvailableCalendarTypes(cls) -> 'Set'[str]: ...
    @classmethod
    def getAvailableLocales(cls) -> _py_List['Locale']: ...
    def getCalendarType(self) -> str: ...
    def getDisplayName(self, int: int, int2: int, locale: 'Locale') -> str: ...
    def getDisplayNames(self, int: int, int2: int, locale: 'Locale') -> 'Map'[str, int]: ...
    def getFirstDayOfWeek(self) -> int: ...
    def getGreatestMinimum(self, int: int) -> int: ...
    @classmethod
    @overload
    def getInstance(cls, locale: 'Locale') -> 'Calendar': ...
    @classmethod
    @overload
    def getInstance(cls, timeZone: 'TimeZone', locale: 'Locale') -> 'Calendar': ...
    @classmethod
    @overload
    def getInstance(cls, timeZone: 'TimeZone') -> 'Calendar': ...
    @classmethod
    @overload
    def getInstance(cls) -> 'Calendar': ...
    def getLeastMaximum(self, int: int) -> int: ...
    def getMaximum(self, int: int) -> int: ...
    def getMinimalDaysInFirstWeek(self) -> int: ...
    def getMinimum(self, int: int) -> int: ...
    def getTime(self) -> 'Date': ...
    def getTimeInMillis(self) -> int: ...
    def getTimeZone(self) -> 'TimeZone': ...
    def getWeekYear(self) -> int: ...
    def getWeeksInWeekYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isLenient(self) -> bool: ...
    def isSet(self, int: int) -> bool: ...
    def isWeekDateSupported(self) -> bool: ...
    @overload
    def roll(self, int: int, int2: int) -> None: ...
    @overload
    def roll(self, int: int, boolean: bool) -> None: ...
    @overload
    def set(self, int: int, int2: int) -> None: ...
    @overload
    def set(self, int: int, int2: int, int3: int, int4: int, int5: int) -> None: ...
    @overload
    def set(self, int: int, int2: int, int3: int) -> None: ...
    @overload
    def set(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    def setFirstDayOfWeek(self, int: int) -> None: ...
    def setLenient(self, boolean: bool) -> None: ...
    def setMinimalDaysInFirstWeek(self, int: int) -> None: ...
    def setTime(self, date: 'Date') -> None: ...
    def setTimeInMillis(self, long: int) -> None: ...
    def setTimeZone(self, timeZone: 'TimeZone') -> None: ...
    def setWeekDate(self, int: int, int2: int, int3: int) -> None: ...
    def toInstant(self) -> java.time.Instant: ...
    def toString(self) -> str: ...
    class Builder:
        def __init__(self): ...
        def build(self) -> 'Calendar': ...
        def set(self, int: int, int2: int) -> 'Calendar.Builder': ...
        def setCalendarType(self, string: str) -> 'Calendar.Builder': ...
        def setDate(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        def setFields(self, intArray: _py_List[int]) -> 'Calendar.Builder': ...
        @overload
        def setInstant(self, date: 'Date') -> 'Calendar.Builder': ...
        @overload
        def setInstant(self, long: int) -> 'Calendar.Builder': ...
        def setLenient(self, boolean: bool) -> 'Calendar.Builder': ...
        def setLocale(self, locale: 'Locale') -> 'Calendar.Builder': ...
        @overload
        def setTimeOfDay(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        @overload
        def setTimeOfDay(self, int: int, int2: int, int3: int, int4: int) -> 'Calendar.Builder': ...
        def setTimeZone(self, timeZone: 'TimeZone') -> 'Calendar.Builder': ...
        def setWeekDate(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        def setWeekDefinition(self, int: int, int2: int) -> 'Calendar.Builder': ...

_Collection__E = _py_TypeVar('_Collection__E')  # <E>
class Collection(java.lang.Iterable[_Collection__E], _py_Generic[_Collection__E], _py_Collection[_Collection__E]):
    def add(self, e: _Collection__E) -> bool: ...
    def addAll(self, collection: 'Collection'[_Collection__E]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: 'Collection'[_py_Any]) -> bool: ...
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> 'Iterator'[_Collection__E]: ...
    def parallelStream(self) -> java.util.stream.Stream[_Collection__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: 'Collection'[_py_Any]) -> bool: ...
    def removeIf(self, predicate: java.util.function.Predicate[_Collection__E]) -> bool: ...
    def retainAll(self, collection: 'Collection'[_py_Any]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_Collection__E]: ...
    def stream(self) -> java.util.stream.Stream[_Collection__E]: ...
    _toArray_0__T = _py_TypeVar('_toArray_0__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_0__T]) -> _py_List[_toArray_0__T]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...

class Collections:
    EMPTY_SET: _py_ClassVar['Set'] = ...
    EMPTY_LIST: _py_ClassVar['List'] = ...
    EMPTY_MAP: _py_ClassVar['Map'] = ...
    _addAll__T = _py_TypeVar('_addAll__T')  # <T>
    @classmethod
    def addAll(cls, collection: Collection[_addAll__T], tArray: _py_List[_addAll__T]) -> bool: ...
    _asLifoQueue__T = _py_TypeVar('_asLifoQueue__T')  # <T>
    @classmethod
    def asLifoQueue(cls, deque: 'Deque'[_asLifoQueue__T]) -> 'Queue'[_asLifoQueue__T]: ...
    _binarySearch_0__T = _py_TypeVar('_binarySearch_0__T')  # <T>
    @classmethod
    @overload
    def binarySearch(cls, list: 'List'[_binarySearch_0__T], t: _binarySearch_0__T, comparator: 'Comparator'[_binarySearch_0__T]) -> int: ...
    _binarySearch_1__T = _py_TypeVar('_binarySearch_1__T')  # <T>
    @classmethod
    @overload
    def binarySearch(cls, list: 'List'[java.lang.Comparable[_binarySearch_1__T]], t: _binarySearch_1__T) -> int: ...
    _checkedCollection__E = _py_TypeVar('_checkedCollection__E')  # <E>
    @classmethod
    def checkedCollection(cls, collection: Collection[_checkedCollection__E], class_: _py_Type[_checkedCollection__E]) -> Collection[_checkedCollection__E]: ...
    _checkedList__E = _py_TypeVar('_checkedList__E')  # <E>
    @classmethod
    def checkedList(cls, list: 'List'[_checkedList__E], class_: _py_Type[_checkedList__E]) -> 'List'[_checkedList__E]: ...
    _checkedMap__K = _py_TypeVar('_checkedMap__K')  # <K>
    _checkedMap__V = _py_TypeVar('_checkedMap__V')  # <V>
    @classmethod
    def checkedMap(cls, map: 'Map'[_checkedMap__K, _checkedMap__V], class_: _py_Type[_checkedMap__K], class2: _py_Type[_checkedMap__V]) -> 'Map'[_checkedMap__K, _checkedMap__V]: ...
    _checkedNavigableMap__K = _py_TypeVar('_checkedNavigableMap__K')  # <K>
    _checkedNavigableMap__V = _py_TypeVar('_checkedNavigableMap__V')  # <V>
    @classmethod
    def checkedNavigableMap(cls, navigableMap: 'NavigableMap'[_checkedNavigableMap__K, _checkedNavigableMap__V], class_: _py_Type[_checkedNavigableMap__K], class2: _py_Type[_checkedNavigableMap__V]) -> 'NavigableMap'[_checkedNavigableMap__K, _checkedNavigableMap__V]: ...
    _checkedNavigableSet__E = _py_TypeVar('_checkedNavigableSet__E')  # <E>
    @classmethod
    def checkedNavigableSet(cls, navigableSet: 'NavigableSet'[_checkedNavigableSet__E], class_: _py_Type[_checkedNavigableSet__E]) -> 'NavigableSet'[_checkedNavigableSet__E]: ...
    _checkedQueue__E = _py_TypeVar('_checkedQueue__E')  # <E>
    @classmethod
    def checkedQueue(cls, queue: 'Queue'[_checkedQueue__E], class_: _py_Type[_checkedQueue__E]) -> 'Queue'[_checkedQueue__E]: ...
    _checkedSet__E = _py_TypeVar('_checkedSet__E')  # <E>
    @classmethod
    def checkedSet(cls, set: 'Set'[_checkedSet__E], class_: _py_Type[_checkedSet__E]) -> 'Set'[_checkedSet__E]: ...
    _checkedSortedMap__K = _py_TypeVar('_checkedSortedMap__K')  # <K>
    _checkedSortedMap__V = _py_TypeVar('_checkedSortedMap__V')  # <V>
    @classmethod
    def checkedSortedMap(cls, sortedMap: 'SortedMap'[_checkedSortedMap__K, _checkedSortedMap__V], class_: _py_Type[_checkedSortedMap__K], class2: _py_Type[_checkedSortedMap__V]) -> 'SortedMap'[_checkedSortedMap__K, _checkedSortedMap__V]: ...
    _checkedSortedSet__E = _py_TypeVar('_checkedSortedSet__E')  # <E>
    @classmethod
    def checkedSortedSet(cls, sortedSet: 'SortedSet'[_checkedSortedSet__E], class_: _py_Type[_checkedSortedSet__E]) -> 'SortedSet'[_checkedSortedSet__E]: ...
    _copy__T = _py_TypeVar('_copy__T')  # <T>
    @classmethod
    def copy(cls, list: 'List'[_copy__T], list2: 'List'[_copy__T]) -> None: ...
    @classmethod
    def disjoint(cls, collection: Collection[_py_Any], collection2: Collection[_py_Any]) -> bool: ...
    _emptyEnumeration__T = _py_TypeVar('_emptyEnumeration__T')  # <T>
    @classmethod
    def emptyEnumeration(cls) -> 'Enumeration'[_emptyEnumeration__T]: ...
    _emptyIterator__T = _py_TypeVar('_emptyIterator__T')  # <T>
    @classmethod
    def emptyIterator(cls) -> 'Iterator'[_emptyIterator__T]: ...
    _emptyList__T = _py_TypeVar('_emptyList__T')  # <T>
    @classmethod
    def emptyList(cls) -> 'List'[_emptyList__T]: ...
    _emptyListIterator__T = _py_TypeVar('_emptyListIterator__T')  # <T>
    @classmethod
    def emptyListIterator(cls) -> 'ListIterator'[_emptyListIterator__T]: ...
    _emptyMap__K = _py_TypeVar('_emptyMap__K')  # <K>
    _emptyMap__V = _py_TypeVar('_emptyMap__V')  # <V>
    @classmethod
    def emptyMap(cls) -> 'Map'[_emptyMap__K, _emptyMap__V]: ...
    _emptyNavigableMap__K = _py_TypeVar('_emptyNavigableMap__K')  # <K>
    _emptyNavigableMap__V = _py_TypeVar('_emptyNavigableMap__V')  # <V>
    @classmethod
    def emptyNavigableMap(cls) -> 'NavigableMap'[_emptyNavigableMap__K, _emptyNavigableMap__V]: ...
    _emptyNavigableSet__E = _py_TypeVar('_emptyNavigableSet__E')  # <E>
    @classmethod
    def emptyNavigableSet(cls) -> 'NavigableSet'[_emptyNavigableSet__E]: ...
    _emptySet__T = _py_TypeVar('_emptySet__T')  # <T>
    @classmethod
    def emptySet(cls) -> 'Set'[_emptySet__T]: ...
    _emptySortedMap__K = _py_TypeVar('_emptySortedMap__K')  # <K>
    _emptySortedMap__V = _py_TypeVar('_emptySortedMap__V')  # <V>
    @classmethod
    def emptySortedMap(cls) -> 'SortedMap'[_emptySortedMap__K, _emptySortedMap__V]: ...
    _emptySortedSet__E = _py_TypeVar('_emptySortedSet__E')  # <E>
    @classmethod
    def emptySortedSet(cls) -> 'SortedSet'[_emptySortedSet__E]: ...
    _enumeration__T = _py_TypeVar('_enumeration__T')  # <T>
    @classmethod
    def enumeration(cls, collection: Collection[_enumeration__T]) -> 'Enumeration'[_enumeration__T]: ...
    _fill__T = _py_TypeVar('_fill__T')  # <T>
    @classmethod
    def fill(cls, list: 'List'[_fill__T], t: _fill__T) -> None: ...
    @classmethod
    def frequency(cls, collection: Collection[_py_Any], object: _py_Any) -> int: ...
    @classmethod
    def indexOfSubList(cls, list: 'List'[_py_Any], list2: 'List'[_py_Any]) -> int: ...
    @classmethod
    def lastIndexOfSubList(cls, list: 'List'[_py_Any], list2: 'List'[_py_Any]) -> int: ...
    _list__T = _py_TypeVar('_list__T')  # <T>
    @classmethod
    def list(cls, enumeration: 'Enumeration'[_list__T]) -> 'ArrayList'[_list__T]: ...
    _max_0__T = _py_TypeVar('_max_0__T')  # <T>
    @classmethod
    @overload
    def max(cls, collection: Collection[_max_0__T], comparator: 'Comparator'[_max_0__T]) -> _max_0__T: ...
    _max_1__T = _py_TypeVar('_max_1__T')  # <T>
    @classmethod
    @overload
    def max(cls, collection: Collection[_max_1__T]) -> _max_1__T: ...
    _min_0__T = _py_TypeVar('_min_0__T')  # <T>
    @classmethod
    @overload
    def min(cls, collection: Collection[_min_0__T], comparator: 'Comparator'[_min_0__T]) -> _min_0__T: ...
    _min_1__T = _py_TypeVar('_min_1__T')  # <T>
    @classmethod
    @overload
    def min(cls, collection: Collection[_min_1__T]) -> _min_1__T: ...
    _nCopies__T = _py_TypeVar('_nCopies__T')  # <T>
    @classmethod
    def nCopies(cls, int: int, t: _nCopies__T) -> 'List'[_nCopies__T]: ...
    _newSetFromMap__E = _py_TypeVar('_newSetFromMap__E')  # <E>
    @classmethod
    def newSetFromMap(cls, map: 'Map'[_newSetFromMap__E, bool]) -> 'Set'[_newSetFromMap__E]: ...
    _replaceAll__T = _py_TypeVar('_replaceAll__T')  # <T>
    @classmethod
    def replaceAll(cls, list: 'List'[_replaceAll__T], t: _replaceAll__T, t2: _replaceAll__T) -> bool: ...
    @classmethod
    def reverse(cls, list: 'List'[_py_Any]) -> None: ...
    _reverseOrder_0__T = _py_TypeVar('_reverseOrder_0__T')  # <T>
    @classmethod
    @overload
    def reverseOrder(cls) -> 'Comparator'[_reverseOrder_0__T]: ...
    _reverseOrder_1__T = _py_TypeVar('_reverseOrder_1__T')  # <T>
    @classmethod
    @overload
    def reverseOrder(cls, comparator: 'Comparator'[_reverseOrder_1__T]) -> 'Comparator'[_reverseOrder_1__T]: ...
    @classmethod
    def rotate(cls, list: 'List'[_py_Any], int: int) -> None: ...
    @classmethod
    @overload
    def shuffle(cls, list: 'List'[_py_Any]) -> None: ...
    @classmethod
    @overload
    def shuffle(cls, list: 'List'[_py_Any], random: 'Random') -> None: ...
    _singleton__T = _py_TypeVar('_singleton__T')  # <T>
    @classmethod
    def singleton(cls, t: _singleton__T) -> 'Set'[_singleton__T]: ...
    _singletonList__T = _py_TypeVar('_singletonList__T')  # <T>
    @classmethod
    def singletonList(cls, t: _singletonList__T) -> 'List'[_singletonList__T]: ...
    _singletonMap__K = _py_TypeVar('_singletonMap__K')  # <K>
    _singletonMap__V = _py_TypeVar('_singletonMap__V')  # <V>
    @classmethod
    def singletonMap(cls, k: _singletonMap__K, v: _singletonMap__V) -> 'Map'[_singletonMap__K, _singletonMap__V]: ...
    _sort_0__T = _py_TypeVar('_sort_0__T')  # <T>
    @classmethod
    @overload
    def sort(cls, list: 'List'[_sort_0__T], comparator: 'Comparator'[_sort_0__T]) -> None: ...
    _sort_1__T = _py_TypeVar('_sort_1__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    @overload
    def sort(cls, list: 'List'[_sort_1__T]) -> None: ...
    @classmethod
    def swap(cls, list: 'List'[_py_Any], int: int, int2: int) -> None: ...
    _synchronizedCollection__T = _py_TypeVar('_synchronizedCollection__T')  # <T>
    @classmethod
    def synchronizedCollection(cls, collection: Collection[_synchronizedCollection__T]) -> Collection[_synchronizedCollection__T]: ...
    _synchronizedList__T = _py_TypeVar('_synchronizedList__T')  # <T>
    @classmethod
    def synchronizedList(cls, list: 'List'[_synchronizedList__T]) -> 'List'[_synchronizedList__T]: ...
    _synchronizedMap__K = _py_TypeVar('_synchronizedMap__K')  # <K>
    _synchronizedMap__V = _py_TypeVar('_synchronizedMap__V')  # <V>
    @classmethod
    def synchronizedMap(cls, map: 'Map'[_synchronizedMap__K, _synchronizedMap__V]) -> 'Map'[_synchronizedMap__K, _synchronizedMap__V]: ...
    _synchronizedNavigableMap__K = _py_TypeVar('_synchronizedNavigableMap__K')  # <K>
    _synchronizedNavigableMap__V = _py_TypeVar('_synchronizedNavigableMap__V')  # <V>
    @classmethod
    def synchronizedNavigableMap(cls, navigableMap: 'NavigableMap'[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V]) -> 'NavigableMap'[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V]: ...
    _synchronizedNavigableSet__T = _py_TypeVar('_synchronizedNavigableSet__T')  # <T>
    @classmethod
    def synchronizedNavigableSet(cls, navigableSet: 'NavigableSet'[_synchronizedNavigableSet__T]) -> 'NavigableSet'[_synchronizedNavigableSet__T]: ...
    _synchronizedSet__T = _py_TypeVar('_synchronizedSet__T')  # <T>
    @classmethod
    def synchronizedSet(cls, set: 'Set'[_synchronizedSet__T]) -> 'Set'[_synchronizedSet__T]: ...
    _synchronizedSortedMap__K = _py_TypeVar('_synchronizedSortedMap__K')  # <K>
    _synchronizedSortedMap__V = _py_TypeVar('_synchronizedSortedMap__V')  # <V>
    @classmethod
    def synchronizedSortedMap(cls, sortedMap: 'SortedMap'[_synchronizedSortedMap__K, _synchronizedSortedMap__V]) -> 'SortedMap'[_synchronizedSortedMap__K, _synchronizedSortedMap__V]: ...
    _synchronizedSortedSet__T = _py_TypeVar('_synchronizedSortedSet__T')  # <T>
    @classmethod
    def synchronizedSortedSet(cls, sortedSet: 'SortedSet'[_synchronizedSortedSet__T]) -> 'SortedSet'[_synchronizedSortedSet__T]: ...
    _unmodifiableCollection__T = _py_TypeVar('_unmodifiableCollection__T')  # <T>
    @classmethod
    def unmodifiableCollection(cls, collection: Collection[_unmodifiableCollection__T]) -> Collection[_unmodifiableCollection__T]: ...
    _unmodifiableList__T = _py_TypeVar('_unmodifiableList__T')  # <T>
    @classmethod
    def unmodifiableList(cls, list: 'List'[_unmodifiableList__T]) -> 'List'[_unmodifiableList__T]: ...
    _unmodifiableMap__K = _py_TypeVar('_unmodifiableMap__K')  # <K>
    _unmodifiableMap__V = _py_TypeVar('_unmodifiableMap__V')  # <V>
    @classmethod
    def unmodifiableMap(cls, map: 'Map'[_unmodifiableMap__K, _unmodifiableMap__V]) -> 'Map'[_unmodifiableMap__K, _unmodifiableMap__V]: ...
    _unmodifiableNavigableMap__K = _py_TypeVar('_unmodifiableNavigableMap__K')  # <K>
    _unmodifiableNavigableMap__V = _py_TypeVar('_unmodifiableNavigableMap__V')  # <V>
    @classmethod
    def unmodifiableNavigableMap(cls, navigableMap: 'NavigableMap'[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V]) -> 'NavigableMap'[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V]: ...
    _unmodifiableNavigableSet__T = _py_TypeVar('_unmodifiableNavigableSet__T')  # <T>
    @classmethod
    def unmodifiableNavigableSet(cls, navigableSet: 'NavigableSet'[_unmodifiableNavigableSet__T]) -> 'NavigableSet'[_unmodifiableNavigableSet__T]: ...
    _unmodifiableSet__T = _py_TypeVar('_unmodifiableSet__T')  # <T>
    @classmethod
    def unmodifiableSet(cls, set: 'Set'[_unmodifiableSet__T]) -> 'Set'[_unmodifiableSet__T]: ...
    _unmodifiableSortedMap__K = _py_TypeVar('_unmodifiableSortedMap__K')  # <K>
    _unmodifiableSortedMap__V = _py_TypeVar('_unmodifiableSortedMap__V')  # <V>
    @classmethod
    def unmodifiableSortedMap(cls, sortedMap: 'SortedMap'[_unmodifiableSortedMap__K, _unmodifiableSortedMap__V]) -> 'SortedMap'[_unmodifiableSortedMap__K, _unmodifiableSortedMap__V]: ...
    _unmodifiableSortedSet__T = _py_TypeVar('_unmodifiableSortedSet__T')  # <T>
    @classmethod
    def unmodifiableSortedSet(cls, sortedSet: 'SortedSet'[_unmodifiableSortedSet__T]) -> 'SortedSet'[_unmodifiableSortedSet__T]: ...

class ComparableTimSort: ...

_Comparator__T = _py_TypeVar('_Comparator__T')  # <T>
class Comparator(_py_Generic[_Comparator__T]):
    def compare(self, t: _Comparator__T, t2: _Comparator__T) -> int: ...
    _comparing_0__T = _py_TypeVar('_comparing_0__T')  # <T>
    _comparing_0__U = _py_TypeVar('_comparing_0__U')  # <U>
    @classmethod
    @overload
    def comparing(cls, function: java.util.function.Function[_comparing_0__T, _comparing_0__U], comparator: 'Comparator'[_comparing_0__U]) -> 'Comparator'[_comparing_0__T]: ...
    _comparing_1__T = _py_TypeVar('_comparing_1__T')  # <T>
    _comparing_1__U = _py_TypeVar('_comparing_1__U', bound=java.lang.Comparable)  # <U>
    @classmethod
    @overload
    def comparing(cls, function: java.util.function.Function[_comparing_1__T, _comparing_1__U]) -> 'Comparator'[_comparing_1__T]: ...
    _comparingDouble__T = _py_TypeVar('_comparingDouble__T')  # <T>
    @classmethod
    def comparingDouble(cls, toDoubleFunction: java.util.function.ToDoubleFunction[_comparingDouble__T]) -> 'Comparator'[_comparingDouble__T]: ...
    _comparingInt__T = _py_TypeVar('_comparingInt__T')  # <T>
    @classmethod
    def comparingInt(cls, toIntFunction: java.util.function.ToIntFunction[_comparingInt__T]) -> 'Comparator'[_comparingInt__T]: ...
    _comparingLong__T = _py_TypeVar('_comparingLong__T')  # <T>
    @classmethod
    def comparingLong(cls, toLongFunction: java.util.function.ToLongFunction[_comparingLong__T]) -> 'Comparator'[_comparingLong__T]: ...
    def equals(self, object: _py_Any) -> bool: ...
    _naturalOrder__T = _py_TypeVar('_naturalOrder__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    def naturalOrder(cls) -> 'Comparator'[_naturalOrder__T]: ...
    _nullsFirst__T = _py_TypeVar('_nullsFirst__T')  # <T>
    @classmethod
    def nullsFirst(cls, comparator: 'Comparator'[_nullsFirst__T]) -> 'Comparator'[_nullsFirst__T]: ...
    _nullsLast__T = _py_TypeVar('_nullsLast__T')  # <T>
    @classmethod
    def nullsLast(cls, comparator: 'Comparator'[_nullsLast__T]) -> 'Comparator'[_nullsLast__T]: ...
    _reverseOrder__T = _py_TypeVar('_reverseOrder__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    def reverseOrder(cls) -> 'Comparator'[_reverseOrder__T]: ...
    def reversed(self) -> 'Comparator'[_Comparator__T]: ...
    _thenComparing_0__U = _py_TypeVar('_thenComparing_0__U', bound=java.lang.Comparable)  # <U>
    @overload
    def thenComparing(self, function: java.util.function.Function[_Comparator__T, _thenComparing_0__U]) -> 'Comparator'[_Comparator__T]: ...
    @overload
    def thenComparing(self, comparator: 'Comparator'[_Comparator__T]) -> 'Comparator'[_Comparator__T]: ...
    _thenComparing_2__U = _py_TypeVar('_thenComparing_2__U')  # <U>
    @overload
    def thenComparing(self, function: java.util.function.Function[_Comparator__T, _thenComparing_2__U], comparator: 'Comparator'[_thenComparing_2__U]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingDouble(self, toDoubleFunction: java.util.function.ToDoubleFunction[_Comparator__T]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingInt(self, toIntFunction: java.util.function.ToIntFunction[_Comparator__T]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingLong(self, toLongFunction: java.util.function.ToLongFunction[_Comparator__T]) -> 'Comparator'[_Comparator__T]: ...

class Comparators: ...

class ConcurrentModificationException(java.lang.RuntimeException):
    @overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...
    @overload
    def __init__(self, throwable: java.lang.Throwable): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self): ...

class Currency(java.io.Serializable):
    @classmethod
    def getAvailableCurrencies(cls) -> 'Set'['Currency']: ...
    def getCurrencyCode(self) -> str: ...
    def getDefaultFractionDigits(self) -> int: ...
    @overload
    def getDisplayName(self) -> str: ...
    @overload
    def getDisplayName(self, locale: 'Locale') -> str: ...
    @classmethod
    @overload
    def getInstance(cls, string: str) -> 'Currency': ...
    @classmethod
    @overload
    def getInstance(cls, locale: 'Locale') -> 'Currency': ...
    def getNumericCode(self) -> int: ...
    @overload
    def getSymbol(self) -> str: ...
    @overload
    def getSymbol(self, locale: 'Locale') -> str: ...
    def toString(self) -> str: ...

class Date(java.io.Serializable, java.lang.Cloneable, java.lang.Comparable['Date']):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, long: int): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int): ...
    @classmethod
    def UTC(cls, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    def after(self, date: 'Date') -> bool: ...
    def before(self, date: 'Date') -> bool: ...
    def clone(self) -> _py_Any: ...
    @overload
    def compareTo(self, date: 'Date') -> int: ...
    @overload
    def compareTo(self, object: _py_Any) -> int: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getDate(self) -> int: ...
    def getDay(self) -> int: ...
    def getHours(self) -> int: ...
    def getMinutes(self) -> int: ...
    def getMonth(self) -> int: ...
    def getSeconds(self) -> int: ...
    def getTime(self) -> int: ...
    def getTimezoneOffset(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    @classmethod
    def parse(cls, string: str) -> int: ...
    def setDate(self, int: int) -> None: ...
    def setHours(self, int: int) -> None: ...
    def setMinutes(self, int: int) -> None: ...
    def setMonth(self, int: int) -> None: ...
    def setSeconds(self, int: int) -> None: ...
    def setTime(self, long: int) -> None: ...
    def setYear(self, int: int) -> None: ...
    def toGMTString(self) -> str: ...
    def toInstant(self) -> java.time.Instant: ...
    def toLocaleString(self) -> str: ...
    def toString(self) -> str: ...

_Dictionary__K = _py_TypeVar('_Dictionary__K')  # <K>
_Dictionary__V = _py_TypeVar('_Dictionary__V')  # <V>
class Dictionary(_py_Generic[_Dictionary__K, _Dictionary__V]):
    def __init__(self): ...
    def elements(self) -> 'Enumeration'[_Dictionary__V]: ...
    def get(self, object: _py_Any) -> _Dictionary__V: ...
    def isEmpty(self) -> bool: ...
    def keys(self) -> 'Enumeration'[_Dictionary__K]: ...
    def put(self, k: _Dictionary__K, v: _Dictionary__V) -> _Dictionary__V: ...
    def remove(self, object: _py_Any) -> _Dictionary__V: ...
    def size(self) -> int: ...

class DoubleSummaryStatistics(java.util.function.DoubleConsumer):
    def __init__(self): ...
    def accept(self, double: float) -> None: ...
    def combine(self, doubleSummaryStatistics: 'DoubleSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> float: ...
    def getMin(self) -> float: ...
    def getSum(self) -> float: ...
    def toString(self) -> str: ...

class DualPivotQuicksort: ...

class EmptyStackException(java.lang.RuntimeException):
    def __init__(self): ...

_Enumeration__E = _py_TypeVar('_Enumeration__E')  # <E>
class Enumeration(_py_Generic[_Enumeration__E]):
    def hasMoreElements(self) -> bool: ...
    def nextElement(self) -> _Enumeration__E: ...

class EventListener: ...

class EventObject(java.io.Serializable):
    def __init__(self, object: _py_Any): ...
    def getSource(self) -> _py_Any: ...
    def toString(self) -> str: ...

class Formattable:
    def formatTo(self, formatter: 'Formatter', int: int, int2: int, int3: int) -> None: ...

class FormattableFlags:
    LEFT_JUSTIFY: _py_ClassVar[int] = ...
    UPPERCASE: _py_ClassVar[int] = ...
    ALTERNATE: _py_ClassVar[int] = ...

class Formatter(java.io.Closeable, java.io.Flushable):
    @overload
    def __init__(self, printStream: java.io.PrintStream): ...
    @overload
    def __init__(self, file: java.io.File, string: str, locale: 'Locale'): ...
    @overload
    def __init__(self, file: java.io.File, string: str): ...
    @overload
    def __init__(self, file: java.io.File): ...
    @overload
    def __init__(self, outputStream: java.io.OutputStream): ...
    @overload
    def __init__(self, outputStream: java.io.OutputStream, string: str): ...
    @overload
    def __init__(self, outputStream: java.io.OutputStream, string: str, locale: 'Locale'): ...
    @overload
    def __init__(self, locale: 'Locale'): ...
    @overload
    def __init__(self, appendable: java.lang.Appendable): ...
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str, string2: str, locale: 'Locale'): ...
    @overload
    def __init__(self, string: str, string2: str): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, appendable: java.lang.Appendable, locale: 'Locale'): ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @overload
    def format(self, locale: 'Locale', string: str, objectArray: _py_List[_py_Any]) -> 'Formatter': ...
    @overload
    def format(self, string: str, objectArray: _py_List[_py_Any]) -> 'Formatter': ...
    def ioException(self) -> java.io.IOException: ...
    def locale(self) -> 'Locale': ...
    def out(self) -> java.lang.Appendable: ...
    def toString(self) -> str: ...
    class BigDecimalLayoutForm(java.lang.Enum['Formatter.BigDecimalLayoutForm']):
        SCIENTIFIC: _py_ClassVar['Formatter.BigDecimalLayoutForm'] = ...
        DECIMAL_FLOAT: _py_ClassVar['Formatter.BigDecimalLayoutForm'] = ...
        @classmethod
        @overload
        def valueOf(cls, string: str) -> 'Formatter.BigDecimalLayoutForm': ...
        _valueOf_1__T = _py_TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @overload
        def valueOf(cls, class_: _py_Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
        @classmethod
        def values(cls) -> _py_List['Formatter.BigDecimalLayoutForm']: ...

class FormatterClosedException(java.lang.IllegalStateException):
    def __init__(self): ...

class IllegalFormatException(java.lang.IllegalArgumentException): ...

class IllformedLocaleException(java.lang.RuntimeException):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str, int: int): ...
    @overload
    def __init__(self, string: str): ...
    def getErrorIndex(self) -> int: ...

class IntSummaryStatistics(java.util.function.IntConsumer):
    def __init__(self): ...
    def accept(self, int: int) -> None: ...
    def combine(self, intSummaryStatistics: 'IntSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> int: ...
    def getMin(self) -> int: ...
    def getSum(self) -> int: ...
    def toString(self) -> str: ...

class InvalidPropertiesFormatException(java.io.IOException):
    @overload
    def __init__(self, throwable: java.lang.Throwable): ...
    @overload
    def __init__(self, string: str): ...

_Iterator__E = _py_TypeVar('_Iterator__E')  # <E>
class Iterator(_py_Generic[_Iterator__E]):
    def forEachRemaining(self, consumer: java.util.function.Consumer[_Iterator__E]) -> None: ...
    def hasNext(self) -> bool: ...
    def next(self) -> _Iterator__E: ...
    def remove(self) -> None: ...

class Locale(java.lang.Cloneable, java.io.Serializable):
    ENGLISH: _py_ClassVar['Locale'] = ...
    FRENCH: _py_ClassVar['Locale'] = ...
    GERMAN: _py_ClassVar['Locale'] = ...
    ITALIAN: _py_ClassVar['Locale'] = ...
    JAPANESE: _py_ClassVar['Locale'] = ...
    KOREAN: _py_ClassVar['Locale'] = ...
    CHINESE: _py_ClassVar['Locale'] = ...
    SIMPLIFIED_CHINESE: _py_ClassVar['Locale'] = ...
    TRADITIONAL_CHINESE: _py_ClassVar['Locale'] = ...
    FRANCE: _py_ClassVar['Locale'] = ...
    GERMANY: _py_ClassVar['Locale'] = ...
    ITALY: _py_ClassVar['Locale'] = ...
    JAPAN: _py_ClassVar['Locale'] = ...
    KOREA: _py_ClassVar['Locale'] = ...
    CHINA: _py_ClassVar['Locale'] = ...
    PRC: _py_ClassVar['Locale'] = ...
    TAIWAN: _py_ClassVar['Locale'] = ...
    UK: _py_ClassVar['Locale'] = ...
    US: _py_ClassVar['Locale'] = ...
    CANADA: _py_ClassVar['Locale'] = ...
    CANADA_FRENCH: _py_ClassVar['Locale'] = ...
    ROOT: _py_ClassVar['Locale'] = ...
    PRIVATE_USE_EXTENSION: _py_ClassVar[str] = ...
    UNICODE_LOCALE_EXTENSION: _py_ClassVar[str] = ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, string2: str): ...
    @overload
    def __init__(self, string: str, string2: str, string3: str): ...
    def clone(self) -> _py_Any: ...
    def equals(self, object: _py_Any) -> bool: ...
    @classmethod
    @overload
    def filter(cls, list: 'List'['Locale.LanguageRange'], collection: Collection['Locale'], filteringMode: 'Locale.FilteringMode') -> 'List'['Locale']: ...
    @classmethod
    @overload
    def filter(cls, list: 'List'['Locale.LanguageRange'], collection: Collection['Locale']) -> 'List'['Locale']: ...
    @classmethod
    @overload
    def filterTags(cls, list: 'List'['Locale.LanguageRange'], collection: Collection[str]) -> 'List'[str]: ...
    @classmethod
    @overload
    def filterTags(cls, list: 'List'['Locale.LanguageRange'], collection: Collection[str], filteringMode: 'Locale.FilteringMode') -> 'List'[str]: ...
    @classmethod
    def forLanguageTag(cls, string: str) -> 'Locale': ...
    @classmethod
    def getAvailableLocales(cls) -> _py_List['Locale']: ...
    def getCountry(self) -> str: ...
    @classmethod
    @overload
    def getDefault(cls, category: 'Locale.Category') -> 'Locale': ...
    @classmethod
    @overload
    def getDefault(cls) -> 'Locale': ...
    @overload
    def getDisplayCountry(self) -> str: ...
    @overload
    def getDisplayCountry(self, locale: 'Locale') -> str: ...
    @overload
    def getDisplayLanguage(self, locale: 'Locale') -> str: ...
    @overload
    def getDisplayLanguage(self) -> str: ...
    @overload
    def getDisplayName(self) -> str: ...
    @overload
    def getDisplayName(self, locale: 'Locale') -> str: ...
    @overload
    def getDisplayScript(self) -> str: ...
    @overload
    def getDisplayScript(self, locale: 'Locale') -> str: ...
    @overload
    def getDisplayVariant(self) -> str: ...
    @overload
    def getDisplayVariant(self, locale: 'Locale') -> str: ...
    def getExtension(self, char: str) -> str: ...
    def getExtensionKeys(self) -> 'Set'[str]: ...
    def getISO3Country(self) -> str: ...
    def getISO3Language(self) -> str: ...
    @classmethod
    def getISOCountries(cls) -> _py_List[str]: ...
    @classmethod
    def getISOLanguages(cls) -> _py_List[str]: ...
    def getLanguage(self) -> str: ...
    def getScript(self) -> str: ...
    def getUnicodeLocaleAttributes(self) -> 'Set'[str]: ...
    def getUnicodeLocaleKeys(self) -> 'Set'[str]: ...
    def getUnicodeLocaleType(self, string: str) -> str: ...
    def getVariant(self) -> str: ...
    def hasExtensions(self) -> bool: ...
    def hashCode(self) -> int: ...
    @classmethod
    def lookup(cls, list: 'List'['Locale.LanguageRange'], collection: Collection['Locale']) -> 'Locale': ...
    @classmethod
    def lookupTag(cls, list: 'List'['Locale.LanguageRange'], collection: Collection[str]) -> str: ...
    @classmethod
    @overload
    def setDefault(cls, locale: 'Locale') -> None: ...
    @classmethod
    @overload
    def setDefault(cls, category: 'Locale.Category', locale: 'Locale') -> None: ...
    def stripExtensions(self) -> 'Locale': ...
    def toLanguageTag(self) -> str: ...
    def toString(self) -> str: ...
    class Builder:
        def __init__(self): ...
        def addUnicodeLocaleAttribute(self, string: str) -> 'Locale.Builder': ...
        def build(self) -> 'Locale': ...
        def clear(self) -> 'Locale.Builder': ...
        def clearExtensions(self) -> 'Locale.Builder': ...
        def removeUnicodeLocaleAttribute(self, string: str) -> 'Locale.Builder': ...
        def setExtension(self, char: str, string: str) -> 'Locale.Builder': ...
        def setLanguage(self, string: str) -> 'Locale.Builder': ...
        def setLanguageTag(self, string: str) -> 'Locale.Builder': ...
        def setLocale(self, locale: 'Locale') -> 'Locale.Builder': ...
        def setRegion(self, string: str) -> 'Locale.Builder': ...
        def setScript(self, string: str) -> 'Locale.Builder': ...
        def setUnicodeLocaleKeyword(self, string: str, string2: str) -> 'Locale.Builder': ...
        def setVariant(self, string: str) -> 'Locale.Builder': ...
    class Category(java.lang.Enum['Locale.Category']):
        DISPLAY: _py_ClassVar['Locale.Category'] = ...
        FORMAT: _py_ClassVar['Locale.Category'] = ...
        @classmethod
        @overload
        def valueOf(cls, string: str) -> 'Locale.Category': ...
        _valueOf_1__T = _py_TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @overload
        def valueOf(cls, class_: _py_Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
        @classmethod
        def values(cls) -> _py_List['Locale.Category']: ...
    class FilteringMode(java.lang.Enum['Locale.FilteringMode']):
        AUTOSELECT_FILTERING: _py_ClassVar['Locale.FilteringMode'] = ...
        EXTENDED_FILTERING: _py_ClassVar['Locale.FilteringMode'] = ...
        IGNORE_EXTENDED_RANGES: _py_ClassVar['Locale.FilteringMode'] = ...
        MAP_EXTENDED_RANGES: _py_ClassVar['Locale.FilteringMode'] = ...
        REJECT_EXTENDED_RANGES: _py_ClassVar['Locale.FilteringMode'] = ...
        @classmethod
        @overload
        def valueOf(cls, string: str) -> 'Locale.FilteringMode': ...
        _valueOf_1__T = _py_TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @overload
        def valueOf(cls, class_: _py_Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
        @classmethod
        def values(cls) -> _py_List['Locale.FilteringMode']: ...
    class LanguageRange:
        MAX_WEIGHT: _py_ClassVar[float] = ...
        MIN_WEIGHT: _py_ClassVar[float] = ...
        @overload
        def __init__(self, string: str, double: float): ...
        @overload
        def __init__(self, string: str): ...
        def equals(self, object: _py_Any) -> bool: ...
        def getRange(self) -> str: ...
        def getWeight(self) -> float: ...
        def hashCode(self) -> int: ...
        @classmethod
        def mapEquivalents(cls, list: 'List'['Locale.LanguageRange'], map: 'Map'[str, 'List'[str]]) -> 'List'['Locale.LanguageRange']: ...
        @classmethod
        @overload
        def parse(cls, string: str) -> 'List'['Locale.LanguageRange']: ...
        @classmethod
        @overload
        def parse(cls, string: str, map: 'Map'[str, 'List'[str]]) -> 'List'['Locale.LanguageRange']: ...

class LocaleISOData: ...

class LongSummaryStatistics(java.util.function.LongConsumer, java.util.function.IntConsumer):
    def __init__(self): ...
    @overload
    def accept(self, int: int) -> None: ...
    @overload
    def accept(self, long: int) -> None: ...
    def combine(self, longSummaryStatistics: 'LongSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> int: ...
    def getMin(self) -> int: ...
    def getSum(self) -> int: ...
    def toString(self) -> str: ...

_Map__Entry__K = _py_TypeVar('_Map__Entry__K')  # <K>
_Map__Entry__V = _py_TypeVar('_Map__Entry__V')  # <V>
_Map__K = _py_TypeVar('_Map__K')  # <K>
_Map__V = _py_TypeVar('_Map__V')  # <V>
class Map(_py_Generic[_Map__K, _Map__V], _py_Mapping[_Map__K, _Map__V]):
    def clear(self) -> None: ...
    def compute(self, k: _Map__K, biFunction: java.util.function.BiFunction[_Map__K, _Map__V, _Map__V]) -> _Map__V: ...
    def computeIfAbsent(self, k: _Map__K, function: java.util.function.Function[_Map__K, _Map__V]) -> _Map__V: ...
    def computeIfPresent(self, k: _Map__K, biFunction: java.util.function.BiFunction[_Map__K, _Map__V, _Map__V]) -> _Map__V: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> 'Set'['Map.Entry'[_Map__K, _Map__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_Map__K, _Map__V]) -> None: ...
    def get(self, object: _py_Any) -> _Map__V: ...
    def getOrDefault(self, object: _py_Any, v: _Map__V) -> _Map__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'Set'[_Map__K]: ...
    def merge(self, k: _Map__K, v: _Map__V, biFunction: java.util.function.BiFunction[_Map__V, _Map__V, _Map__V]) -> _Map__V: ...
    def put(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    def putAll(self, map: 'Map'[_Map__K, _Map__V]) -> None: ...
    def putIfAbsent(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    @overload
    def remove(self, object: _py_Any) -> _Map__V: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def replace(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    @overload
    def replace(self, k: _Map__K, v: _Map__V, v2: _Map__V) -> bool: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_Map__K, _Map__V, _Map__V]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_Map__V]: ...
    class Entry(_py_Generic[_Map__Entry__K, _Map__Entry__V]):
        _comparingByKey_0__K = _py_TypeVar('_comparingByKey_0__K')  # <K>
        _comparingByKey_0__V = _py_TypeVar('_comparingByKey_0__V')  # <V>
        @classmethod
        @overload
        def comparingByKey(cls, comparator: Comparator[_comparingByKey_0__K]) -> Comparator['Map.Entry'[_comparingByKey_0__K, _comparingByKey_0__V]]: ...
        _comparingByKey_1__K = _py_TypeVar('_comparingByKey_1__K', bound=java.lang.Comparable)  # <K>
        _comparingByKey_1__V = _py_TypeVar('_comparingByKey_1__V')  # <V>
        @classmethod
        @overload
        def comparingByKey(cls) -> Comparator['Map.Entry'[_comparingByKey_1__K, _comparingByKey_1__V]]: ...
        _comparingByValue_0__K = _py_TypeVar('_comparingByValue_0__K')  # <K>
        _comparingByValue_0__V = _py_TypeVar('_comparingByValue_0__V', bound=java.lang.Comparable)  # <V>
        @classmethod
        @overload
        def comparingByValue(cls) -> Comparator['Map.Entry'[_comparingByValue_0__K, _comparingByValue_0__V]]: ...
        _comparingByValue_1__K = _py_TypeVar('_comparingByValue_1__K')  # <K>
        _comparingByValue_1__V = _py_TypeVar('_comparingByValue_1__V')  # <V>
        @classmethod
        @overload
        def comparingByValue(cls, comparator: Comparator[_comparingByValue_1__V]) -> Comparator['Map.Entry'[_comparingByValue_1__K, _comparingByValue_1__V]]: ...
        def equals(self, object: _py_Any) -> bool: ...
        def getKey(self) -> _Map__Entry__K: ...
        def getValue(self) -> _Map__Entry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _Map__Entry__V) -> _Map__Entry__V: ...

class MissingResourceException(java.lang.RuntimeException):
    def __init__(self, string: str, string2: str, string3: str): ...
    def getClassName(self) -> str: ...
    def getKey(self) -> str: ...

class NoSuchElementException(java.lang.RuntimeException):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str): ...

class Objects:
    _compare__T = _py_TypeVar('_compare__T')  # <T>
    @classmethod
    def compare(cls, t: _compare__T, t2: _compare__T, comparator: Comparator[_compare__T]) -> int: ...
    @classmethod
    def deepEquals(cls, object: _py_Any, object2: _py_Any) -> bool: ...
    @classmethod
    @overload
    def equals(cls, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def equals(self, object: _py_Any) -> bool: ...
    @classmethod
    def hash(cls, objectArray: _py_List[_py_Any]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, object: _py_Any) -> int: ...
    @overload
    def hashCode(self) -> int: ...
    @classmethod
    def isNull(cls, object: _py_Any) -> bool: ...
    @classmethod
    def nonNull(cls, object: _py_Any) -> bool: ...
    _requireNonNull_0__T = _py_TypeVar('_requireNonNull_0__T')  # <T>
    @classmethod
    @overload
    def requireNonNull(cls, t: _requireNonNull_0__T, supplier: java.util.function.Supplier[str]) -> _requireNonNull_0__T: ...
    _requireNonNull_1__T = _py_TypeVar('_requireNonNull_1__T')  # <T>
    @classmethod
    @overload
    def requireNonNull(cls, t: _requireNonNull_1__T, string: str) -> _requireNonNull_1__T: ...
    _requireNonNull_2__T = _py_TypeVar('_requireNonNull_2__T')  # <T>
    @classmethod
    @overload
    def requireNonNull(cls, t: _requireNonNull_2__T) -> _requireNonNull_2__T: ...
    @classmethod
    @overload
    def toString(cls, object: _py_Any) -> str: ...
    @classmethod
    @overload
    def toString(cls, object: _py_Any, string: str) -> str: ...
    @overload
    def toString(self) -> str: ...

class Observable:
    def __init__(self): ...
    def addObserver(self, observer: 'Observer') -> None: ...
    def countObservers(self) -> int: ...
    def deleteObserver(self, observer: 'Observer') -> None: ...
    def deleteObservers(self) -> None: ...
    def hasChanged(self) -> bool: ...
    @overload
    def notifyObservers(self) -> None: ...
    @overload
    def notifyObservers(self, object: _py_Any) -> None: ...

class Observer:
    def update(self, observable: Observable, object: _py_Any) -> None: ...

_Optional__T = _py_TypeVar('_Optional__T')  # <T>
class Optional(_py_Generic[_Optional__T]):
    _empty__T = _py_TypeVar('_empty__T')  # <T>
    @classmethod
    def empty(cls) -> 'Optional'[_empty__T]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def filter(self, predicate: java.util.function.Predicate[_Optional__T]) -> 'Optional'[_Optional__T]: ...
    _flatMap__U = _py_TypeVar('_flatMap__U')  # <U>
    def flatMap(self, function: java.util.function.Function[_Optional__T, 'Optional'[_flatMap__U]]) -> 'Optional'[_flatMap__U]: ...
    def get(self) -> _Optional__T: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, consumer: java.util.function.Consumer[_Optional__T]) -> None: ...
    def isPresent(self) -> bool: ...
    _map__U = _py_TypeVar('_map__U')  # <U>
    def map(self, function: java.util.function.Function[_Optional__T, _map__U]) -> 'Optional'[_map__U]: ...
    _of__T = _py_TypeVar('_of__T')  # <T>
    @classmethod
    def of(cls, t: _of__T) -> 'Optional'[_of__T]: ...
    _ofNullable__T = _py_TypeVar('_ofNullable__T')  # <T>
    @classmethod
    def ofNullable(cls, t: _ofNullable__T) -> 'Optional'[_ofNullable__T]: ...
    def orElse(self, t: _Optional__T) -> _Optional__T: ...
    def orElseGet(self, supplier: java.util.function.Supplier[_Optional__T]) -> _Optional__T: ...
    _orElseThrow__X = _py_TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: java.util.function.Supplier[_orElseThrow__X]) -> _Optional__T: ...
    def toString(self) -> str: ...

class OptionalDouble:
    @classmethod
    def empty(cls) -> 'OptionalDouble': ...
    def equals(self, object: _py_Any) -> bool: ...
    def getAsDouble(self) -> float: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, doubleConsumer: java.util.function.DoubleConsumer) -> None: ...
    def isPresent(self) -> bool: ...
    @classmethod
    def of(cls, double: float) -> 'OptionalDouble': ...
    def orElse(self, double: float) -> float: ...
    def orElseGet(self, doubleSupplier: java.util.function.DoubleSupplier) -> float: ...
    _orElseThrow__X = _py_TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: java.util.function.Supplier[_orElseThrow__X]) -> float: ...
    def toString(self) -> str: ...

class OptionalInt:
    @classmethod
    def empty(cls) -> 'OptionalInt': ...
    def equals(self, object: _py_Any) -> bool: ...
    def getAsInt(self) -> int: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, intConsumer: java.util.function.IntConsumer) -> None: ...
    def isPresent(self) -> bool: ...
    @classmethod
    def of(cls, int: int) -> 'OptionalInt': ...
    def orElse(self, int: int) -> int: ...
    def orElseGet(self, intSupplier: java.util.function.IntSupplier) -> int: ...
    _orElseThrow__X = _py_TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: java.util.function.Supplier[_orElseThrow__X]) -> int: ...
    def toString(self) -> str: ...

class OptionalLong:
    @classmethod
    def empty(cls) -> 'OptionalLong': ...
    def equals(self, object: _py_Any) -> bool: ...
    def getAsLong(self) -> int: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, longConsumer: java.util.function.LongConsumer) -> None: ...
    def isPresent(self) -> bool: ...
    @classmethod
    def of(cls, long: int) -> 'OptionalLong': ...
    def orElse(self, long: int) -> int: ...
    def orElseGet(self, longSupplier: java.util.function.LongSupplier) -> int: ...
    _orElseThrow__X = _py_TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: java.util.function.Supplier[_orElseThrow__X]) -> int: ...
    def toString(self) -> str: ...

class PropertyPermission(java.security.BasicPermission):
    def __init__(self, string: str, string2: str): ...
    def equals(self, object: _py_Any) -> bool: ...
    def getActions(self) -> str: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: java.security.Permission) -> bool: ...
    def newPermissionCollection(self) -> java.security.PermissionCollection: ...

class PropertyPermissionCollection(java.security.PermissionCollection, java.io.Serializable):
    def __init__(self): ...
    def add(self, permission: java.security.Permission) -> None: ...
    def elements(self) -> Enumeration[java.security.Permission]: ...
    def implies(self, permission: java.security.Permission) -> bool: ...

class Random(java.io.Serializable):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, long: int): ...
    @overload
    def doubles(self, long: int) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self, long: int, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @overload
    def ints(self, long: int) -> java.util.stream.IntStream: ...
    @overload
    def ints(self, int: int, int2: int) -> java.util.stream.IntStream: ...
    @overload
    def ints(self, long: int, int: int, int2: int) -> java.util.stream.IntStream: ...
    @overload
    def ints(self) -> java.util.stream.IntStream: ...
    @overload
    def longs(self, long: int, long2: int, long3: int) -> java.util.stream.LongStream: ...
    @overload
    def longs(self, long: int, long2: int) -> java.util.stream.LongStream: ...
    @overload
    def longs(self, long: int) -> java.util.stream.LongStream: ...
    @overload
    def longs(self) -> java.util.stream.LongStream: ...
    def nextBoolean(self) -> bool: ...
    def nextBytes(self, byteArray: _py_List[int]) -> None: ...
    def nextDouble(self) -> float: ...
    def nextFloat(self) -> float: ...
    def nextGaussian(self) -> float: ...
    @overload
    def nextInt(self) -> int: ...
    @overload
    def nextInt(self, int: int) -> int: ...
    def nextLong(self) -> int: ...
    def setSeed(self, long: int) -> None: ...

class RandomAccess: ...

class ResourceBundle:
    def __init__(self): ...
    @classmethod
    @overload
    def clearCache(cls) -> None: ...
    @classmethod
    @overload
    def clearCache(cls, classLoader: java.lang.ClassLoader) -> None: ...
    def containsKey(self, string: str) -> bool: ...
    def getBaseBundleName(self) -> str: ...
    @classmethod
    @overload
    def getBundle(cls, string: str) -> 'ResourceBundle': ...
    @classmethod
    @overload
    def getBundle(cls, string: str, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    @classmethod
    @overload
    def getBundle(cls, string: str, locale: Locale) -> 'ResourceBundle': ...
    @classmethod
    @overload
    def getBundle(cls, string: str, locale: Locale, classLoader: java.lang.ClassLoader, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    @classmethod
    @overload
    def getBundle(cls, string: str, locale: Locale, classLoader: java.lang.ClassLoader) -> 'ResourceBundle': ...
    @classmethod
    @overload
    def getBundle(cls, string: str, locale: Locale, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    def getKeys(self) -> Enumeration[str]: ...
    def getLocale(self) -> Locale: ...
    def getObject(self, string: str) -> _py_Any: ...
    def getString(self, string: str) -> str: ...
    def getStringArray(self, string: str) -> _py_List[str]: ...
    def keySet(self) -> 'Set'[str]: ...
    class Control:
        FORMAT_DEFAULT: _py_ClassVar['List'] = ...
        FORMAT_CLASS: _py_ClassVar['List'] = ...
        FORMAT_PROPERTIES: _py_ClassVar['List'] = ...
        TTL_DONT_CACHE: _py_ClassVar[int] = ...
        TTL_NO_EXPIRATION_CONTROL: _py_ClassVar[int] = ...
        def getCandidateLocales(self, string: str, locale: Locale) -> 'List'[Locale]: ...
        @classmethod
        def getControl(cls, list: 'List'[str]) -> 'ResourceBundle.Control': ...
        def getFallbackLocale(self, string: str, locale: Locale) -> Locale: ...
        def getFormats(self, string: str) -> 'List'[str]: ...
        @classmethod
        def getNoFallbackControl(cls, list: 'List'[str]) -> 'ResourceBundle.Control': ...
        def getTimeToLive(self, string: str, locale: Locale) -> int: ...
        def needsReload(self, string: str, locale: Locale, string2: str, classLoader: java.lang.ClassLoader, resourceBundle: 'ResourceBundle', long: int) -> bool: ...
        def newBundle(self, string: str, locale: Locale, string2: str, classLoader: java.lang.ClassLoader, boolean: bool) -> 'ResourceBundle': ...
        def toBundleName(self, string: str, locale: Locale) -> str: ...
        def toResourceName(self, string: str, string2: str) -> str: ...

class ServiceConfigurationError(java.lang.Error):
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...

_ServiceLoader__S = _py_TypeVar('_ServiceLoader__S')  # <S>
class ServiceLoader(java.lang.Iterable[_ServiceLoader__S], _py_Generic[_ServiceLoader__S]):
    def iterator(self) -> Iterator[_ServiceLoader__S]: ...
    _load_0__S = _py_TypeVar('_load_0__S')  # <S>
    @classmethod
    @overload
    def load(cls, class_: _py_Type[_load_0__S]) -> 'ServiceLoader'[_load_0__S]: ...
    _load_1__S = _py_TypeVar('_load_1__S')  # <S>
    @classmethod
    @overload
    def load(cls, class_: _py_Type[_load_1__S], classLoader: java.lang.ClassLoader) -> 'ServiceLoader'[_load_1__S]: ...
    _loadInstalled__S = _py_TypeVar('_loadInstalled__S')  # <S>
    @classmethod
    def loadInstalled(cls, class_: _py_Type[_loadInstalled__S]) -> 'ServiceLoader'[_loadInstalled__S]: ...
    def reload(self) -> None: ...
    def toString(self) -> str: ...

class SplittableRandom:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, long: int): ...
    @overload
    def doubles(self, long: int, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self, long: int) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @overload
    def ints(self) -> java.util.stream.IntStream: ...
    @overload
    def ints(self, long: int) -> java.util.stream.IntStream: ...
    @overload
    def ints(self, long: int, int: int, int2: int) -> java.util.stream.IntStream: ...
    @overload
    def ints(self, int: int, int2: int) -> java.util.stream.IntStream: ...
    @overload
    def longs(self, long: int) -> java.util.stream.LongStream: ...
    @overload
    def longs(self, long: int, long2: int, long3: int) -> java.util.stream.LongStream: ...
    @overload
    def longs(self, long: int, long2: int) -> java.util.stream.LongStream: ...
    @overload
    def longs(self) -> java.util.stream.LongStream: ...
    def nextBoolean(self) -> bool: ...
    @overload
    def nextDouble(self, double: float) -> float: ...
    @overload
    def nextDouble(self, double: float, double2: float) -> float: ...
    @overload
    def nextDouble(self) -> float: ...
    @overload
    def nextInt(self) -> int: ...
    @overload
    def nextInt(self, int: int) -> int: ...
    @overload
    def nextInt(self, int: int, int2: int) -> int: ...
    @overload
    def nextLong(self) -> int: ...
    @overload
    def nextLong(self, long: int) -> int: ...
    @overload
    def nextLong(self, long: int, long2: int) -> int: ...
    def split(self) -> 'SplittableRandom': ...

class StringJoiner:
    @overload
    def __init__(self, charSequence: java.lang.CharSequence): ...
    @overload
    def __init__(self, charSequence: java.lang.CharSequence, charSequence2: java.lang.CharSequence, charSequence3: java.lang.CharSequence): ...
    def add(self, charSequence: java.lang.CharSequence) -> 'StringJoiner': ...
    def length(self) -> int: ...
    def merge(self, stringJoiner: 'StringJoiner') -> 'StringJoiner': ...
    def setEmptyValue(self, charSequence: java.lang.CharSequence) -> 'StringJoiner': ...
    def toString(self) -> str: ...

class TaskQueue: ...

_TimSort__T = _py_TypeVar('_TimSort__T')  # <T>
class TimSort(_py_Generic[_TimSort__T]): ...

class TimeZone(java.io.Serializable, java.lang.Cloneable):
    SHORT: _py_ClassVar[int] = ...
    LONG: _py_ClassVar[int] = ...
    def __init__(self): ...
    def clone(self) -> _py_Any: ...
    @classmethod
    @overload
    def getAvailableIDs(cls, int: int) -> _py_List[str]: ...
    @classmethod
    @overload
    def getAvailableIDs(cls) -> _py_List[str]: ...
    def getDSTSavings(self) -> int: ...
    @classmethod
    def getDefault(cls) -> 'TimeZone': ...
    @overload
    def getDisplayName(self, boolean: bool, int: int, locale: Locale) -> str: ...
    @overload
    def getDisplayName(self) -> str: ...
    @overload
    def getDisplayName(self, locale: Locale) -> str: ...
    @overload
    def getDisplayName(self, boolean: bool, int: int) -> str: ...
    def getID(self) -> str: ...
    @overload
    def getOffset(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    @overload
    def getOffset(self, long: int) -> int: ...
    def getRawOffset(self) -> int: ...
    @classmethod
    @overload
    def getTimeZone(cls, string: str) -> 'TimeZone': ...
    @classmethod
    @overload
    def getTimeZone(cls, zoneId: java.time.ZoneId) -> 'TimeZone': ...
    def hasSameRules(self, timeZone: 'TimeZone') -> bool: ...
    def inDaylightTime(self, date: Date) -> bool: ...
    def observesDaylightTime(self) -> bool: ...
    @classmethod
    def setDefault(cls, timeZone: 'TimeZone') -> None: ...
    def setID(self, string: str) -> None: ...
    def setRawOffset(self, int: int) -> None: ...
    def toZoneId(self) -> java.time.ZoneId: ...
    def useDaylightTime(self) -> bool: ...

class Timer:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, boolean: bool): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, boolean: bool): ...
    def cancel(self) -> None: ...
    def purge(self) -> int: ...
    @overload
    def schedule(self, timerTask: 'TimerTask', date: Date) -> None: ...
    @overload
    def schedule(self, timerTask: 'TimerTask', long: int, long2: int) -> None: ...
    @overload
    def schedule(self, timerTask: 'TimerTask', date: Date, long: int) -> None: ...
    @overload
    def schedule(self, timerTask: 'TimerTask', long: int) -> None: ...
    @overload
    def scheduleAtFixedRate(self, timerTask: 'TimerTask', long: int, long2: int) -> None: ...
    @overload
    def scheduleAtFixedRate(self, timerTask: 'TimerTask', date: Date, long: int) -> None: ...

class TimerTask(java.lang.Runnable):
    def cancel(self) -> bool: ...
    def run(self) -> None: ...
    def scheduledExecutionTime(self) -> int: ...

class TimerThread(java.lang.Thread):
    def run(self) -> None: ...

class TooManyListenersException(java.lang.Exception):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str): ...

class Tripwire: ...

class UUID(java.io.Serializable, java.lang.Comparable['UUID']):
    def __init__(self, long: int, long2: int): ...
    def clockSequence(self) -> int: ...
    @overload
    def compareTo(self, uUID: 'UUID') -> int: ...
    @overload
    def compareTo(self, object: _py_Any) -> int: ...
    def equals(self, object: _py_Any) -> bool: ...
    @classmethod
    def fromString(cls, string: str) -> 'UUID': ...
    def getLeastSignificantBits(self) -> int: ...
    def getMostSignificantBits(self) -> int: ...
    def hashCode(self) -> int: ...
    @classmethod
    def nameUUIDFromBytes(cls, byteArray: _py_List[int]) -> 'UUID': ...
    def node(self) -> int: ...
    @classmethod
    def randomUUID(cls) -> 'UUID': ...
    def timestamp(self) -> int: ...
    def toString(self) -> str: ...
    def variant(self) -> int: ...
    def version(self) -> int: ...

_AbstractCollection__E = _py_TypeVar('_AbstractCollection__E')  # <E>
class AbstractCollection(Collection[_AbstractCollection__E], _py_Generic[_AbstractCollection__E]):
    def add(self, e: _AbstractCollection__E) -> bool: ...
    def addAll(self, collection: Collection[_AbstractCollection__E]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_AbstractCollection__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def size(self) -> int: ...
    _toArray_0__T = _py_TypeVar('_toArray_0__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_0__T]) -> _py_List[_toArray_0__T]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    def toString(self) -> str: ...

class DuplicateFormatFlagsException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

_EventListenerProxy__T = _py_TypeVar('_EventListenerProxy__T', bound=EventListener)  # <T>
class EventListenerProxy(EventListener, _py_Generic[_EventListenerProxy__T]):
    def __init__(self, t: _EventListenerProxy__T): ...
    def getListener(self) -> _EventListenerProxy__T: ...

class FormatFlagsConversionMismatchException(IllegalFormatException):
    def __init__(self, string: str, char: str): ...
    def getConversion(self) -> str: ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

class GregorianCalendar(Calendar):
    BC: _py_ClassVar[int] = ...
    AD: _py_ClassVar[int] = ...
    @overload
    def __init__(self, timeZone: TimeZone, locale: Locale): ...
    @overload
    def __init__(self, locale: Locale): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @overload
    def __init__(self, timeZone: TimeZone): ...
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int): ...
    def add(self, int: int, int2: int) -> None: ...
    def clone(self) -> _py_Any: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getActualMaximum(self, int: int) -> int: ...
    def getActualMinimum(self, int: int) -> int: ...
    def getCalendarType(self) -> str: ...
    def getGreatestMinimum(self, int: int) -> int: ...
    def getGregorianChange(self) -> Date: ...
    def getLeastMaximum(self, int: int) -> int: ...
    def getMaximum(self, int: int) -> int: ...
    def getMinimum(self, int: int) -> int: ...
    def getTimeZone(self) -> TimeZone: ...
    def getWeekYear(self) -> int: ...
    def getWeeksInWeekYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isLeapYear(self, int: int) -> bool: ...
    def isWeekDateSupported(self) -> bool: ...
    @overload
    def roll(self, int: int, int2: int) -> None: ...
    @overload
    def roll(self, int: int, boolean: bool) -> None: ...
    def setGregorianChange(self, date: Date) -> None: ...
    def setTimeZone(self, timeZone: TimeZone) -> None: ...
    def setWeekDate(self, int: int, int2: int, int3: int) -> None: ...
    def toZonedDateTime(self) -> java.time.ZonedDateTime: ...

_Hashtable__K = _py_TypeVar('_Hashtable__K')  # <K>
_Hashtable__V = _py_TypeVar('_Hashtable__V')  # <V>
class Hashtable(Dictionary[_Hashtable__K, _Hashtable__V], Map[_Hashtable__K, _Hashtable__V], java.lang.Cloneable, java.io.Serializable, _py_Generic[_Hashtable__K, _Hashtable__V]):
    @overload
    def __init__(self, map: Map[_Hashtable__K, _Hashtable__V]): ...
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, float: float): ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def compute(self, k: _Hashtable__K, biFunction: java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V]) -> _Hashtable__V: ...
    def computeIfAbsent(self, k: _Hashtable__K, function: java.util.function.Function[_Hashtable__K, _Hashtable__V]) -> _Hashtable__V: ...
    def computeIfPresent(self, k: _Hashtable__K, biFunction: java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V]) -> _Hashtable__V: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def elements(self) -> Enumeration[_Hashtable__V]: ...
    def entrySet(self) -> 'Set'['Map.Entry'[_Hashtable__K, _Hashtable__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_Hashtable__K, _Hashtable__V]) -> None: ...
    def get(self, object: _py_Any) -> _Hashtable__V: ...
    def getOrDefault(self, object: _py_Any, v: _Hashtable__V) -> _Hashtable__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'Set'[_Hashtable__K]: ...
    def keys(self) -> Enumeration[_Hashtable__K]: ...
    def merge(self, k: _Hashtable__K, v: _Hashtable__V, biFunction: java.util.function.BiFunction[_Hashtable__V, _Hashtable__V, _Hashtable__V]) -> _Hashtable__V: ...
    def put(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    def putAll(self, map: Map[_Hashtable__K, _Hashtable__V]) -> None: ...
    def putIfAbsent(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def remove(self, object: _py_Any) -> _Hashtable__V: ...
    @overload
    def replace(self, k: _Hashtable__K, v: _Hashtable__V, v2: _Hashtable__V) -> bool: ...
    @overload
    def replace(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V]) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def values(self) -> Collection[_Hashtable__V]: ...

class IllegalFormatCodePointException(IllegalFormatException):
    def __init__(self, int: int): ...
    def getCodePoint(self) -> int: ...
    def getMessage(self) -> str: ...

class IllegalFormatConversionException(IllegalFormatException):
    def __init__(self, char: str, class_: _py_Type[_py_Any]): ...
    def getArgumentClass(self) -> _py_Type[_py_Any]: ...
    def getConversion(self) -> str: ...
    def getMessage(self) -> str: ...

class IllegalFormatFlagsException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

class IllegalFormatPrecisionException(IllegalFormatException):
    def __init__(self, int: int): ...
    def getMessage(self) -> str: ...
    def getPrecision(self) -> int: ...

class IllegalFormatWidthException(IllegalFormatException):
    def __init__(self, int: int): ...
    def getMessage(self) -> str: ...
    def getWidth(self) -> int: ...

class InputMismatchException(NoSuchElementException):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str): ...

class JapaneseImperialCalendar(Calendar):
    BEFORE_MEIJI: _py_ClassVar[int] = ...
    MEIJI: _py_ClassVar[int] = ...
    TAISHO: _py_ClassVar[int] = ...
    SHOWA: _py_ClassVar[int] = ...
    HEISEI: _py_ClassVar[int] = ...
    def add(self, int: int, int2: int) -> None: ...
    def clone(self) -> _py_Any: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getActualMaximum(self, int: int) -> int: ...
    def getActualMinimum(self, int: int) -> int: ...
    def getCalendarType(self) -> str: ...
    def getDisplayName(self, int: int, int2: int, locale: Locale) -> str: ...
    def getDisplayNames(self, int: int, int2: int, locale: Locale) -> Map[str, int]: ...
    def getGreatestMinimum(self, int: int) -> int: ...
    def getLeastMaximum(self, int: int) -> int: ...
    def getMaximum(self, int: int) -> int: ...
    def getMinimum(self, int: int) -> int: ...
    def getTimeZone(self) -> TimeZone: ...
    def hashCode(self) -> int: ...
    @overload
    def roll(self, int: int, int2: int) -> None: ...
    @overload
    def roll(self, int: int, boolean: bool) -> None: ...
    def setTimeZone(self, timeZone: TimeZone) -> None: ...

_List__E = _py_TypeVar('_List__E')  # <E>
class List(Collection[_List__E], _py_Generic[_List__E], _py_List[_List__E]):
    @overload
    def add(self, e: _List__E) -> bool: ...
    @overload
    def add(self, int: int, e: _List__E) -> None: ...
    @overload
    def addAll(self, collection: Collection[_List__E]) -> bool: ...
    @overload
    def addAll(self, int: int, collection: Collection[_List__E]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def equals(self, object: _py_Any) -> bool: ...
    def get(self, int: int) -> _List__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, object: _py_Any) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_List__E]: ...
    def lastIndexOf(self, object: _py_Any) -> int: ...
    @overload
    def listIterator(self, int: int) -> 'ListIterator'[_List__E]: ...
    @overload
    def listIterator(self) -> 'ListIterator'[_List__E]: ...
    @overload
    def remove(self, int: int) -> _List__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def replaceAll(self, unaryOperator: java.util.function.UnaryOperator[_List__E]) -> None: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def set(self, int: int, e: _List__E) -> _List__E: ...
    def size(self) -> int: ...
    def sort(self, comparator: Comparator[_List__E]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_List__E]: ...
    def subList(self, int: int, int2: int) -> 'List'[_List__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...

_ListIterator__E = _py_TypeVar('_ListIterator__E')  # <E>
class ListIterator(Iterator[_ListIterator__E], _py_Generic[_ListIterator__E]):
    def add(self, e: _ListIterator__E) -> None: ...
    def hasNext(self) -> bool: ...
    def hasPrevious(self) -> bool: ...
    def next(self) -> _ListIterator__E: ...
    def nextIndex(self) -> int: ...
    def previous(self) -> _ListIterator__E: ...
    def previousIndex(self) -> int: ...
    def remove(self) -> None: ...
    def set(self, e: _ListIterator__E) -> None: ...

class ListResourceBundle(ResourceBundle):
    def __init__(self): ...
    def getKeys(self) -> Enumeration[str]: ...
    def handleGetObject(self, string: str) -> _py_Any: ...

class MissingFormatArgumentException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFormatSpecifier(self) -> str: ...
    def getMessage(self) -> str: ...

class MissingFormatWidthException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFormatSpecifier(self) -> str: ...
    def getMessage(self) -> str: ...

class PropertyResourceBundle(ResourceBundle):
    @overload
    def __init__(self, reader: java.io.Reader): ...
    @overload
    def __init__(self, inputStream: java.io.InputStream): ...
    def getKeys(self) -> Enumeration[str]: ...
    def handleGetObject(self, string: str) -> _py_Any: ...

_Queue__E = _py_TypeVar('_Queue__E')  # <E>
class Queue(Collection[_Queue__E], _py_Generic[_Queue__E]):
    def add(self, e: _Queue__E) -> bool: ...
    def element(self) -> _Queue__E: ...
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def offer(self, e: _Queue__E) -> bool: ...
    def peek(self) -> _Queue__E: ...
    def poll(self) -> _Queue__E: ...
    @overload
    def remove(self) -> _Queue__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...

class Scanner(Iterator[str], java.io.Closeable):
    @overload
    def __init__(self, file: java.io.File, string: str): ...
    @overload
    def __init__(self, file: java.io.File): ...
    @overload
    def __init__(self, path: java.nio.file.Path, string: str): ...
    @overload
    def __init__(self, path: java.nio.file.Path): ...
    @overload
    def __init__(self, readableByteChannel: java.nio.channels.ReadableByteChannel, string: str): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, readableByteChannel: java.nio.channels.ReadableByteChannel): ...
    @overload
    def __init__(self, readable: java.lang.Readable): ...
    @overload
    def __init__(self, inputStream: java.io.InputStream): ...
    @overload
    def __init__(self, inputStream: java.io.InputStream, string: str): ...
    def close(self) -> None: ...
    def delimiter(self) -> java.util.regex.Pattern: ...
    @overload
    def findInLine(self, string: str) -> str: ...
    @overload
    def findInLine(self, pattern: java.util.regex.Pattern) -> str: ...
    @overload
    def findWithinHorizon(self, string: str, int: int) -> str: ...
    @overload
    def findWithinHorizon(self, pattern: java.util.regex.Pattern, int: int) -> str: ...
    @overload
    def hasNext(self, pattern: java.util.regex.Pattern) -> bool: ...
    @overload
    def hasNext(self) -> bool: ...
    @overload
    def hasNext(self, string: str) -> bool: ...
    def hasNextBigDecimal(self) -> bool: ...
    @overload
    def hasNextBigInteger(self) -> bool: ...
    @overload
    def hasNextBigInteger(self, int: int) -> bool: ...
    def hasNextBoolean(self) -> bool: ...
    @overload
    def hasNextByte(self, int: int) -> bool: ...
    @overload
    def hasNextByte(self) -> bool: ...
    def hasNextDouble(self) -> bool: ...
    def hasNextFloat(self) -> bool: ...
    @overload
    def hasNextInt(self, int: int) -> bool: ...
    @overload
    def hasNextInt(self) -> bool: ...
    def hasNextLine(self) -> bool: ...
    @overload
    def hasNextLong(self, int: int) -> bool: ...
    @overload
    def hasNextLong(self) -> bool: ...
    @overload
    def hasNextShort(self) -> bool: ...
    @overload
    def hasNextShort(self, int: int) -> bool: ...
    def ioException(self) -> java.io.IOException: ...
    def locale(self) -> Locale: ...
    def match(self) -> java.util.regex.MatchResult: ...
    @overload
    def next(self) -> _py_Any: ...
    @overload
    def next(self) -> str: ...
    @overload
    def next(self, pattern: java.util.regex.Pattern) -> str: ...
    @overload
    def next(self, string: str) -> str: ...
    def nextBigDecimal(self) -> java.math.BigDecimal: ...
    @overload
    def nextBigInteger(self, int: int) -> java.math.BigInteger: ...
    @overload
    def nextBigInteger(self) -> java.math.BigInteger: ...
    def nextBoolean(self) -> bool: ...
    @overload
    def nextByte(self) -> int: ...
    @overload
    def nextByte(self, int: int) -> int: ...
    def nextDouble(self) -> float: ...
    def nextFloat(self) -> float: ...
    @overload
    def nextInt(self) -> int: ...
    @overload
    def nextInt(self, int: int) -> int: ...
    def nextLine(self) -> str: ...
    @overload
    def nextLong(self) -> int: ...
    @overload
    def nextLong(self, int: int) -> int: ...
    @overload
    def nextShort(self, int: int) -> int: ...
    @overload
    def nextShort(self) -> int: ...
    def radix(self) -> int: ...
    def remove(self) -> None: ...
    def reset(self) -> 'Scanner': ...
    @overload
    def skip(self, string: str) -> 'Scanner': ...
    @overload
    def skip(self, pattern: java.util.regex.Pattern) -> 'Scanner': ...
    def toString(self) -> str: ...
    @overload
    def useDelimiter(self, string: str) -> 'Scanner': ...
    @overload
    def useDelimiter(self, pattern: java.util.regex.Pattern) -> 'Scanner': ...
    def useLocale(self, locale: Locale) -> 'Scanner': ...
    def useRadix(self, int: int) -> 'Scanner': ...

_Set__E = _py_TypeVar('_Set__E')  # <E>
class Set(Collection[_Set__E], _py_Generic[_Set__E], _py_Set[_Set__E]):
    def add(self, e: _Set__E) -> bool: ...
    def addAll(self, collection: Collection[_Set__E]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_Set__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_Set__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...

class SimpleTimeZone(TimeZone):
    WALL_TIME: _py_ClassVar[int] = ...
    STANDARD_TIME: _py_ClassVar[int] = ...
    UTC_TIME: _py_ClassVar[int] = ...
    @overload
    def __init__(self, int: int, string: str, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int): ...
    @overload
    def __init__(self, int: int, string: str): ...
    @overload
    def __init__(self, int: int, string: str, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int, int10: int): ...
    @overload
    def __init__(self, int: int, string: str, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int, int10: int, int11: int, int12: int): ...
    def clone(self) -> _py_Any: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getDSTSavings(self) -> int: ...
    @overload
    def getOffset(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    @overload
    def getOffset(self, long: int) -> int: ...
    def getRawOffset(self) -> int: ...
    def hasSameRules(self, timeZone: TimeZone) -> bool: ...
    def hashCode(self) -> int: ...
    def inDaylightTime(self, date: Date) -> bool: ...
    def observesDaylightTime(self) -> bool: ...
    def setDSTSavings(self, int: int) -> None: ...
    @overload
    def setEndRule(self, int: int, int2: int, int3: int, int4: int) -> None: ...
    @overload
    def setEndRule(self, int: int, int2: int, int3: int, int4: int, boolean: bool) -> None: ...
    @overload
    def setEndRule(self, int: int, int2: int, int3: int) -> None: ...
    def setRawOffset(self, int: int) -> None: ...
    @overload
    def setStartRule(self, int: int, int2: int, int3: int) -> None: ...
    @overload
    def setStartRule(self, int: int, int2: int, int3: int, int4: int) -> None: ...
    @overload
    def setStartRule(self, int: int, int2: int, int3: int, int4: int, boolean: bool) -> None: ...
    def setStartYear(self, int: int) -> None: ...
    def toString(self) -> str: ...
    def useDaylightTime(self) -> bool: ...

_SortedMap__K = _py_TypeVar('_SortedMap__K')  # <K>
_SortedMap__V = _py_TypeVar('_SortedMap__V')  # <V>
class SortedMap(Map[_SortedMap__K, _SortedMap__V], _py_Generic[_SortedMap__K, _SortedMap__V]):
    def comparator(self) -> Comparator[_SortedMap__K]: ...
    def entrySet(self) -> Set['Map.Entry'[_SortedMap__K, _SortedMap__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def firstKey(self) -> _SortedMap__K: ...
    def hashCode(self) -> int: ...
    def headMap(self, k: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def keySet(self) -> Set[_SortedMap__K]: ...
    def lastKey(self) -> _SortedMap__K: ...
    def subMap(self, k: _SortedMap__K, k2: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def tailMap(self, k: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def values(self) -> Collection[_SortedMap__V]: ...

class StringTokenizer(Enumeration[_py_Any]):
    @overload
    def __init__(self, string: str, string2: str): ...
    @overload
    def __init__(self, string: str, string2: str, boolean: bool): ...
    @overload
    def __init__(self, string: str): ...
    def countTokens(self) -> int: ...
    def hasMoreElements(self) -> bool: ...
    def hasMoreTokens(self) -> bool: ...
    def nextElement(self) -> _py_Any: ...
    @overload
    def nextToken(self, string: str) -> str: ...
    @overload
    def nextToken(self) -> str: ...

class UnknownFormatConversionException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getConversion(self) -> str: ...
    def getMessage(self) -> str: ...

class UnknownFormatFlagsException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

_AbstractList__E = _py_TypeVar('_AbstractList__E')  # <E>
class AbstractList(AbstractCollection[_AbstractList__E], List[_AbstractList__E], _py_Generic[_AbstractList__E]):
    @overload
    def add(self, int: int, e: _AbstractList__E) -> None: ...
    @overload
    def add(self, e: _AbstractList__E) -> bool: ...
    @overload
    def addAll(self, int: int, collection: Collection[_AbstractList__E]) -> bool: ...
    @overload
    def addAll(self, collection: Collection[_AbstractList__E]) -> bool: ...
    def clear(self) -> None: ...
    def equals(self, object: _py_Any) -> bool: ...
    def get(self, int: int) -> _AbstractList__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, object: _py_Any) -> int: ...
    def iterator(self) -> Iterator[_AbstractList__E]: ...
    def lastIndexOf(self, object: _py_Any) -> int: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_AbstractList__E]: ...
    @overload
    def listIterator(self) -> ListIterator[_AbstractList__E]: ...
    @overload
    def remove(self, int: int) -> _AbstractList__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    def set(self, int: int, e: _AbstractList__E) -> _AbstractList__E: ...
    def subList(self, int: int, int2: int) -> List[_AbstractList__E]: ...

_AbstractQueue__E = _py_TypeVar('_AbstractQueue__E')  # <E>
class AbstractQueue(AbstractCollection[_AbstractQueue__E], Queue[_AbstractQueue__E], _py_Generic[_AbstractQueue__E]):
    def add(self, e: _AbstractQueue__E) -> bool: ...
    def addAll(self, collection: Collection[_AbstractQueue__E]) -> bool: ...
    def clear(self) -> None: ...
    def element(self) -> _AbstractQueue__E: ...
    @overload
    def remove(self) -> _AbstractQueue__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...

_AbstractSet__E = _py_TypeVar('_AbstractSet__E')  # <E>
class AbstractSet(AbstractCollection[_AbstractSet__E], Set[_AbstractSet__E], _py_Generic[_AbstractSet__E]):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...

_Deque__E = _py_TypeVar('_Deque__E')  # <E>
class Deque(Queue[_Deque__E], _py_Generic[_Deque__E]):
    def add(self, e: _Deque__E) -> bool: ...
    def addFirst(self, e: _Deque__E) -> None: ...
    def addLast(self, e: _Deque__E) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_Deque__E]: ...
    def element(self) -> _Deque__E: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getFirst(self) -> _Deque__E: ...
    def getLast(self) -> _Deque__E: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> Iterator[_Deque__E]: ...
    def offer(self, e: _Deque__E) -> bool: ...
    def offerFirst(self, e: _Deque__E) -> bool: ...
    def offerLast(self, e: _Deque__E) -> bool: ...
    def peek(self) -> _Deque__E: ...
    def peekFirst(self) -> _Deque__E: ...
    def peekLast(self) -> _Deque__E: ...
    def poll(self) -> _Deque__E: ...
    def pollFirst(self) -> _Deque__E: ...
    def pollLast(self) -> _Deque__E: ...
    def pop(self) -> _Deque__E: ...
    def push(self, e: _Deque__E) -> None: ...
    @overload
    def remove(self) -> _Deque__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    def removeFirst(self) -> _Deque__E: ...
    def removeFirstOccurrence(self, object: _py_Any) -> bool: ...
    def removeLast(self) -> _Deque__E: ...
    def removeLastOccurrence(self, object: _py_Any) -> bool: ...
    def size(self) -> int: ...

_NavigableMap__K = _py_TypeVar('_NavigableMap__K')  # <K>
_NavigableMap__V = _py_TypeVar('_NavigableMap__V')  # <V>
class NavigableMap(SortedMap[_NavigableMap__K, _NavigableMap__V], _py_Generic[_NavigableMap__K, _NavigableMap__V]):
    def ceilingEntry(self, k: _NavigableMap__K) -> 'Map.Entry'[_NavigableMap__K, _NavigableMap__V]: ...
    def ceilingKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def descendingKeySet(self) -> 'NavigableSet'[_NavigableMap__K]: ...
    def descendingMap(self) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def firstEntry(self) -> 'Map.Entry'[_NavigableMap__K, _NavigableMap__V]: ...
    def floorEntry(self, k: _NavigableMap__K) -> 'Map.Entry'[_NavigableMap__K, _NavigableMap__V]: ...
    def floorKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def hashCode(self) -> int: ...
    @overload
    def headMap(self, k: _NavigableMap__K, boolean: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @overload
    def headMap(self, k: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...
    def higherEntry(self, k: _NavigableMap__K) -> 'Map.Entry'[_NavigableMap__K, _NavigableMap__V]: ...
    def higherKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def lastEntry(self) -> 'Map.Entry'[_NavigableMap__K, _NavigableMap__V]: ...
    def lowerEntry(self, k: _NavigableMap__K) -> 'Map.Entry'[_NavigableMap__K, _NavigableMap__V]: ...
    def lowerKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def navigableKeySet(self) -> 'NavigableSet'[_NavigableMap__K]: ...
    def pollFirstEntry(self) -> 'Map.Entry'[_NavigableMap__K, _NavigableMap__V]: ...
    def pollLastEntry(self) -> 'Map.Entry'[_NavigableMap__K, _NavigableMap__V]: ...
    @overload
    def subMap(self, k: _NavigableMap__K, k2: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...
    @overload
    def subMap(self, k: _NavigableMap__K, boolean: bool, k2: _NavigableMap__K, boolean2: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @overload
    def tailMap(self, k: _NavigableMap__K, boolean: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @overload
    def tailMap(self, k: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...

class Properties(Hashtable[_py_Any, _py_Any]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, properties: 'Properties'): ...
    @overload
    def getProperty(self, string: str) -> str: ...
    @overload
    def getProperty(self, string: str, string2: str) -> str: ...
    @overload
    def list(self, printStream: java.io.PrintStream) -> None: ...
    @overload
    def list(self, printWriter: java.io.PrintWriter) -> None: ...
    @overload
    def load(self, reader: java.io.Reader) -> None: ...
    @overload
    def load(self, inputStream: java.io.InputStream) -> None: ...
    def loadFromXML(self, inputStream: java.io.InputStream) -> None: ...
    def propertyNames(self) -> Enumeration[_py_Any]: ...
    def save(self, outputStream: java.io.OutputStream, string: str) -> None: ...
    def setProperty(self, string: str, string2: str) -> _py_Any: ...
    @overload
    def store(self, writer: java.io.Writer, string: str) -> None: ...
    @overload
    def store(self, outputStream: java.io.OutputStream, string: str) -> None: ...
    @overload
    def storeToXML(self, outputStream: java.io.OutputStream, string: str) -> None: ...
    @overload
    def storeToXML(self, outputStream: java.io.OutputStream, string: str, string2: str) -> None: ...
    def stringPropertyNames(self) -> Set[str]: ...

_SortedSet__E = _py_TypeVar('_SortedSet__E')  # <E>
class SortedSet(Set[_SortedSet__E], _py_Generic[_SortedSet__E]):
    def comparator(self) -> Comparator[_SortedSet__E]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def first(self) -> _SortedSet__E: ...
    def hashCode(self) -> int: ...
    def headSet(self, e: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...
    def last(self) -> _SortedSet__E: ...
    def spliterator(self) -> 'Spliterator'[_SortedSet__E]: ...
    def subSet(self, e: _SortedSet__E, e2: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...
    def tailSet(self, e: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...

_AbstractSequentialList__E = _py_TypeVar('_AbstractSequentialList__E')  # <E>
class AbstractSequentialList(AbstractList[_AbstractSequentialList__E], _py_Generic[_AbstractSequentialList__E]):
    @overload
    def add(self, int: int, e: _AbstractSequentialList__E) -> None: ...
    @overload
    def add(self, e: _AbstractSequentialList__E) -> bool: ...
    @overload
    def addAll(self, int: int, collection: Collection[_AbstractSequentialList__E]) -> bool: ...
    @overload
    def addAll(self, collection: Collection[_AbstractSequentialList__E]) -> bool: ...
    def get(self, int: int) -> _AbstractSequentialList__E: ...
    def iterator(self) -> Iterator[_AbstractSequentialList__E]: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_AbstractSequentialList__E]: ...
    @overload
    def listIterator(self) -> ListIterator[_AbstractSequentialList__E]: ...
    @overload
    def remove(self, int: int) -> _AbstractSequentialList__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    def set(self, int: int, e: _AbstractSequentialList__E) -> _AbstractSequentialList__E: ...

_ArrayDeque__E = _py_TypeVar('_ArrayDeque__E')  # <E>
class ArrayDeque(AbstractCollection[_ArrayDeque__E], Deque[_ArrayDeque__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_ArrayDeque__E]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, collection: Collection[_ArrayDeque__E]): ...
    def add(self, e: _ArrayDeque__E) -> bool: ...
    def addFirst(self, e: _ArrayDeque__E) -> None: ...
    def addLast(self, e: _ArrayDeque__E) -> None: ...
    def clear(self) -> None: ...
    @overload
    def clone(self) -> 'ArrayDeque'[_ArrayDeque__E]: ...
    @overload
    def clone(self) -> _py_Any: ...
    def contains(self, object: _py_Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_ArrayDeque__E]: ...
    def element(self) -> _ArrayDeque__E: ...
    def getFirst(self) -> _ArrayDeque__E: ...
    def getLast(self) -> _ArrayDeque__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_ArrayDeque__E]: ...
    def offer(self, e: _ArrayDeque__E) -> bool: ...
    def offerFirst(self, e: _ArrayDeque__E) -> bool: ...
    def offerLast(self, e: _ArrayDeque__E) -> bool: ...
    def peek(self) -> _ArrayDeque__E: ...
    def peekFirst(self) -> _ArrayDeque__E: ...
    def peekLast(self) -> _ArrayDeque__E: ...
    def poll(self) -> _ArrayDeque__E: ...
    def pollFirst(self) -> _ArrayDeque__E: ...
    def pollLast(self) -> _ArrayDeque__E: ...
    def pop(self) -> _ArrayDeque__E: ...
    def push(self, e: _ArrayDeque__E) -> None: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self) -> _ArrayDeque__E: ...
    def removeFirst(self) -> _ArrayDeque__E: ...
    def removeFirstOccurrence(self, object: _py_Any) -> bool: ...
    def removeLast(self) -> _ArrayDeque__E: ...
    def removeLastOccurrence(self, object: _py_Any) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_ArrayDeque__E]: ...
    _toArray_0__T = _py_TypeVar('_toArray_0__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_0__T]) -> _py_List[_toArray_0__T]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...

_ArrayList__E = _py_TypeVar('_ArrayList__E')  # <E>
class ArrayList(AbstractList[_ArrayList__E], List[_ArrayList__E], RandomAccess, java.lang.Cloneable, java.io.Serializable, _py_Generic[_ArrayList__E]):
    @overload
    def __init__(self, collection: Collection[_ArrayList__E]): ...
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def add(self, int: int, e: _ArrayList__E) -> None: ...
    @overload
    def add(self, e: _ArrayList__E) -> bool: ...
    @overload
    def addAll(self, int: int, collection: Collection[_ArrayList__E]) -> bool: ...
    @overload
    def addAll(self, collection: Collection[_ArrayList__E]) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def contains(self, object: _py_Any) -> bool: ...
    def ensureCapacity(self, int: int) -> None: ...
    def forEach(self, consumer: java.util.function.Consumer[_ArrayList__E]) -> None: ...
    def get(self, int: int) -> _ArrayList__E: ...
    def indexOf(self, object: _py_Any) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_ArrayList__E]: ...
    def lastIndexOf(self, object: _py_Any) -> int: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_ArrayList__E]: ...
    @overload
    def listIterator(self) -> ListIterator[_ArrayList__E]: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self, int: int) -> _ArrayList__E: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def removeIf(self, predicate: java.util.function.Predicate[_ArrayList__E]) -> bool: ...
    def replaceAll(self, unaryOperator: java.util.function.UnaryOperator[_ArrayList__E]) -> None: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def set(self, int: int, e: _ArrayList__E) -> _ArrayList__E: ...
    def size(self) -> int: ...
    def sort(self, comparator: Comparator[_ArrayList__E]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_ArrayList__E]: ...
    def subList(self, int: int, int2: int) -> List[_ArrayList__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...
    def trimToSize(self) -> None: ...

_EnumSet__E = _py_TypeVar('_EnumSet__E', bound=java.lang.Enum)  # <E>
class EnumSet(AbstractSet[_EnumSet__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_EnumSet__E]):
    _allOf__E = _py_TypeVar('_allOf__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def allOf(cls, class_: _py_Type[_allOf__E]) -> 'EnumSet'[_allOf__E]: ...
    @overload
    def clone(self) -> _py_Any: ...
    @overload
    def clone(self) -> 'EnumSet'[_EnumSet__E]: ...
    _complementOf__E = _py_TypeVar('_complementOf__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def complementOf(cls, enumSet: 'EnumSet'[_complementOf__E]) -> 'EnumSet'[_complementOf__E]: ...
    _copyOf_0__E = _py_TypeVar('_copyOf_0__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def copyOf(cls, collection: Collection[_copyOf_0__E]) -> 'EnumSet'[_copyOf_0__E]: ...
    _copyOf_1__E = _py_TypeVar('_copyOf_1__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def copyOf(cls, enumSet: 'EnumSet'[_copyOf_1__E]) -> 'EnumSet'[_copyOf_1__E]: ...
    _noneOf__E = _py_TypeVar('_noneOf__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def noneOf(cls, class_: _py_Type[_noneOf__E]) -> 'EnumSet'[_noneOf__E]: ...
    _of_0__E = _py_TypeVar('_of_0__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_0__E, eArray: _py_List[_of_0__E]) -> 'EnumSet'[_of_0__E]: ...
    _of_1__E = _py_TypeVar('_of_1__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_1__E) -> 'EnumSet'[_of_1__E]: ...
    _of_2__E = _py_TypeVar('_of_2__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_2__E, e2: _of_2__E, e3: _of_2__E) -> 'EnumSet'[_of_2__E]: ...
    _of_3__E = _py_TypeVar('_of_3__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_3__E, e2: _of_3__E, e3: _of_3__E, e4: _of_3__E) -> 'EnumSet'[_of_3__E]: ...
    _of_4__E = _py_TypeVar('_of_4__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_4__E, e2: _of_4__E) -> 'EnumSet'[_of_4__E]: ...
    _of_5__E = _py_TypeVar('_of_5__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_5__E, e2: _of_5__E, e3: _of_5__E, e4: _of_5__E, e5: _of_5__E) -> 'EnumSet'[_of_5__E]: ...
    _range__E = _py_TypeVar('_range__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def range(cls, e: _range__E, e2: _range__E) -> 'EnumSet'[_range__E]: ...

_HashSet__E = _py_TypeVar('_HashSet__E')  # <E>
class HashSet(AbstractSet[_HashSet__E], Set[_HashSet__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_HashSet__E]):
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, float: float): ...
    @overload
    def __init__(self, collection: Collection[_HashSet__E]): ...
    @overload
    def __init__(self): ...
    def add(self, e: _HashSet__E) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def contains(self, object: _py_Any) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_HashSet__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_HashSet__E]: ...

_NavigableSet__E = _py_TypeVar('_NavigableSet__E')  # <E>
class NavigableSet(SortedSet[_NavigableSet__E], _py_Generic[_NavigableSet__E]):
    def ceiling(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def descendingIterator(self) -> Iterator[_NavigableSet__E]: ...
    def descendingSet(self) -> 'NavigableSet'[_NavigableSet__E]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def floor(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def hashCode(self) -> int: ...
    @overload
    def headSet(self, e: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...
    @overload
    def headSet(self, e: _NavigableSet__E, boolean: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    def higher(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def iterator(self) -> Iterator[_NavigableSet__E]: ...
    def lower(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def pollFirst(self) -> _NavigableSet__E: ...
    def pollLast(self) -> _NavigableSet__E: ...
    @overload
    def subSet(self, e: _NavigableSet__E, boolean: bool, e2: _NavigableSet__E, boolean2: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    @overload
    def subSet(self, e: _NavigableSet__E, e2: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...
    @overload
    def tailSet(self, e: _NavigableSet__E, boolean: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    @overload
    def tailSet(self, e: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...

_PriorityQueue__E = _py_TypeVar('_PriorityQueue__E')  # <E>
class PriorityQueue(AbstractQueue[_PriorityQueue__E], java.io.Serializable, _py_Generic[_PriorityQueue__E]):
    @overload
    def __init__(self, comparator: Comparator[_PriorityQueue__E]): ...
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, collection: Collection[_PriorityQueue__E]): ...
    @overload
    def __init__(self, int: int, comparator: Comparator[_PriorityQueue__E]): ...
    @overload
    def __init__(self, priorityQueue: 'PriorityQueue'[_PriorityQueue__E]): ...
    @overload
    def __init__(self, sortedSet: SortedSet[_PriorityQueue__E]): ...
    def add(self, e: _PriorityQueue__E) -> bool: ...
    def clear(self) -> None: ...
    def comparator(self) -> Comparator[_PriorityQueue__E]: ...
    def contains(self, object: _py_Any) -> bool: ...
    def iterator(self) -> Iterator[_PriorityQueue__E]: ...
    def offer(self, e: _PriorityQueue__E) -> bool: ...
    def peek(self) -> _PriorityQueue__E: ...
    def poll(self) -> _PriorityQueue__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self) -> _PriorityQueue__E: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_PriorityQueue__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...

_SubList__E = _py_TypeVar('_SubList__E')  # <E>
class SubList(AbstractList[_SubList__E], _py_Generic[_SubList__E]):
    @overload
    def add(self, int: int, e: _SubList__E) -> None: ...
    @overload
    def add(self, e: _SubList__E) -> bool: ...
    @overload
    def addAll(self, int: int, collection: Collection[_SubList__E]) -> bool: ...
    @overload
    def addAll(self, collection: Collection[_SubList__E]) -> bool: ...
    def get(self, int: int) -> _SubList__E: ...
    def iterator(self) -> Iterator[_SubList__E]: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_SubList__E]: ...
    @overload
    def listIterator(self) -> ListIterator[_SubList__E]: ...
    @overload
    def remove(self, int: int) -> _SubList__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    def set(self, int: int, e: _SubList__E) -> _SubList__E: ...
    def size(self) -> int: ...
    def subList(self, int: int, int2: int) -> List[_SubList__E]: ...

_Vector__E = _py_TypeVar('_Vector__E')  # <E>
class Vector(AbstractList[_Vector__E], List[_Vector__E], RandomAccess, java.lang.Cloneable, java.io.Serializable, _py_Generic[_Vector__E]):
    @overload
    def __init__(self, collection: Collection[_Vector__E]): ...
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, int2: int): ...
    @overload
    def add(self, e: _Vector__E) -> bool: ...
    @overload
    def add(self, int: int, e: _Vector__E) -> None: ...
    @overload
    def addAll(self, collection: Collection[_Vector__E]) -> bool: ...
    @overload
    def addAll(self, int: int, collection: Collection[_Vector__E]) -> bool: ...
    def addElement(self, e: _Vector__E) -> None: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def copyInto(self, objectArray: _py_List[_py_Any]) -> None: ...
    def elementAt(self, int: int) -> _Vector__E: ...
    def elements(self) -> Enumeration[_Vector__E]: ...
    def ensureCapacity(self, int: int) -> None: ...
    def equals(self, object: _py_Any) -> bool: ...
    def firstElement(self) -> _Vector__E: ...
    def forEach(self, consumer: java.util.function.Consumer[_Vector__E]) -> None: ...
    def get(self, int: int) -> _Vector__E: ...
    def hashCode(self) -> int: ...
    @overload
    def indexOf(self, object: _py_Any, int: int) -> int: ...
    @overload
    def indexOf(self, object: _py_Any) -> int: ...
    def insertElementAt(self, e: _Vector__E, int: int) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_Vector__E]: ...
    def lastElement(self) -> _Vector__E: ...
    @overload
    def lastIndexOf(self, object: _py_Any, int: int) -> int: ...
    @overload
    def lastIndexOf(self, object: _py_Any) -> int: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_Vector__E]: ...
    @overload
    def listIterator(self) -> ListIterator[_Vector__E]: ...
    @overload
    def remove(self, int: int) -> _Vector__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def removeAllElements(self) -> None: ...
    def removeElement(self, object: _py_Any) -> bool: ...
    def removeElementAt(self, int: int) -> None: ...
    def removeIf(self, predicate: java.util.function.Predicate[_Vector__E]) -> bool: ...
    def replaceAll(self, unaryOperator: java.util.function.UnaryOperator[_Vector__E]) -> None: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def set(self, int: int, e: _Vector__E) -> _Vector__E: ...
    def setElementAt(self, e: _Vector__E, int: int) -> None: ...
    def setSize(self, int: int) -> None: ...
    def size(self) -> int: ...
    def sort(self, comparator: Comparator[_Vector__E]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_Vector__E]: ...
    def subList(self, int: int, int2: int) -> List[_Vector__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...
    def toString(self) -> str: ...
    def trimToSize(self) -> None: ...

_JumboEnumSet__E = _py_TypeVar('_JumboEnumSet__E', bound=java.lang.Enum)  # <E>
class JumboEnumSet(EnumSet[_JumboEnumSet__E], _py_Generic[_JumboEnumSet__E]):
    @overload
    def add(self, object: _py_Any) -> bool: ...
    @overload
    def add(self, e: _JumboEnumSet__E) -> bool: ...
    def addAll(self, collection: Collection[_JumboEnumSet__E]) -> bool: ...
    def clear(self) -> None: ...
    @overload
    def clone(self) -> EnumSet[_JumboEnumSet__E]: ...
    @overload
    def clone(self) -> _py_Any: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def equals(self, object: _py_Any) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_JumboEnumSet__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def size(self) -> int: ...

_LinkedHashSet__E = _py_TypeVar('_LinkedHashSet__E')  # <E>
class LinkedHashSet(HashSet[_LinkedHashSet__E], Set[_LinkedHashSet__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_LinkedHashSet__E]):
    @overload
    def __init__(self, collection: Collection[_LinkedHashSet__E]): ...
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, float: float): ...
    def spliterator(self) -> 'Spliterator'[_LinkedHashSet__E]: ...

_LinkedList__E = _py_TypeVar('_LinkedList__E')  # <E>
class LinkedList(AbstractSequentialList[_LinkedList__E], List[_LinkedList__E], Deque[_LinkedList__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_LinkedList__E]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, collection: Collection[_LinkedList__E]): ...
    @overload
    def add(self, e: _LinkedList__E) -> bool: ...
    @overload
    def add(self, int: int, e: _LinkedList__E) -> None: ...
    @overload
    def addAll(self, collection: Collection[_LinkedList__E]) -> bool: ...
    @overload
    def addAll(self, int: int, collection: Collection[_LinkedList__E]) -> bool: ...
    def addFirst(self, e: _LinkedList__E) -> None: ...
    def addLast(self, e: _LinkedList__E) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def contains(self, object: _py_Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_LinkedList__E]: ...
    def element(self) -> _LinkedList__E: ...
    def get(self, int: int) -> _LinkedList__E: ...
    def getFirst(self) -> _LinkedList__E: ...
    def getLast(self) -> _LinkedList__E: ...
    def indexOf(self, object: _py_Any) -> int: ...
    def lastIndexOf(self, object: _py_Any) -> int: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_LinkedList__E]: ...
    @overload
    def listIterator(self) -> ListIterator[_LinkedList__E]: ...
    def offer(self, e: _LinkedList__E) -> bool: ...
    def offerFirst(self, e: _LinkedList__E) -> bool: ...
    def offerLast(self, e: _LinkedList__E) -> bool: ...
    def peek(self) -> _LinkedList__E: ...
    def peekFirst(self) -> _LinkedList__E: ...
    def peekLast(self) -> _LinkedList__E: ...
    def poll(self) -> _LinkedList__E: ...
    def pollFirst(self) -> _LinkedList__E: ...
    def pollLast(self) -> _LinkedList__E: ...
    def pop(self) -> _LinkedList__E: ...
    def push(self, e: _LinkedList__E) -> None: ...
    @overload
    def remove(self) -> _LinkedList__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self, int: int) -> _LinkedList__E: ...
    def removeFirst(self) -> _LinkedList__E: ...
    def removeFirstOccurrence(self, object: _py_Any) -> bool: ...
    def removeLast(self) -> _LinkedList__E: ...
    def removeLastOccurrence(self, object: _py_Any) -> bool: ...
    def set(self, int: int, e: _LinkedList__E) -> _LinkedList__E: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_LinkedList__E]: ...
    _toArray_0__T = _py_TypeVar('_toArray_0__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_0__T]) -> _py_List[_toArray_0__T]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...

_RandomAccessSubList__E = _py_TypeVar('_RandomAccessSubList__E')  # <E>
class RandomAccessSubList(SubList[_RandomAccessSubList__E], RandomAccess, _py_Generic[_RandomAccessSubList__E]):
    def subList(self, int: int, int2: int) -> List[_RandomAccessSubList__E]: ...

_RegularEnumSet__E = _py_TypeVar('_RegularEnumSet__E', bound=java.lang.Enum)  # <E>
class RegularEnumSet(EnumSet[_RegularEnumSet__E], _py_Generic[_RegularEnumSet__E]):
    @overload
    def add(self, e: _RegularEnumSet__E) -> bool: ...
    @overload
    def add(self, object: _py_Any) -> bool: ...
    def addAll(self, collection: Collection[_RegularEnumSet__E]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def equals(self, object: _py_Any) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_RegularEnumSet__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def size(self) -> int: ...

_Stack__E = _py_TypeVar('_Stack__E')  # <E>
class Stack(Vector[_Stack__E], _py_Generic[_Stack__E]):
    def __init__(self): ...
    def empty(self) -> bool: ...
    def peek(self) -> _Stack__E: ...
    def pop(self) -> _Stack__E: ...
    def push(self, e: _Stack__E) -> _Stack__E: ...
    def search(self, object: _py_Any) -> int: ...

_TreeSet__E = _py_TypeVar('_TreeSet__E')  # <E>
class TreeSet(AbstractSet[_TreeSet__E], NavigableSet[_TreeSet__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_TreeSet__E]):
    @overload
    def __init__(self, sortedSet: SortedSet[_TreeSet__E]): ...
    @overload
    def __init__(self, comparator: Comparator[_TreeSet__E]): ...
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, collection: Collection[_TreeSet__E]): ...
    def add(self, e: _TreeSet__E) -> bool: ...
    def addAll(self, collection: Collection[_TreeSet__E]) -> bool: ...
    def ceiling(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def comparator(self) -> Comparator[_TreeSet__E]: ...
    def contains(self, object: _py_Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_TreeSet__E]: ...
    def descendingSet(self) -> NavigableSet[_TreeSet__E]: ...
    def first(self) -> _TreeSet__E: ...
    def floor(self, e: _TreeSet__E) -> _TreeSet__E: ...
    @overload
    def headSet(self, e: _TreeSet__E, boolean: bool) -> NavigableSet[_TreeSet__E]: ...
    @overload
    def headSet(self, e: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...
    def higher(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_TreeSet__E]: ...
    def last(self) -> _TreeSet__E: ...
    def lower(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def pollFirst(self) -> _TreeSet__E: ...
    def pollLast(self) -> _TreeSet__E: ...
    def remove(self, object: _py_Any) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_TreeSet__E]: ...
    @overload
    def subSet(self, e: _TreeSet__E, e2: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...
    @overload
    def subSet(self, e: _TreeSet__E, boolean: bool, e2: _TreeSet__E, boolean2: bool) -> NavigableSet[_TreeSet__E]: ...
    @overload
    def tailSet(self, e: _TreeSet__E, boolean: bool) -> NavigableSet[_TreeSet__E]: ...
    @overload
    def tailSet(self, e: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...

_AbstractMap__SimpleEntry__K = _py_TypeVar('_AbstractMap__SimpleEntry__K')  # <K>
_AbstractMap__SimpleEntry__V = _py_TypeVar('_AbstractMap__SimpleEntry__V')  # <V>
_AbstractMap__SimpleImmutableEntry__K = _py_TypeVar('_AbstractMap__SimpleImmutableEntry__K')  # <K>
_AbstractMap__SimpleImmutableEntry__V = _py_TypeVar('_AbstractMap__SimpleImmutableEntry__V')  # <V>
_AbstractMap__K = _py_TypeVar('_AbstractMap__K')  # <K>
_AbstractMap__V = _py_TypeVar('_AbstractMap__V')  # <V>
class AbstractMap(Map[_AbstractMap__K, _AbstractMap__V], _py_Generic[_AbstractMap__K, _AbstractMap__V]):
    def clear(self) -> None: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set['Map.Entry'[_AbstractMap__K, _AbstractMap__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def get(self, object: _py_Any) -> _AbstractMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_AbstractMap__K]: ...
    def put(self, k: _AbstractMap__K, v: _AbstractMap__V) -> _AbstractMap__V: ...
    def putAll(self, map: Map[_AbstractMap__K, _AbstractMap__V]) -> None: ...
    @overload
    def remove(self, object: _py_Any) -> _AbstractMap__V: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def values(self) -> Collection[_AbstractMap__V]: ...
    class SimpleEntry(java.util.Map.Entry[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V], java.io.Serializable, _py_Generic[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V]):
        @overload
        def __init__(self, k: _AbstractMap__SimpleEntry__K, v: _AbstractMap__SimpleEntry__V): ...
        @overload
        def __init__(self, entry: 'Map.Entry'[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V]): ...
        def equals(self, object: _py_Any) -> bool: ...
        def getKey(self) -> _AbstractMap__SimpleEntry__K: ...
        def getValue(self) -> _AbstractMap__SimpleEntry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _AbstractMap__SimpleEntry__V) -> _AbstractMap__SimpleEntry__V: ...
        def toString(self) -> str: ...
    class SimpleImmutableEntry(java.util.Map.Entry[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V], java.io.Serializable, _py_Generic[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V]):
        @overload
        def __init__(self, k: _AbstractMap__SimpleImmutableEntry__K, v: _AbstractMap__SimpleImmutableEntry__V): ...
        @overload
        def __init__(self, entry: 'Map.Entry'[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V]): ...
        def equals(self, object: _py_Any) -> bool: ...
        def getKey(self) -> _AbstractMap__SimpleImmutableEntry__K: ...
        def getValue(self) -> _AbstractMap__SimpleImmutableEntry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _AbstractMap__SimpleImmutableEntry__V) -> _AbstractMap__SimpleImmutableEntry__V: ...
        def toString(self) -> str: ...

_EnumMap__K = _py_TypeVar('_EnumMap__K', bound=java.lang.Enum)  # <K>
_EnumMap__V = _py_TypeVar('_EnumMap__V')  # <V>
class EnumMap(AbstractMap[_EnumMap__K, _EnumMap__V], java.io.Serializable, java.lang.Cloneable, _py_Generic[_EnumMap__K, _EnumMap__V]):
    @overload
    def __init__(self, map: Map[_EnumMap__K, _EnumMap__V]): ...
    @overload
    def __init__(self, class_: _py_Type[_EnumMap__K]): ...
    @overload
    def __init__(self, enumMap: 'EnumMap'[_EnumMap__K, _EnumMap__V]): ...
    def clear(self) -> None: ...
    @overload
    def clone(self) -> 'EnumMap'[_EnumMap__K, _EnumMap__V]: ...
    @overload
    def clone(self) -> _py_Any: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set['Map.Entry'[_EnumMap__K, _EnumMap__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def get(self, object: _py_Any) -> _EnumMap__V: ...
    def hashCode(self) -> int: ...
    def keySet(self) -> Set[_EnumMap__K]: ...
    @overload
    def put(self, object: _py_Any, object2: _py_Any) -> _py_Any: ...
    @overload
    def put(self, k: _EnumMap__K, v: _EnumMap__V) -> _EnumMap__V: ...
    def putAll(self, map: Map[_EnumMap__K, _EnumMap__V]) -> None: ...
    @overload
    def remove(self, object: _py_Any) -> _EnumMap__V: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_EnumMap__V]: ...

_HashMap__K = _py_TypeVar('_HashMap__K')  # <K>
_HashMap__V = _py_TypeVar('_HashMap__V')  # <V>
class HashMap(AbstractMap[_HashMap__K, _HashMap__V], Map[_HashMap__K, _HashMap__V], java.lang.Cloneable, java.io.Serializable, _py_Generic[_HashMap__K, _HashMap__V]):
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, map: Map[_HashMap__K, _HashMap__V]): ...
    @overload
    def __init__(self, int: int, float: float): ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def compute(self, k: _HashMap__K, biFunction: java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V]) -> _HashMap__V: ...
    def computeIfAbsent(self, k: _HashMap__K, function: java.util.function.Function[_HashMap__K, _HashMap__V]) -> _HashMap__V: ...
    def computeIfPresent(self, k: _HashMap__K, biFunction: java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V]) -> _HashMap__V: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set['Map.Entry'[_HashMap__K, _HashMap__V]]: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_HashMap__K, _HashMap__V]) -> None: ...
    def get(self, object: _py_Any) -> _HashMap__V: ...
    def getOrDefault(self, object: _py_Any, v: _HashMap__V) -> _HashMap__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_HashMap__K]: ...
    def merge(self, k: _HashMap__K, v: _HashMap__V, biFunction: java.util.function.BiFunction[_HashMap__V, _HashMap__V, _HashMap__V]) -> _HashMap__V: ...
    def put(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    def putAll(self, map: Map[_HashMap__K, _HashMap__V]) -> None: ...
    def putIfAbsent(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    @overload
    def remove(self, object: _py_Any) -> _HashMap__V: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def replace(self, k: _HashMap__K, v: _HashMap__V, v2: _HashMap__V) -> bool: ...
    @overload
    def replace(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_HashMap__V]: ...

_IdentityHashMap__K = _py_TypeVar('_IdentityHashMap__K')  # <K>
_IdentityHashMap__V = _py_TypeVar('_IdentityHashMap__V')  # <V>
class IdentityHashMap(AbstractMap[_IdentityHashMap__K, _IdentityHashMap__V], Map[_IdentityHashMap__K, _IdentityHashMap__V], java.io.Serializable, java.lang.Cloneable, _py_Generic[_IdentityHashMap__K, _IdentityHashMap__V]):
    @overload
    def __init__(self, map: Map[_IdentityHashMap__K, _IdentityHashMap__V]): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self): ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set['Map.Entry'[_IdentityHashMap__K, _IdentityHashMap__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_IdentityHashMap__K, _IdentityHashMap__V]) -> None: ...
    def get(self, object: _py_Any) -> _IdentityHashMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_IdentityHashMap__K]: ...
    def put(self, k: _IdentityHashMap__K, v: _IdentityHashMap__V) -> _IdentityHashMap__V: ...
    def putAll(self, map: Map[_IdentityHashMap__K, _IdentityHashMap__V]) -> None: ...
    @overload
    def remove(self, object: _py_Any) -> _IdentityHashMap__V: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_IdentityHashMap__K, _IdentityHashMap__V, _IdentityHashMap__V]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_IdentityHashMap__V]: ...

_LinkedHashMap__K = _py_TypeVar('_LinkedHashMap__K')  # <K>
_LinkedHashMap__V = _py_TypeVar('_LinkedHashMap__V')  # <V>
class LinkedHashMap(HashMap[_LinkedHashMap__K, _LinkedHashMap__V], Map[_LinkedHashMap__K, _LinkedHashMap__V], _py_Generic[_LinkedHashMap__K, _LinkedHashMap__V]):
    @overload
    def __init__(self, int: int, float: float, boolean: bool): ...
    @overload
    def __init__(self, map: Map[_LinkedHashMap__K, _LinkedHashMap__V]): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, float: float): ...
    @overload
    def __init__(self): ...
    def clear(self) -> None: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set['Map.Entry'[_LinkedHashMap__K, _LinkedHashMap__V]]: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_LinkedHashMap__K, _LinkedHashMap__V]) -> None: ...
    def get(self, object: _py_Any) -> _LinkedHashMap__V: ...
    def getOrDefault(self, object: _py_Any, v: _LinkedHashMap__V) -> _LinkedHashMap__V: ...
    def keySet(self) -> Set[_LinkedHashMap__K]: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_LinkedHashMap__K, _LinkedHashMap__V, _LinkedHashMap__V]) -> None: ...
    def values(self) -> Collection[_LinkedHashMap__V]: ...

_PrimitiveIterator__T = _py_TypeVar('_PrimitiveIterator__T')  # <T>
_PrimitiveIterator__T_CONS = _py_TypeVar('_PrimitiveIterator__T_CONS')  # <T_CONS>
class PrimitiveIterator(Iterator[_PrimitiveIterator__T], _py_Generic[_PrimitiveIterator__T, _PrimitiveIterator__T_CONS]):
    @overload
    def forEachRemaining(self, t_CONS: _PrimitiveIterator__T_CONS) -> None: ...
    @overload
    def forEachRemaining(self, consumer: java.util.function.Consumer[_py_Any]) -> None: ...
    class OfDouble(java.util.PrimitiveIterator[float, java.util.function.DoubleConsumer]):
        @overload
        def forEachRemaining(self, doubleConsumer: java.util.function.DoubleConsumer) -> None: ...
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[float]) -> None: ...
        @overload
        def next(self) -> _py_Any: ...
        @overload
        def next(self) -> float: ...
        def nextDouble(self) -> float: ...
    class OfInt(java.util.PrimitiveIterator[int, java.util.function.IntConsumer]):
        @overload
        def forEachRemaining(self, intConsumer: java.util.function.IntConsumer) -> None: ...
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[int]) -> None: ...
        @overload
        def next(self) -> _py_Any: ...
        @overload
        def next(self) -> int: ...
        def nextInt(self) -> int: ...
    class OfLong(java.util.PrimitiveIterator[int, java.util.function.LongConsumer]):
        @overload
        def forEachRemaining(self, longConsumer: java.util.function.LongConsumer) -> None: ...
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[int]) -> None: ...
        @overload
        def next(self) -> _py_Any: ...
        @overload
        def next(self) -> int: ...
        def nextLong(self) -> int: ...

_Spliterator__OfPrimitive__T = _py_TypeVar('_Spliterator__OfPrimitive__T')  # <T>
_Spliterator__OfPrimitive__T_CONS = _py_TypeVar('_Spliterator__OfPrimitive__T_CONS')  # <T_CONS>
_Spliterator__OfPrimitive__T_SPLITR = _py_TypeVar('_Spliterator__OfPrimitive__T_SPLITR', bound='Spliterator.OfPrimitive')  # <T_SPLITR>
_Spliterator__T = _py_TypeVar('_Spliterator__T')  # <T>
class Spliterator(_py_Generic[_Spliterator__T]):
    ORDERED: _py_ClassVar[int] = ...
    DISTINCT: _py_ClassVar[int] = ...
    SORTED: _py_ClassVar[int] = ...
    SIZED: _py_ClassVar[int] = ...
    NONNULL: _py_ClassVar[int] = ...
    IMMUTABLE: _py_ClassVar[int] = ...
    CONCURRENT: _py_ClassVar[int] = ...
    SUBSIZED: _py_ClassVar[int] = ...
    def characteristics(self) -> int: ...
    def estimateSize(self) -> int: ...
    def forEachRemaining(self, consumer: java.util.function.Consumer[_Spliterator__T]) -> None: ...
    def getComparator(self) -> Comparator[_Spliterator__T]: ...
    def getExactSizeIfKnown(self) -> int: ...
    def hasCharacteristics(self, int: int) -> bool: ...
    def tryAdvance(self, consumer: java.util.function.Consumer[_Spliterator__T]) -> bool: ...
    def trySplit(self) -> 'Spliterator'[_Spliterator__T]: ...
    class OfDouble(java.util.Spliterator.OfPrimitive[float, java.util.function.DoubleConsumer, 'Spliterator.OfDouble']):
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, doubleConsumer: java.util.function.DoubleConsumer) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[float]) -> None: ...
        @overload
        def tryAdvance(self, object: _py_Any) -> bool: ...
        @overload
        def tryAdvance(self, consumer: java.util.function.Consumer[float]) -> bool: ...
        @overload
        def tryAdvance(self, doubleConsumer: java.util.function.DoubleConsumer) -> bool: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
        @overload
        def trySplit(self) -> 'Spliterator': ...
        @overload
        def trySplit(self) -> 'Spliterator.OfDouble': ...
    class OfInt(java.util.Spliterator.OfPrimitive[int, java.util.function.IntConsumer, 'Spliterator.OfInt']):
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, intConsumer: java.util.function.IntConsumer) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[int]) -> None: ...
        @overload
        def tryAdvance(self, object: _py_Any) -> bool: ...
        @overload
        def tryAdvance(self, consumer: java.util.function.Consumer[int]) -> bool: ...
        @overload
        def tryAdvance(self, intConsumer: java.util.function.IntConsumer) -> bool: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
        @overload
        def trySplit(self) -> 'Spliterator': ...
        @overload
        def trySplit(self) -> 'Spliterator.OfInt': ...
    class OfLong(java.util.Spliterator.OfPrimitive[int, java.util.function.LongConsumer, 'Spliterator.OfLong']):
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, longConsumer: java.util.function.LongConsumer) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[int]) -> None: ...
        @overload
        def tryAdvance(self, object: _py_Any) -> bool: ...
        @overload
        def tryAdvance(self, consumer: java.util.function.Consumer[int]) -> bool: ...
        @overload
        def tryAdvance(self, longConsumer: java.util.function.LongConsumer) -> bool: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
        @overload
        def trySplit(self) -> 'Spliterator': ...
        @overload
        def trySplit(self) -> 'Spliterator.OfLong': ...
    class OfPrimitive(java.util.Spliterator[_Spliterator__OfPrimitive__T], _py_Generic[_Spliterator__OfPrimitive__T, _Spliterator__OfPrimitive__T_CONS, _Spliterator__OfPrimitive__T_SPLITR]):
        @overload
        def forEachRemaining(self, t_CONS: _Spliterator__OfPrimitive__T_CONS) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[_Spliterator__OfPrimitive__T]) -> None: ...
        @overload
        def tryAdvance(self, t_CONS: _Spliterator__OfPrimitive__T_CONS) -> bool: ...
        @overload
        def tryAdvance(self, consumer: java.util.function.Consumer[_Spliterator__OfPrimitive__T]) -> bool: ...
        @overload
        def trySplit(self) -> 'Spliterator': ...
        @overload
        def trySplit(self) -> _Spliterator__OfPrimitive__T_SPLITR: ...

_Spliterators__AbstractSpliterator__T = _py_TypeVar('_Spliterators__AbstractSpliterator__T')  # <T>
class Spliterators:
    @classmethod
    def emptyDoubleSpliterator(cls) -> 'Spliterator.OfDouble': ...
    @classmethod
    def emptyIntSpliterator(cls) -> 'Spliterator.OfInt': ...
    @classmethod
    def emptyLongSpliterator(cls) -> 'Spliterator.OfLong': ...
    _emptySpliterator__T = _py_TypeVar('_emptySpliterator__T')  # <T>
    @classmethod
    def emptySpliterator(cls) -> Spliterator[_emptySpliterator__T]: ...
    @classmethod
    @overload
    def iterator(cls, ofInt: 'Spliterator.OfInt') -> 'PrimitiveIterator.OfInt': ...
    @classmethod
    @overload
    def iterator(cls, ofLong: 'Spliterator.OfLong') -> 'PrimitiveIterator.OfLong': ...
    @classmethod
    @overload
    def iterator(cls, ofDouble: 'Spliterator.OfDouble') -> 'PrimitiveIterator.OfDouble': ...
    _iterator_3__T = _py_TypeVar('_iterator_3__T')  # <T>
    @classmethod
    @overload
    def iterator(cls, spliterator: Spliterator[_iterator_3__T]) -> Iterator[_iterator_3__T]: ...
    @classmethod
    @overload
    def spliterator(cls, ofInt: 'PrimitiveIterator.OfInt', long: int, int: int) -> 'Spliterator.OfInt': ...
    @classmethod
    @overload
    def spliterator(cls, ofLong: 'PrimitiveIterator.OfLong', long: int, int: int) -> 'Spliterator.OfLong': ...
    _spliterator_2__T = _py_TypeVar('_spliterator_2__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, iterator: Iterator[_spliterator_2__T], long: int, int: int) -> Spliterator[_spliterator_2__T]: ...
    @classmethod
    @overload
    def spliterator(cls, ofDouble: 'PrimitiveIterator.OfDouble', long: int, int: int) -> 'Spliterator.OfDouble': ...
    _spliterator_4__T = _py_TypeVar('_spliterator_4__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, collection: Collection[_spliterator_4__T], int: int) -> Spliterator[_spliterator_4__T]: ...
    _spliterator_5__T = _py_TypeVar('_spliterator_5__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, objectArray: _py_List[_py_Any], int: int, int2: int, int3: int) -> Spliterator[_spliterator_5__T]: ...
    @classmethod
    @overload
    def spliterator(cls, longArray: _py_List[int], int: int, int2: int, int3: int) -> 'Spliterator.OfLong': ...
    @classmethod
    @overload
    def spliterator(cls, longArray: _py_List[int], int: int) -> 'Spliterator.OfLong': ...
    @classmethod
    @overload
    def spliterator(cls, intArray: _py_List[int], int2: int, int3: int, int4: int) -> 'Spliterator.OfInt': ...
    @classmethod
    @overload
    def spliterator(cls, intArray: _py_List[int], int2: int) -> 'Spliterator.OfInt': ...
    @classmethod
    @overload
    def spliterator(cls, doubleArray: _py_List[float], int: int) -> 'Spliterator.OfDouble': ...
    @classmethod
    @overload
    def spliterator(cls, doubleArray: _py_List[float], int: int, int2: int, int3: int) -> 'Spliterator.OfDouble': ...
    _spliterator_12__T = _py_TypeVar('_spliterator_12__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, objectArray: _py_List[_py_Any], int: int) -> Spliterator[_spliterator_12__T]: ...
    _spliteratorUnknownSize_0__T = _py_TypeVar('_spliteratorUnknownSize_0__T')  # <T>
    @classmethod
    @overload
    def spliteratorUnknownSize(cls, iterator: Iterator[_spliteratorUnknownSize_0__T], int: int) -> Spliterator[_spliteratorUnknownSize_0__T]: ...
    @classmethod
    @overload
    def spliteratorUnknownSize(cls, ofLong: 'PrimitiveIterator.OfLong', int: int) -> 'Spliterator.OfLong': ...
    @classmethod
    @overload
    def spliteratorUnknownSize(cls, ofInt: 'PrimitiveIterator.OfInt', int: int) -> 'Spliterator.OfInt': ...
    @classmethod
    @overload
    def spliteratorUnknownSize(cls, ofDouble: 'PrimitiveIterator.OfDouble', int: int) -> 'Spliterator.OfDouble': ...
    class AbstractDoubleSpliterator(java.util.Spliterator.OfDouble):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
        @overload
        def trySplit(self) -> Spliterator: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfDouble': ...
    class AbstractIntSpliterator(java.util.Spliterator.OfInt):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
        @overload
        def trySplit(self) -> Spliterator: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfInt': ...
    class AbstractLongSpliterator(java.util.Spliterator.OfLong):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
        @overload
        def trySplit(self) -> Spliterator: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfLong': ...
    class AbstractSpliterator(Spliterator[_Spliterators__AbstractSpliterator__T], _py_Generic[_Spliterators__AbstractSpliterator__T]):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        def trySplit(self) -> Spliterator[_Spliterators__AbstractSpliterator__T]: ...

_TreeMap__K = _py_TypeVar('_TreeMap__K')  # <K>
_TreeMap__V = _py_TypeVar('_TreeMap__V')  # <V>
class TreeMap(AbstractMap[_TreeMap__K, _TreeMap__V], NavigableMap[_TreeMap__K, _TreeMap__V], java.lang.Cloneable, java.io.Serializable, _py_Generic[_TreeMap__K, _TreeMap__V]):
    @overload
    def __init__(self, sortedMap: SortedMap[_TreeMap__K, _TreeMap__V]): ...
    @overload
    def __init__(self, map: Map[_TreeMap__K, _TreeMap__V]): ...
    @overload
    def __init__(self, comparator: Comparator[_TreeMap__K]): ...
    @overload
    def __init__(self): ...
    def ceilingEntry(self, k: _TreeMap__K) -> 'Map.Entry'[_TreeMap__K, _TreeMap__V]: ...
    def ceilingKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def comparator(self) -> Comparator[_TreeMap__K]: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def descendingKeySet(self) -> NavigableSet[_TreeMap__K]: ...
    def descendingMap(self) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    def entrySet(self) -> Set['Map.Entry'[_TreeMap__K, _TreeMap__V]]: ...
    def firstEntry(self) -> 'Map.Entry'[_TreeMap__K, _TreeMap__V]: ...
    def firstKey(self) -> _TreeMap__K: ...
    def floorEntry(self, k: _TreeMap__K) -> 'Map.Entry'[_TreeMap__K, _TreeMap__V]: ...
    def floorKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_TreeMap__K, _TreeMap__V]) -> None: ...
    def get(self, object: _py_Any) -> _TreeMap__V: ...
    @overload
    def headMap(self, k: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    @overload
    def headMap(self, k: _TreeMap__K, boolean: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    def higherEntry(self, k: _TreeMap__K) -> 'Map.Entry'[_TreeMap__K, _TreeMap__V]: ...
    def higherKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def keySet(self) -> Set[_TreeMap__K]: ...
    def lastEntry(self) -> 'Map.Entry'[_TreeMap__K, _TreeMap__V]: ...
    def lastKey(self) -> _TreeMap__K: ...
    def lowerEntry(self, k: _TreeMap__K) -> 'Map.Entry'[_TreeMap__K, _TreeMap__V]: ...
    def lowerKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def navigableKeySet(self) -> NavigableSet[_TreeMap__K]: ...
    def pollFirstEntry(self) -> 'Map.Entry'[_TreeMap__K, _TreeMap__V]: ...
    def pollLastEntry(self) -> 'Map.Entry'[_TreeMap__K, _TreeMap__V]: ...
    def put(self, k: _TreeMap__K, v: _TreeMap__V) -> _TreeMap__V: ...
    def putAll(self, map: Map[_TreeMap__K, _TreeMap__V]) -> None: ...
    @overload
    def remove(self, object: _py_Any) -> _TreeMap__V: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def replace(self, k: _TreeMap__K, v: _TreeMap__V) -> _TreeMap__V: ...
    @overload
    def replace(self, k: _TreeMap__K, v: _TreeMap__V, v2: _TreeMap__V) -> bool: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_TreeMap__K, _TreeMap__V, _TreeMap__V]) -> None: ...
    def size(self) -> int: ...
    @overload
    def subMap(self, k: _TreeMap__K, boolean: bool, k2: _TreeMap__K, boolean2: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    @overload
    def subMap(self, k: _TreeMap__K, k2: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    @overload
    def tailMap(self, k: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    @overload
    def tailMap(self, k: _TreeMap__K, boolean: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    def values(self) -> Collection[_TreeMap__V]: ...

_WeakHashMap__K = _py_TypeVar('_WeakHashMap__K')  # <K>
_WeakHashMap__V = _py_TypeVar('_WeakHashMap__V')  # <V>
class WeakHashMap(AbstractMap[_WeakHashMap__K, _WeakHashMap__V], Map[_WeakHashMap__K, _WeakHashMap__V], _py_Generic[_WeakHashMap__K, _WeakHashMap__V]):
    @overload
    def __init__(self, map: Map[_WeakHashMap__K, _WeakHashMap__V]): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, float: float): ...
    @overload
    def __init__(self): ...
    def clear(self) -> None: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set['Map.Entry'[_WeakHashMap__K, _WeakHashMap__V]]: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_WeakHashMap__K, _WeakHashMap__V]) -> None: ...
    def get(self, object: _py_Any) -> _WeakHashMap__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_WeakHashMap__K]: ...
    def put(self, k: _WeakHashMap__K, v: _WeakHashMap__V) -> _WeakHashMap__V: ...
    def putAll(self, map: Map[_WeakHashMap__K, _WeakHashMap__V]) -> None: ...
    @overload
    def remove(self, object: _py_Any) -> _WeakHashMap__V: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_WeakHashMap__K, _WeakHashMap__V, _WeakHashMap__V]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_WeakHashMap__V]: ...
