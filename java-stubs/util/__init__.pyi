from typing import Any as _py_Any
from typing import List as _py_List
from typing import TypeVar as _py_TypeVar
from typing import Type as _py_Type
from typing import ClassVar as _py_ClassVar
from typing import Generic as _py_Generic
from typing import Set as _py_Set
from typing import Collection as _py_Collection
from typing import Mapping as _py_Mapping
from typing import overload
import java
import java.io
import java.lang
import java.math
import java.nio
import java.nio.channels
import java.nio.file
import java.security
import java.time
import java.util.function
import java.util.regex
import java.util.stream


class ArrayPrefixHelpers: ...

class Arrays:
    _asList__T = _py_TypeVar('_asList__T')  # <T>
    @classmethod
    def asList(cls, tArray: _py_List[_asList__T]) -> 'List'[_asList__T]: ...
    @classmethod
    @overload
    def binarySearch(cls, byteArray: _py_List[int], byte2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, byteArray: _py_List[int], int: int, int2: int, byte2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, charArray: _py_List[str], char2: str) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, charArray: _py_List[str], int: int, int2: int, char2: str) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, doubleArray: _py_List[float], double2: float) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, doubleArray: _py_List[float], int: int, int2: int, double2: float) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, floatArray: _py_List[float], float2: float) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, floatArray: _py_List[float], int: int, int2: int, float2: float) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, intArray: _py_List[int], int2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, intArray: _py_List[int], int2: int, int3: int, int4: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, objectArray: _py_List[_py_Any], int: int, int2: int, object2: _py_Any) -> int: ...
    _binarySearch_11__T = _py_TypeVar('_binarySearch_11__T')  # <T>
    @classmethod
    @overload
    def binarySearch(cls, tArray: _py_List[_binarySearch_11__T], int: int, int2: int, t2: _binarySearch_11__T, comparator: 'Comparator'[_binarySearch_11__T]) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, objectArray: _py_List[_py_Any], object2: _py_Any) -> int: ...
    _binarySearch_13__T = _py_TypeVar('_binarySearch_13__T')  # <T>
    @classmethod
    @overload
    def binarySearch(cls, tArray: _py_List[_binarySearch_13__T], t2: _binarySearch_13__T, comparator: 'Comparator'[_binarySearch_13__T]) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, longArray: _py_List[int], int: int, int2: int, long2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, longArray: _py_List[int], long2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, shortArray: _py_List[int], int: int, int2: int, short2: int) -> int: ...
    @classmethod
    @overload
    def binarySearch(cls, shortArray: _py_List[int], short2: int) -> int: ...
    @classmethod
    @overload
    def copyOf(cls, booleanArray: _py_List[bool], int: int) -> _py_List[bool]: ...
    @classmethod
    @overload
    def copyOf(cls, byteArray: _py_List[int], int: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOf(cls, charArray: _py_List[str], int: int) -> _py_List[str]: ...
    @classmethod
    @overload
    def copyOf(cls, doubleArray: _py_List[float], int: int) -> _py_List[float]: ...
    @classmethod
    @overload
    def copyOf(cls, floatArray: _py_List[float], int: int) -> _py_List[float]: ...
    @classmethod
    @overload
    def copyOf(cls, intArray: _py_List[int], int2: int) -> _py_List[int]: ...
    _copyOf_6__T = _py_TypeVar('_copyOf_6__T')  # <T>
    @classmethod
    @overload
    def copyOf(cls, tArray: _py_List[_copyOf_6__T], int: int) -> _py_List[_copyOf_6__T]: ...
    _copyOf_7__T = _py_TypeVar('_copyOf_7__T')  # <T>
    _copyOf_7__U = _py_TypeVar('_copyOf_7__U')  # <U>
    @classmethod
    @overload
    def copyOf(cls, uArray: _py_List[_copyOf_7__U], int: int, class_: _py_Type[_py_List[_copyOf_7__T]]) -> _py_List[_copyOf_7__T]: ...
    @classmethod
    @overload
    def copyOf(cls, longArray: _py_List[int], int: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOf(cls, shortArray: _py_List[int], int: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOfRange(cls, booleanArray: _py_List[bool], int: int, int2: int) -> _py_List[bool]: ...
    @classmethod
    @overload
    def copyOfRange(cls, byteArray: _py_List[int], int: int, int2: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOfRange(cls, charArray: _py_List[str], int: int, int2: int) -> _py_List[str]: ...
    @classmethod
    @overload
    def copyOfRange(cls, doubleArray: _py_List[float], int: int, int2: int) -> _py_List[float]: ...
    @classmethod
    @overload
    def copyOfRange(cls, floatArray: _py_List[float], int: int, int2: int) -> _py_List[float]: ...
    @classmethod
    @overload
    def copyOfRange(cls, intArray: _py_List[int], int2: int, int3: int) -> _py_List[int]: ...
    _copyOfRange_6__T = _py_TypeVar('_copyOfRange_6__T')  # <T>
    @classmethod
    @overload
    def copyOfRange(cls, tArray: _py_List[_copyOfRange_6__T], int: int, int2: int) -> _py_List[_copyOfRange_6__T]: ...
    _copyOfRange_7__T = _py_TypeVar('_copyOfRange_7__T')  # <T>
    _copyOfRange_7__U = _py_TypeVar('_copyOfRange_7__U')  # <U>
    @classmethod
    @overload
    def copyOfRange(cls, uArray: _py_List[_copyOfRange_7__U], int: int, int2: int, class_: _py_Type[_py_List[_copyOfRange_7__T]]) -> _py_List[_copyOfRange_7__T]: ...
    @classmethod
    @overload
    def copyOfRange(cls, longArray: _py_List[int], int: int, int2: int) -> _py_List[int]: ...
    @classmethod
    @overload
    def copyOfRange(cls, shortArray: _py_List[int], int: int, int2: int) -> _py_List[int]: ...
    @classmethod
    def deepEquals(cls, objectArray: _py_List[_py_Any], objectArray2: _py_List[_py_Any]) -> bool: ...
    @classmethod
    def deepHashCode(cls, objectArray: _py_List[_py_Any]) -> int: ...
    @classmethod
    def deepToString(cls, objectArray: _py_List[_py_Any]) -> str: ...
    @overload
    def equals(self, object: _py_Any) -> bool: ...
    @classmethod
    @overload
    def equals(cls, booleanArray: _py_List[bool], booleanArray2: _py_List[bool]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, byteArray: _py_List[int], byteArray2: _py_List[int]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, charArray: _py_List[str], charArray2: _py_List[str]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, doubleArray: _py_List[float], doubleArray2: _py_List[float]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, floatArray: _py_List[float], floatArray2: _py_List[float]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, intArray: _py_List[int], intArray2: _py_List[int]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, objectArray: _py_List[_py_Any], objectArray2: _py_List[_py_Any]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, longArray: _py_List[int], longArray2: _py_List[int]) -> bool: ...
    @classmethod
    @overload
    def equals(cls, shortArray: _py_List[int], shortArray2: _py_List[int]) -> bool: ...
    @classmethod
    @overload
    def fill(cls, booleanArray: _py_List[bool], boolean2: bool) -> None: ...
    @classmethod
    @overload
    def fill(cls, booleanArray: _py_List[bool], int: int, int2: int, boolean2: bool) -> None: ...
    @classmethod
    @overload
    def fill(cls, byteArray: _py_List[int], byte2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, byteArray: _py_List[int], int: int, int2: int, byte2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, charArray: _py_List[str], char2: str) -> None: ...
    @classmethod
    @overload
    def fill(cls, charArray: _py_List[str], int: int, int2: int, char2: str) -> None: ...
    @classmethod
    @overload
    def fill(cls, doubleArray: _py_List[float], double2: float) -> None: ...
    @classmethod
    @overload
    def fill(cls, doubleArray: _py_List[float], int: int, int2: int, double2: float) -> None: ...
    @classmethod
    @overload
    def fill(cls, floatArray: _py_List[float], float2: float) -> None: ...
    @classmethod
    @overload
    def fill(cls, floatArray: _py_List[float], int: int, int2: int, float2: float) -> None: ...
    @classmethod
    @overload
    def fill(cls, intArray: _py_List[int], int2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, intArray: _py_List[int], int2: int, int3: int, int4: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, objectArray: _py_List[_py_Any], int: int, int2: int, object2: _py_Any) -> None: ...
    @classmethod
    @overload
    def fill(cls, objectArray: _py_List[_py_Any], object2: _py_Any) -> None: ...
    @classmethod
    @overload
    def fill(cls, longArray: _py_List[int], int: int, int2: int, long2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, longArray: _py_List[int], long2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, shortArray: _py_List[int], int: int, int2: int, short2: int) -> None: ...
    @classmethod
    @overload
    def fill(cls, shortArray: _py_List[int], short2: int) -> None: ...
    @overload
    def hashCode(self) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, booleanArray: _py_List[bool]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, byteArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, charArray: _py_List[str]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, doubleArray: _py_List[float]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, floatArray: _py_List[float]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, intArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, objectArray: _py_List[_py_Any]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, longArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, shortArray: _py_List[int]) -> int: ...
    @classmethod
    @overload
    def parallelPrefix(cls, doubleArray: _py_List[float], int: int, int2: int, doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> None: ...
    @classmethod
    @overload
    def parallelPrefix(cls, doubleArray: _py_List[float], doubleBinaryOperator: java.util.function.DoubleBinaryOperator) -> None: ...
    @classmethod
    @overload
    def parallelPrefix(cls, intArray: _py_List[int], int2: int, int3: int, intBinaryOperator: java.util.function.IntBinaryOperator) -> None: ...
    @classmethod
    @overload
    def parallelPrefix(cls, intArray: _py_List[int], intBinaryOperator: java.util.function.IntBinaryOperator) -> None: ...
    _parallelPrefix_4__T = _py_TypeVar('_parallelPrefix_4__T')  # <T>
    @classmethod
    @overload
    def parallelPrefix(cls, tArray: _py_List[_parallelPrefix_4__T], int: int, int2: int, binaryOperator: java.util.function.BinaryOperator[_parallelPrefix_4__T]) -> None: ...
    _parallelPrefix_5__T = _py_TypeVar('_parallelPrefix_5__T')  # <T>
    @classmethod
    @overload
    def parallelPrefix(cls, tArray: _py_List[_parallelPrefix_5__T], binaryOperator: java.util.function.BinaryOperator[_parallelPrefix_5__T]) -> None: ...
    @classmethod
    @overload
    def parallelPrefix(cls, longArray: _py_List[int], int: int, int2: int, longBinaryOperator: java.util.function.LongBinaryOperator) -> None: ...
    @classmethod
    @overload
    def parallelPrefix(cls, longArray: _py_List[int], longBinaryOperator: java.util.function.LongBinaryOperator) -> None: ...
    @classmethod
    @overload
    def parallelSetAll(cls, doubleArray: _py_List[float], intToDoubleFunction: java.util.function.IntToDoubleFunction) -> None: ...
    @classmethod
    @overload
    def parallelSetAll(cls, intArray: _py_List[int], intUnaryOperator: java.util.function.IntUnaryOperator) -> None: ...
    _parallelSetAll_2__T = _py_TypeVar('_parallelSetAll_2__T')  # <T>
    @classmethod
    @overload
    def parallelSetAll(cls, tArray: _py_List[_parallelSetAll_2__T], intFunction: java.util.function.IntFunction[_parallelSetAll_2__T]) -> None: ...
    @classmethod
    @overload
    def parallelSetAll(cls, longArray: _py_List[int], intToLongFunction: java.util.function.IntToLongFunction) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, byteArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, byteArray: _py_List[int], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, charArray: _py_List[str]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, charArray: _py_List[str], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, doubleArray: _py_List[float]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, doubleArray: _py_List[float], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, floatArray: _py_List[float]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, floatArray: _py_List[float], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, intArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, intArray: _py_List[int], int2: int, int3: int) -> None: ...
    _parallelSort_10__T = _py_TypeVar('_parallelSort_10__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    @overload
    def parallelSort(cls, tArray: _py_List[_parallelSort_10__T]) -> None: ...
    _parallelSort_11__T = _py_TypeVar('_parallelSort_11__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    @overload
    def parallelSort(cls, tArray: _py_List[_parallelSort_11__T], int: int, int2: int) -> None: ...
    _parallelSort_12__T = _py_TypeVar('_parallelSort_12__T')  # <T>
    @classmethod
    @overload
    def parallelSort(cls, tArray: _py_List[_parallelSort_12__T], int: int, int2: int, comparator: 'Comparator'[_parallelSort_12__T]) -> None: ...
    _parallelSort_13__T = _py_TypeVar('_parallelSort_13__T')  # <T>
    @classmethod
    @overload
    def parallelSort(cls, tArray: _py_List[_parallelSort_13__T], comparator: 'Comparator'[_parallelSort_13__T]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, longArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, longArray: _py_List[int], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, shortArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def parallelSort(cls, shortArray: _py_List[int], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def setAll(cls, doubleArray: _py_List[float], intToDoubleFunction: java.util.function.IntToDoubleFunction) -> None: ...
    @classmethod
    @overload
    def setAll(cls, intArray: _py_List[int], intUnaryOperator: java.util.function.IntUnaryOperator) -> None: ...
    _setAll_2__T = _py_TypeVar('_setAll_2__T')  # <T>
    @classmethod
    @overload
    def setAll(cls, tArray: _py_List[_setAll_2__T], intFunction: java.util.function.IntFunction[_setAll_2__T]) -> None: ...
    @classmethod
    @overload
    def setAll(cls, longArray: _py_List[int], intToLongFunction: java.util.function.IntToLongFunction) -> None: ...
    @classmethod
    @overload
    def sort(cls, byteArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def sort(cls, byteArray: _py_List[int], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, charArray: _py_List[str]) -> None: ...
    @classmethod
    @overload
    def sort(cls, charArray: _py_List[str], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, doubleArray: _py_List[float]) -> None: ...
    @classmethod
    @overload
    def sort(cls, doubleArray: _py_List[float], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, floatArray: _py_List[float]) -> None: ...
    @classmethod
    @overload
    def sort(cls, floatArray: _py_List[float], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, intArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def sort(cls, intArray: _py_List[int], int2: int, int3: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, objectArray: _py_List[_py_Any]) -> None: ...
    @classmethod
    @overload
    def sort(cls, objectArray: _py_List[_py_Any], int: int, int2: int) -> None: ...
    _sort_12__T = _py_TypeVar('_sort_12__T')  # <T>
    @classmethod
    @overload
    def sort(cls, tArray: _py_List[_sort_12__T], int: int, int2: int, comparator: 'Comparator'[_sort_12__T]) -> None: ...
    _sort_13__T = _py_TypeVar('_sort_13__T')  # <T>
    @classmethod
    @overload
    def sort(cls, tArray: _py_List[_sort_13__T], comparator: 'Comparator'[_sort_13__T]) -> None: ...
    @classmethod
    @overload
    def sort(cls, longArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def sort(cls, longArray: _py_List[int], int: int, int2: int) -> None: ...
    @classmethod
    @overload
    def sort(cls, shortArray: _py_List[int]) -> None: ...
    @classmethod
    @overload
    def sort(cls, shortArray: _py_List[int], int: int, int2: int) -> None: ...
    _spliterator_0__T = _py_TypeVar('_spliterator_0__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, tArray: _py_List[_spliterator_0__T]) -> 'Spliterator'[_spliterator_0__T]: ...
    _spliterator_1__T = _py_TypeVar('_spliterator_1__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, tArray: _py_List[_spliterator_1__T], int: int, int2: int) -> 'Spliterator'[_spliterator_1__T]: ...
    @classmethod
    @overload
    def spliterator(cls, doubleArray: _py_List[float]) -> 'Spliterator.OfDouble': ...
    @classmethod
    @overload
    def spliterator(cls, doubleArray: _py_List[float], int: int, int2: int) -> 'Spliterator.OfDouble': ...
    @classmethod
    @overload
    def spliterator(cls, intArray: _py_List[int]) -> 'Spliterator.OfInt': ...
    @classmethod
    @overload
    def spliterator(cls, intArray: _py_List[int], int2: int, int3: int) -> 'Spliterator.OfInt': ...
    @classmethod
    @overload
    def spliterator(cls, longArray: _py_List[int]) -> 'Spliterator.OfLong': ...
    @classmethod
    @overload
    def spliterator(cls, longArray: _py_List[int], int: int, int2: int) -> 'Spliterator.OfLong': ...
    @classmethod
    @overload
    def stream(cls, doubleArray: _py_List[float]) -> java.util.stream.DoubleStream: ...
    @classmethod
    @overload
    def stream(cls, doubleArray: _py_List[float], int: int, int2: int) -> java.util.stream.DoubleStream: ...
    @classmethod
    @overload
    def stream(cls, intArray: _py_List[int]) -> java.util.stream.IntStream: ...
    @classmethod
    @overload
    def stream(cls, intArray: _py_List[int], int2: int, int3: int) -> java.util.stream.IntStream: ...
    @classmethod
    @overload
    def stream(cls, longArray: _py_List[int]) -> java.util.stream.LongStream: ...
    @classmethod
    @overload
    def stream(cls, longArray: _py_List[int], int: int, int2: int) -> java.util.stream.LongStream: ...
    _stream_6__T = _py_TypeVar('_stream_6__T')  # <T>
    @classmethod
    @overload
    def stream(cls, tArray: _py_List[_stream_6__T]) -> java.util.stream.Stream[_stream_6__T]: ...
    _stream_7__T = _py_TypeVar('_stream_7__T')  # <T>
    @classmethod
    @overload
    def stream(cls, tArray: _py_List[_stream_7__T], int: int, int2: int) -> java.util.stream.Stream[_stream_7__T]: ...
    @overload
    def toString(self) -> str: ...
    @classmethod
    @overload
    def toString(cls, booleanArray: _py_List[bool]) -> str: ...
    @classmethod
    @overload
    def toString(cls, byteArray: _py_List[int]) -> str: ...
    @classmethod
    @overload
    def toString(cls, charArray: _py_List[str]) -> str: ...
    @classmethod
    @overload
    def toString(cls, doubleArray: _py_List[float]) -> str: ...
    @classmethod
    @overload
    def toString(cls, floatArray: _py_List[float]) -> str: ...
    @classmethod
    @overload
    def toString(cls, intArray: _py_List[int]) -> str: ...
    @classmethod
    @overload
    def toString(cls, objectArray: _py_List[_py_Any]) -> str: ...
    @classmethod
    @overload
    def toString(cls, longArray: _py_List[int]) -> str: ...
    @classmethod
    @overload
    def toString(cls, shortArray: _py_List[int]) -> str: ...

class ArraysParallelSortHelpers: ...

class Base64:
    @classmethod
    def getDecoder(cls) -> 'Base64.Decoder': ...
    @classmethod
    def getEncoder(cls) -> 'Base64.Encoder': ...
    @classmethod
    def getMimeDecoder(cls) -> 'Base64.Decoder': ...
    @classmethod
    @overload
    def getMimeEncoder(cls) -> 'Base64.Encoder': ...
    @classmethod
    @overload
    def getMimeEncoder(cls, int: int, byteArray: _py_List[int]) -> 'Base64.Encoder': ...
    @classmethod
    def getUrlDecoder(cls) -> 'Base64.Decoder': ...
    @classmethod
    def getUrlEncoder(cls) -> 'Base64.Encoder': ...
    class Decoder:
        @overload
        def decode(self, byteArray: _py_List[int]) -> _py_List[int]: ...
        @overload
        def decode(self, string: str) -> _py_List[int]: ...
        @overload
        def decode(self, byteArray: _py_List[int], byteArray2: _py_List[int]) -> int: ...
        @overload
        def decode(self, byteBuffer: java.nio.ByteBuffer) -> java.nio.ByteBuffer: ...
        def wrap(self, inputStream: java.io.InputStream) -> java.io.InputStream: ...
    class Encoder:
        @overload
        def encode(self, byteArray: _py_List[int]) -> _py_List[int]: ...
        @overload
        def encode(self, byteArray: _py_List[int], byteArray2: _py_List[int]) -> int: ...
        @overload
        def encode(self, byteBuffer: java.nio.ByteBuffer) -> java.nio.ByteBuffer: ...
        def encodeToString(self, byteArray: _py_List[int]) -> str: ...
        def withoutPadding(self) -> 'Base64.Encoder': ...
        def wrap(self, outputStream: java.io.OutputStream) -> java.io.OutputStream: ...

class BitSet(java.lang.Cloneable, java.io.Serializable):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    def andNot(self, bitSet: 'BitSet') -> None: ...
    def cardinality(self) -> int: ...
    @overload
    def clear(self) -> None: ...
    @overload
    def clear(self, int: int) -> None: ...
    @overload
    def clear(self, int: int, int2: int) -> None: ...
    def clone(self) -> _py_Any: ...
    def equals(self, object: _py_Any) -> bool: ...
    @overload
    def flip(self, int: int) -> None: ...
    @overload
    def flip(self, int: int, int2: int) -> None: ...
    @overload
    def get(self, int: int) -> bool: ...
    @overload
    def get(self, int: int, int2: int) -> 'BitSet': ...
    def hashCode(self) -> int: ...
    def intersects(self, bitSet: 'BitSet') -> bool: ...
    def isEmpty(self) -> bool: ...
    def length(self) -> int: ...
    def nextClearBit(self, int: int) -> int: ...
    def nextSetBit(self, int: int) -> int: ...
    def previousClearBit(self, int: int) -> int: ...
    def previousSetBit(self, int: int) -> int: ...
    @overload
    def set(self, int: int) -> None: ...
    @overload
    def set(self, int: int, boolean: bool) -> None: ...
    @overload
    def set(self, int: int, int2: int) -> None: ...
    @overload
    def set(self, int: int, int2: int, boolean: bool) -> None: ...
    def size(self) -> int: ...
    def stream(self) -> java.util.stream.IntStream: ...
    def toByteArray(self) -> _py_List[int]: ...
    def toLongArray(self) -> _py_List[int]: ...
    def toString(self) -> str: ...
    @classmethod
    @overload
    def valueOf(cls, byteArray: _py_List[int]) -> 'BitSet': ...
    @classmethod
    @overload
    def valueOf(cls, byteBuffer: java.nio.ByteBuffer) -> 'BitSet': ...
    @classmethod
    @overload
    def valueOf(cls, longBuffer: java.nio.LongBuffer) -> 'BitSet': ...
    @classmethod
    @overload
    def valueOf(cls, longArray: _py_List[int]) -> 'BitSet': ...
    def xor(self, bitSet: 'BitSet') -> None: ...

class Calendar(java.io.Serializable, java.lang.Cloneable, java.lang.Comparable['Calendar']):
    ERA: _py_ClassVar[int] = ...
    YEAR: _py_ClassVar[int] = ...
    MONTH: _py_ClassVar[int] = ...
    WEEK_OF_YEAR: _py_ClassVar[int] = ...
    WEEK_OF_MONTH: _py_ClassVar[int] = ...
    DATE: _py_ClassVar[int] = ...
    DAY_OF_MONTH: _py_ClassVar[int] = ...
    DAY_OF_YEAR: _py_ClassVar[int] = ...
    DAY_OF_WEEK: _py_ClassVar[int] = ...
    DAY_OF_WEEK_IN_MONTH: _py_ClassVar[int] = ...
    AM_PM: _py_ClassVar[int] = ...
    HOUR: _py_ClassVar[int] = ...
    HOUR_OF_DAY: _py_ClassVar[int] = ...
    MINUTE: _py_ClassVar[int] = ...
    SECOND: _py_ClassVar[int] = ...
    MILLISECOND: _py_ClassVar[int] = ...
    ZONE_OFFSET: _py_ClassVar[int] = ...
    DST_OFFSET: _py_ClassVar[int] = ...
    FIELD_COUNT: _py_ClassVar[int] = ...
    SUNDAY: _py_ClassVar[int] = ...
    MONDAY: _py_ClassVar[int] = ...
    TUESDAY: _py_ClassVar[int] = ...
    WEDNESDAY: _py_ClassVar[int] = ...
    THURSDAY: _py_ClassVar[int] = ...
    FRIDAY: _py_ClassVar[int] = ...
    SATURDAY: _py_ClassVar[int] = ...
    JANUARY: _py_ClassVar[int] = ...
    FEBRUARY: _py_ClassVar[int] = ...
    MARCH: _py_ClassVar[int] = ...
    APRIL: _py_ClassVar[int] = ...
    MAY: _py_ClassVar[int] = ...
    JUNE: _py_ClassVar[int] = ...
    JULY: _py_ClassVar[int] = ...
    AUGUST: _py_ClassVar[int] = ...
    SEPTEMBER: _py_ClassVar[int] = ...
    OCTOBER: _py_ClassVar[int] = ...
    NOVEMBER: _py_ClassVar[int] = ...
    DECEMBER: _py_ClassVar[int] = ...
    UNDECIMBER: _py_ClassVar[int] = ...
    AM: _py_ClassVar[int] = ...
    PM: _py_ClassVar[int] = ...
    ALL_STYLES: _py_ClassVar[int] = ...
    SHORT: _py_ClassVar[int] = ...
    LONG: _py_ClassVar[int] = ...
    NARROW_FORMAT: _py_ClassVar[int] = ...
    NARROW_STANDALONE: _py_ClassVar[int] = ...
    SHORT_FORMAT: _py_ClassVar[int] = ...
    LONG_FORMAT: _py_ClassVar[int] = ...
    SHORT_STANDALONE: _py_ClassVar[int] = ...
    LONG_STANDALONE: _py_ClassVar[int] = ...
    def add(self, int: int, int2: int) -> None: ...
    def after(self, object: _py_Any) -> bool: ...
    def before(self, object: _py_Any) -> bool: ...
    @overload
    def clear(self) -> None: ...
    @overload
    def clear(self, int: int) -> None: ...
    def clone(self) -> _py_Any: ...
    @overload
    def compareTo(self, object: _py_Any) -> int: ...
    @overload
    def compareTo(self, calendar: 'Calendar') -> int: ...
    def equals(self, object: _py_Any) -> bool: ...
    def get(self, int: int) -> int: ...
    def getActualMaximum(self, int: int) -> int: ...
    def getActualMinimum(self, int: int) -> int: ...
    @classmethod
    def getAvailableCalendarTypes(cls) -> 'Set'[str]: ...
    @classmethod
    def getAvailableLocales(cls) -> _py_List['Locale']: ...
    def getCalendarType(self) -> str: ...
    def getDisplayName(self, int: int, int2: int, locale: 'Locale') -> str: ...
    def getDisplayNames(self, int: int, int2: int, locale: 'Locale') -> 'Map'[str, int]: ...
    def getFirstDayOfWeek(self) -> int: ...
    def getGreatestMinimum(self, int: int) -> int: ...
    @classmethod
    @overload
    def getInstance(cls) -> 'Calendar': ...
    @classmethod
    @overload
    def getInstance(cls, locale: 'Locale') -> 'Calendar': ...
    @classmethod
    @overload
    def getInstance(cls, timeZone: 'TimeZone') -> 'Calendar': ...
    @classmethod
    @overload
    def getInstance(cls, timeZone: 'TimeZone', locale: 'Locale') -> 'Calendar': ...
    def getLeastMaximum(self, int: int) -> int: ...
    def getMaximum(self, int: int) -> int: ...
    def getMinimalDaysInFirstWeek(self) -> int: ...
    def getMinimum(self, int: int) -> int: ...
    def getTime(self) -> 'Date': ...
    def getTimeInMillis(self) -> int: ...
    def getTimeZone(self) -> 'TimeZone': ...
    def getWeekYear(self) -> int: ...
    def getWeeksInWeekYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isLenient(self) -> bool: ...
    def isSet(self, int: int) -> bool: ...
    def isWeekDateSupported(self) -> bool: ...
    @overload
    def roll(self, int: int, boolean: bool) -> None: ...
    @overload
    def roll(self, int: int, int2: int) -> None: ...
    @overload
    def set(self, int: int, int2: int, int3: int) -> None: ...
    @overload
    def set(self, int: int, int2: int, int3: int, int4: int, int5: int) -> None: ...
    @overload
    def set(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    @overload
    def set(self, int: int, int2: int) -> None: ...
    def setFirstDayOfWeek(self, int: int) -> None: ...
    def setLenient(self, boolean: bool) -> None: ...
    def setMinimalDaysInFirstWeek(self, int: int) -> None: ...
    def setTime(self, date: 'Date') -> None: ...
    def setTimeInMillis(self, long: int) -> None: ...
    def setTimeZone(self, timeZone: 'TimeZone') -> None: ...
    def setWeekDate(self, int: int, int2: int, int3: int) -> None: ...
    def toInstant(self) -> java.time.Instant: ...
    def toString(self) -> str: ...
    class Builder:
        def __init__(self): ...
        def build(self) -> 'Calendar': ...
        def set(self, int: int, int2: int) -> 'Calendar.Builder': ...
        def setCalendarType(self, string: str) -> 'Calendar.Builder': ...
        def setDate(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        def setFields(self, intArray: _py_List[int]) -> 'Calendar.Builder': ...
        @overload
        def setInstant(self, date: 'Date') -> 'Calendar.Builder': ...
        @overload
        def setInstant(self, long: int) -> 'Calendar.Builder': ...
        def setLenient(self, boolean: bool) -> 'Calendar.Builder': ...
        def setLocale(self, locale: 'Locale') -> 'Calendar.Builder': ...
        @overload
        def setTimeOfDay(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        @overload
        def setTimeOfDay(self, int: int, int2: int, int3: int, int4: int) -> 'Calendar.Builder': ...
        def setTimeZone(self, timeZone: 'TimeZone') -> 'Calendar.Builder': ...
        def setWeekDate(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        def setWeekDefinition(self, int: int, int2: int) -> 'Calendar.Builder': ...

_Collection__E = _py_TypeVar('_Collection__E')  # <E>
class Collection(java.lang.Iterable[_Collection__E], _py_Generic[_Collection__E], _py_Collection[_Collection__E]):
    def add(self, e: _Collection__E) -> bool: ...
    def addAll(self, collection: 'Collection'[_Collection__E]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: 'Collection'[_py_Any]) -> bool: ...
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> 'Iterator'[_Collection__E]: ...
    def parallelStream(self) -> java.util.stream.Stream[_Collection__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: 'Collection'[_py_Any]) -> bool: ...
    def removeIf(self, predicate: java.util.function.Predicate[_Collection__E]) -> bool: ...
    def retainAll(self, collection: 'Collection'[_py_Any]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_Collection__E]: ...
    def stream(self) -> java.util.stream.Stream[_Collection__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...

class Collections:
    EMPTY_SET: _py_ClassVar['Set'] = ...
    EMPTY_LIST: _py_ClassVar['List'] = ...
    EMPTY_MAP: _py_ClassVar['Map'] = ...
    _addAll__T = _py_TypeVar('_addAll__T')  # <T>
    @classmethod
    def addAll(cls, collection: Collection[_addAll__T], tArray: _py_List[_addAll__T]) -> bool: ...
    _asLifoQueue__T = _py_TypeVar('_asLifoQueue__T')  # <T>
    @classmethod
    def asLifoQueue(cls, deque: 'Deque'[_asLifoQueue__T]) -> 'Queue'[_asLifoQueue__T]: ...
    _binarySearch_0__T = _py_TypeVar('_binarySearch_0__T')  # <T>
    @classmethod
    @overload
    def binarySearch(cls, list: 'List'[java.lang.Comparable[_binarySearch_0__T]], t: _binarySearch_0__T) -> int: ...
    _binarySearch_1__T = _py_TypeVar('_binarySearch_1__T')  # <T>
    @classmethod
    @overload
    def binarySearch(cls, list: 'List'[_binarySearch_1__T], t: _binarySearch_1__T, comparator: 'Comparator'[_binarySearch_1__T]) -> int: ...
    _checkedCollection__E = _py_TypeVar('_checkedCollection__E')  # <E>
    @classmethod
    def checkedCollection(cls, collection: Collection[_checkedCollection__E], class_: _py_Type[_checkedCollection__E]) -> Collection[_checkedCollection__E]: ...
    _checkedList__E = _py_TypeVar('_checkedList__E')  # <E>
    @classmethod
    def checkedList(cls, list: 'List'[_checkedList__E], class_: _py_Type[_checkedList__E]) -> 'List'[_checkedList__E]: ...
    _checkedMap__K = _py_TypeVar('_checkedMap__K')  # <K>
    _checkedMap__V = _py_TypeVar('_checkedMap__V')  # <V>
    @classmethod
    def checkedMap(cls, map: 'Map'[_checkedMap__K, _checkedMap__V], class_: _py_Type[_checkedMap__K], class2: _py_Type[_checkedMap__V]) -> 'Map'[_checkedMap__K, _checkedMap__V]: ...
    _checkedNavigableMap__K = _py_TypeVar('_checkedNavigableMap__K')  # <K>
    _checkedNavigableMap__V = _py_TypeVar('_checkedNavigableMap__V')  # <V>
    @classmethod
    def checkedNavigableMap(cls, navigableMap: 'NavigableMap'[_checkedNavigableMap__K, _checkedNavigableMap__V], class_: _py_Type[_checkedNavigableMap__K], class2: _py_Type[_checkedNavigableMap__V]) -> 'NavigableMap'[_checkedNavigableMap__K, _checkedNavigableMap__V]: ...
    _checkedNavigableSet__E = _py_TypeVar('_checkedNavigableSet__E')  # <E>
    @classmethod
    def checkedNavigableSet(cls, navigableSet: 'NavigableSet'[_checkedNavigableSet__E], class_: _py_Type[_checkedNavigableSet__E]) -> 'NavigableSet'[_checkedNavigableSet__E]: ...
    _checkedQueue__E = _py_TypeVar('_checkedQueue__E')  # <E>
    @classmethod
    def checkedQueue(cls, queue: 'Queue'[_checkedQueue__E], class_: _py_Type[_checkedQueue__E]) -> 'Queue'[_checkedQueue__E]: ...
    _checkedSet__E = _py_TypeVar('_checkedSet__E')  # <E>
    @classmethod
    def checkedSet(cls, set: 'Set'[_checkedSet__E], class_: _py_Type[_checkedSet__E]) -> 'Set'[_checkedSet__E]: ...
    _checkedSortedMap__K = _py_TypeVar('_checkedSortedMap__K')  # <K>
    _checkedSortedMap__V = _py_TypeVar('_checkedSortedMap__V')  # <V>
    @classmethod
    def checkedSortedMap(cls, sortedMap: 'SortedMap'[_checkedSortedMap__K, _checkedSortedMap__V], class_: _py_Type[_checkedSortedMap__K], class2: _py_Type[_checkedSortedMap__V]) -> 'SortedMap'[_checkedSortedMap__K, _checkedSortedMap__V]: ...
    _checkedSortedSet__E = _py_TypeVar('_checkedSortedSet__E')  # <E>
    @classmethod
    def checkedSortedSet(cls, sortedSet: 'SortedSet'[_checkedSortedSet__E], class_: _py_Type[_checkedSortedSet__E]) -> 'SortedSet'[_checkedSortedSet__E]: ...
    _copy__T = _py_TypeVar('_copy__T')  # <T>
    @classmethod
    def copy(cls, list: 'List'[_copy__T], list2: 'List'[_copy__T]) -> None: ...
    @classmethod
    def disjoint(cls, collection: Collection[_py_Any], collection2: Collection[_py_Any]) -> bool: ...
    _emptyEnumeration__T = _py_TypeVar('_emptyEnumeration__T')  # <T>
    @classmethod
    def emptyEnumeration(cls) -> 'Enumeration'[_emptyEnumeration__T]: ...
    _emptyIterator__T = _py_TypeVar('_emptyIterator__T')  # <T>
    @classmethod
    def emptyIterator(cls) -> 'Iterator'[_emptyIterator__T]: ...
    _emptyList__T = _py_TypeVar('_emptyList__T')  # <T>
    @classmethod
    def emptyList(cls) -> 'List'[_emptyList__T]: ...
    _emptyListIterator__T = _py_TypeVar('_emptyListIterator__T')  # <T>
    @classmethod
    def emptyListIterator(cls) -> 'ListIterator'[_emptyListIterator__T]: ...
    _emptyMap__K = _py_TypeVar('_emptyMap__K')  # <K>
    _emptyMap__V = _py_TypeVar('_emptyMap__V')  # <V>
    @classmethod
    def emptyMap(cls) -> 'Map'[_emptyMap__K, _emptyMap__V]: ...
    _emptyNavigableMap__K = _py_TypeVar('_emptyNavigableMap__K')  # <K>
    _emptyNavigableMap__V = _py_TypeVar('_emptyNavigableMap__V')  # <V>
    @classmethod
    def emptyNavigableMap(cls) -> 'NavigableMap'[_emptyNavigableMap__K, _emptyNavigableMap__V]: ...
    _emptyNavigableSet__E = _py_TypeVar('_emptyNavigableSet__E')  # <E>
    @classmethod
    def emptyNavigableSet(cls) -> 'NavigableSet'[_emptyNavigableSet__E]: ...
    _emptySet__T = _py_TypeVar('_emptySet__T')  # <T>
    @classmethod
    def emptySet(cls) -> 'Set'[_emptySet__T]: ...
    _emptySortedMap__K = _py_TypeVar('_emptySortedMap__K')  # <K>
    _emptySortedMap__V = _py_TypeVar('_emptySortedMap__V')  # <V>
    @classmethod
    def emptySortedMap(cls) -> 'SortedMap'[_emptySortedMap__K, _emptySortedMap__V]: ...
    _emptySortedSet__E = _py_TypeVar('_emptySortedSet__E')  # <E>
    @classmethod
    def emptySortedSet(cls) -> 'SortedSet'[_emptySortedSet__E]: ...
    _enumeration__T = _py_TypeVar('_enumeration__T')  # <T>
    @classmethod
    def enumeration(cls, collection: Collection[_enumeration__T]) -> 'Enumeration'[_enumeration__T]: ...
    _fill__T = _py_TypeVar('_fill__T')  # <T>
    @classmethod
    def fill(cls, list: 'List'[_fill__T], t: _fill__T) -> None: ...
    @classmethod
    def frequency(cls, collection: Collection[_py_Any], object: _py_Any) -> int: ...
    @classmethod
    def indexOfSubList(cls, list: 'List'[_py_Any], list2: 'List'[_py_Any]) -> int: ...
    @classmethod
    def lastIndexOfSubList(cls, list: 'List'[_py_Any], list2: 'List'[_py_Any]) -> int: ...
    _list__T = _py_TypeVar('_list__T')  # <T>
    @classmethod
    def list(cls, enumeration: 'Enumeration'[_list__T]) -> 'ArrayList'[_list__T]: ...
    _max_0__T = _py_TypeVar('_max_0__T')  # <T>
    @classmethod
    @overload
    def max(cls, collection: Collection[_max_0__T]) -> _max_0__T: ...
    _max_1__T = _py_TypeVar('_max_1__T')  # <T>
    @classmethod
    @overload
    def max(cls, collection: Collection[_max_1__T], comparator: 'Comparator'[_max_1__T]) -> _max_1__T: ...
    _min_0__T = _py_TypeVar('_min_0__T')  # <T>
    @classmethod
    @overload
    def min(cls, collection: Collection[_min_0__T]) -> _min_0__T: ...
    _min_1__T = _py_TypeVar('_min_1__T')  # <T>
    @classmethod
    @overload
    def min(cls, collection: Collection[_min_1__T], comparator: 'Comparator'[_min_1__T]) -> _min_1__T: ...
    _nCopies__T = _py_TypeVar('_nCopies__T')  # <T>
    @classmethod
    def nCopies(cls, int: int, t: _nCopies__T) -> 'List'[_nCopies__T]: ...
    _newSetFromMap__E = _py_TypeVar('_newSetFromMap__E')  # <E>
    @classmethod
    def newSetFromMap(cls, map: 'Map'[_newSetFromMap__E, bool]) -> 'Set'[_newSetFromMap__E]: ...
    _replaceAll__T = _py_TypeVar('_replaceAll__T')  # <T>
    @classmethod
    def replaceAll(cls, list: 'List'[_replaceAll__T], t: _replaceAll__T, t2: _replaceAll__T) -> bool: ...
    @classmethod
    def reverse(cls, list: 'List'[_py_Any]) -> None: ...
    _reverseOrder_0__T = _py_TypeVar('_reverseOrder_0__T')  # <T>
    @classmethod
    @overload
    def reverseOrder(cls) -> 'Comparator'[_reverseOrder_0__T]: ...
    _reverseOrder_1__T = _py_TypeVar('_reverseOrder_1__T')  # <T>
    @classmethod
    @overload
    def reverseOrder(cls, comparator: 'Comparator'[_reverseOrder_1__T]) -> 'Comparator'[_reverseOrder_1__T]: ...
    @classmethod
    def rotate(cls, list: 'List'[_py_Any], int: int) -> None: ...
    @classmethod
    @overload
    def shuffle(cls, list: 'List'[_py_Any]) -> None: ...
    @classmethod
    @overload
    def shuffle(cls, list: 'List'[_py_Any], random: 'Random') -> None: ...
    _singleton__T = _py_TypeVar('_singleton__T')  # <T>
    @classmethod
    def singleton(cls, t: _singleton__T) -> 'Set'[_singleton__T]: ...
    _singletonList__T = _py_TypeVar('_singletonList__T')  # <T>
    @classmethod
    def singletonList(cls, t: _singletonList__T) -> 'List'[_singletonList__T]: ...
    _singletonMap__K = _py_TypeVar('_singletonMap__K')  # <K>
    _singletonMap__V = _py_TypeVar('_singletonMap__V')  # <V>
    @classmethod
    def singletonMap(cls, k: _singletonMap__K, v: _singletonMap__V) -> 'Map'[_singletonMap__K, _singletonMap__V]: ...
    _sort_0__T = _py_TypeVar('_sort_0__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    @overload
    def sort(cls, list: 'List'[_sort_0__T]) -> None: ...
    _sort_1__T = _py_TypeVar('_sort_1__T')  # <T>
    @classmethod
    @overload
    def sort(cls, list: 'List'[_sort_1__T], comparator: 'Comparator'[_sort_1__T]) -> None: ...
    @classmethod
    def swap(cls, list: 'List'[_py_Any], int: int, int2: int) -> None: ...
    _synchronizedCollection__T = _py_TypeVar('_synchronizedCollection__T')  # <T>
    @classmethod
    def synchronizedCollection(cls, collection: Collection[_synchronizedCollection__T]) -> Collection[_synchronizedCollection__T]: ...
    _synchronizedList__T = _py_TypeVar('_synchronizedList__T')  # <T>
    @classmethod
    def synchronizedList(cls, list: 'List'[_synchronizedList__T]) -> 'List'[_synchronizedList__T]: ...
    _synchronizedMap__K = _py_TypeVar('_synchronizedMap__K')  # <K>
    _synchronizedMap__V = _py_TypeVar('_synchronizedMap__V')  # <V>
    @classmethod
    def synchronizedMap(cls, map: 'Map'[_synchronizedMap__K, _synchronizedMap__V]) -> 'Map'[_synchronizedMap__K, _synchronizedMap__V]: ...
    _synchronizedNavigableMap__K = _py_TypeVar('_synchronizedNavigableMap__K')  # <K>
    _synchronizedNavigableMap__V = _py_TypeVar('_synchronizedNavigableMap__V')  # <V>
    @classmethod
    def synchronizedNavigableMap(cls, navigableMap: 'NavigableMap'[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V]) -> 'NavigableMap'[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V]: ...
    _synchronizedNavigableSet__T = _py_TypeVar('_synchronizedNavigableSet__T')  # <T>
    @classmethod
    def synchronizedNavigableSet(cls, navigableSet: 'NavigableSet'[_synchronizedNavigableSet__T]) -> 'NavigableSet'[_synchronizedNavigableSet__T]: ...
    _synchronizedSet__T = _py_TypeVar('_synchronizedSet__T')  # <T>
    @classmethod
    def synchronizedSet(cls, set: 'Set'[_synchronizedSet__T]) -> 'Set'[_synchronizedSet__T]: ...
    _synchronizedSortedMap__K = _py_TypeVar('_synchronizedSortedMap__K')  # <K>
    _synchronizedSortedMap__V = _py_TypeVar('_synchronizedSortedMap__V')  # <V>
    @classmethod
    def synchronizedSortedMap(cls, sortedMap: 'SortedMap'[_synchronizedSortedMap__K, _synchronizedSortedMap__V]) -> 'SortedMap'[_synchronizedSortedMap__K, _synchronizedSortedMap__V]: ...
    _synchronizedSortedSet__T = _py_TypeVar('_synchronizedSortedSet__T')  # <T>
    @classmethod
    def synchronizedSortedSet(cls, sortedSet: 'SortedSet'[_synchronizedSortedSet__T]) -> 'SortedSet'[_synchronizedSortedSet__T]: ...
    _unmodifiableCollection__T = _py_TypeVar('_unmodifiableCollection__T')  # <T>
    @classmethod
    def unmodifiableCollection(cls, collection: Collection[_unmodifiableCollection__T]) -> Collection[_unmodifiableCollection__T]: ...
    _unmodifiableList__T = _py_TypeVar('_unmodifiableList__T')  # <T>
    @classmethod
    def unmodifiableList(cls, list: 'List'[_unmodifiableList__T]) -> 'List'[_unmodifiableList__T]: ...
    _unmodifiableMap__K = _py_TypeVar('_unmodifiableMap__K')  # <K>
    _unmodifiableMap__V = _py_TypeVar('_unmodifiableMap__V')  # <V>
    @classmethod
    def unmodifiableMap(cls, map: 'Map'[_unmodifiableMap__K, _unmodifiableMap__V]) -> 'Map'[_unmodifiableMap__K, _unmodifiableMap__V]: ...
    _unmodifiableNavigableMap__K = _py_TypeVar('_unmodifiableNavigableMap__K')  # <K>
    _unmodifiableNavigableMap__V = _py_TypeVar('_unmodifiableNavigableMap__V')  # <V>
    @classmethod
    def unmodifiableNavigableMap(cls, navigableMap: 'NavigableMap'[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V]) -> 'NavigableMap'[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V]: ...
    _unmodifiableNavigableSet__T = _py_TypeVar('_unmodifiableNavigableSet__T')  # <T>
    @classmethod
    def unmodifiableNavigableSet(cls, navigableSet: 'NavigableSet'[_unmodifiableNavigableSet__T]) -> 'NavigableSet'[_unmodifiableNavigableSet__T]: ...
    _unmodifiableSet__T = _py_TypeVar('_unmodifiableSet__T')  # <T>
    @classmethod
    def unmodifiableSet(cls, set: 'Set'[_unmodifiableSet__T]) -> 'Set'[_unmodifiableSet__T]: ...
    _unmodifiableSortedMap__K = _py_TypeVar('_unmodifiableSortedMap__K')  # <K>
    _unmodifiableSortedMap__V = _py_TypeVar('_unmodifiableSortedMap__V')  # <V>
    @classmethod
    def unmodifiableSortedMap(cls, sortedMap: 'SortedMap'[_unmodifiableSortedMap__K, _unmodifiableSortedMap__V]) -> 'SortedMap'[_unmodifiableSortedMap__K, _unmodifiableSortedMap__V]: ...
    _unmodifiableSortedSet__T = _py_TypeVar('_unmodifiableSortedSet__T')  # <T>
    @classmethod
    def unmodifiableSortedSet(cls, sortedSet: 'SortedSet'[_unmodifiableSortedSet__T]) -> 'SortedSet'[_unmodifiableSortedSet__T]: ...

class ComparableTimSort: ...

_Comparator__T = _py_TypeVar('_Comparator__T')  # <T>
class Comparator(_py_Generic[_Comparator__T]):
    def compare(self, t: _Comparator__T, t2: _Comparator__T) -> int: ...
    _comparing_0__T = _py_TypeVar('_comparing_0__T')  # <T>
    _comparing_0__U = _py_TypeVar('_comparing_0__U', bound=java.lang.Comparable)  # <U>
    @classmethod
    @overload
    def comparing(cls, function: java.util.function.Function[_comparing_0__T, _comparing_0__U]) -> 'Comparator'[_comparing_0__T]: ...
    _comparing_1__T = _py_TypeVar('_comparing_1__T')  # <T>
    _comparing_1__U = _py_TypeVar('_comparing_1__U')  # <U>
    @classmethod
    @overload
    def comparing(cls, function: java.util.function.Function[_comparing_1__T, _comparing_1__U], comparator: 'Comparator'[_comparing_1__U]) -> 'Comparator'[_comparing_1__T]: ...
    _comparingDouble__T = _py_TypeVar('_comparingDouble__T')  # <T>
    @classmethod
    def comparingDouble(cls, toDoubleFunction: java.util.function.ToDoubleFunction[_comparingDouble__T]) -> 'Comparator'[_comparingDouble__T]: ...
    _comparingInt__T = _py_TypeVar('_comparingInt__T')  # <T>
    @classmethod
    def comparingInt(cls, toIntFunction: java.util.function.ToIntFunction[_comparingInt__T]) -> 'Comparator'[_comparingInt__T]: ...
    _comparingLong__T = _py_TypeVar('_comparingLong__T')  # <T>
    @classmethod
    def comparingLong(cls, toLongFunction: java.util.function.ToLongFunction[_comparingLong__T]) -> 'Comparator'[_comparingLong__T]: ...
    def equals(self, object: _py_Any) -> bool: ...
    _naturalOrder__T = _py_TypeVar('_naturalOrder__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    def naturalOrder(cls) -> 'Comparator'[_naturalOrder__T]: ...
    _nullsFirst__T = _py_TypeVar('_nullsFirst__T')  # <T>
    @classmethod
    def nullsFirst(cls, comparator: 'Comparator'[_nullsFirst__T]) -> 'Comparator'[_nullsFirst__T]: ...
    _nullsLast__T = _py_TypeVar('_nullsLast__T')  # <T>
    @classmethod
    def nullsLast(cls, comparator: 'Comparator'[_nullsLast__T]) -> 'Comparator'[_nullsLast__T]: ...
    _reverseOrder__T = _py_TypeVar('_reverseOrder__T', bound=java.lang.Comparable)  # <T>
    @classmethod
    def reverseOrder(cls) -> 'Comparator'[_reverseOrder__T]: ...
    def reversed(self) -> 'Comparator'[_Comparator__T]: ...
    @overload
    def thenComparing(self, comparator: 'Comparator'[_Comparator__T]) -> 'Comparator'[_Comparator__T]: ...
    _thenComparing_1__U = _py_TypeVar('_thenComparing_1__U', bound=java.lang.Comparable)  # <U>
    @overload
    def thenComparing(self, function: java.util.function.Function[_Comparator__T, _thenComparing_1__U]) -> 'Comparator'[_Comparator__T]: ...
    _thenComparing_2__U = _py_TypeVar('_thenComparing_2__U')  # <U>
    @overload
    def thenComparing(self, function: java.util.function.Function[_Comparator__T, _thenComparing_2__U], comparator: 'Comparator'[_thenComparing_2__U]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingDouble(self, toDoubleFunction: java.util.function.ToDoubleFunction[_Comparator__T]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingInt(self, toIntFunction: java.util.function.ToIntFunction[_Comparator__T]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingLong(self, toLongFunction: java.util.function.ToLongFunction[_Comparator__T]) -> 'Comparator'[_Comparator__T]: ...

class Comparators: ...

class ConcurrentModificationException(java.lang.RuntimeException):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...
    @overload
    def __init__(self, throwable: java.lang.Throwable): ...

class Currency(java.io.Serializable):
    @classmethod
    def getAvailableCurrencies(cls) -> 'Set'['Currency']: ...
    def getCurrencyCode(self) -> str: ...
    def getDefaultFractionDigits(self) -> int: ...
    @overload
    def getDisplayName(self) -> str: ...
    @overload
    def getDisplayName(self, locale: 'Locale') -> str: ...
    @classmethod
    @overload
    def getInstance(cls, string: str) -> 'Currency': ...
    @classmethod
    @overload
    def getInstance(cls, locale: 'Locale') -> 'Currency': ...
    def getNumericCode(self) -> int: ...
    @overload
    def getSymbol(self) -> str: ...
    @overload
    def getSymbol(self, locale: 'Locale') -> str: ...
    def toString(self) -> str: ...

class Date(java.io.Serializable, java.lang.Cloneable, java.lang.Comparable['Date']):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, long: int): ...
    @classmethod
    def UTC(cls, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    def after(self, date: 'Date') -> bool: ...
    def before(self, date: 'Date') -> bool: ...
    def clone(self) -> _py_Any: ...
    @overload
    def compareTo(self, object: _py_Any) -> int: ...
    @overload
    def compareTo(self, date: 'Date') -> int: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getDate(self) -> int: ...
    def getDay(self) -> int: ...
    def getHours(self) -> int: ...
    def getMinutes(self) -> int: ...
    def getMonth(self) -> int: ...
    def getSeconds(self) -> int: ...
    def getTime(self) -> int: ...
    def getTimezoneOffset(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    @classmethod
    def parse(cls, string: str) -> int: ...
    def setDate(self, int: int) -> None: ...
    def setHours(self, int: int) -> None: ...
    def setMinutes(self, int: int) -> None: ...
    def setMonth(self, int: int) -> None: ...
    def setSeconds(self, int: int) -> None: ...
    def setTime(self, long: int) -> None: ...
    def setYear(self, int: int) -> None: ...
    def toGMTString(self) -> str: ...
    def toInstant(self) -> java.time.Instant: ...
    def toLocaleString(self) -> str: ...
    def toString(self) -> str: ...

_Dictionary__K = _py_TypeVar('_Dictionary__K')  # <K>
_Dictionary__V = _py_TypeVar('_Dictionary__V')  # <V>
class Dictionary(_py_Generic[_Dictionary__K, _Dictionary__V]):
    def __init__(self): ...
    def elements(self) -> 'Enumeration'[_Dictionary__V]: ...
    def get(self, object: _py_Any) -> _Dictionary__V: ...
    def isEmpty(self) -> bool: ...
    def keys(self) -> 'Enumeration'[_Dictionary__K]: ...
    def put(self, k: _Dictionary__K, v: _Dictionary__V) -> _Dictionary__V: ...
    def remove(self, object: _py_Any) -> _Dictionary__V: ...
    def size(self) -> int: ...

class DoubleSummaryStatistics(java.util.function.DoubleConsumer):
    def __init__(self): ...
    def accept(self, double: float) -> None: ...
    def combine(self, doubleSummaryStatistics: 'DoubleSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> float: ...
    def getMin(self) -> float: ...
    def getSum(self) -> float: ...
    def toString(self) -> str: ...

class DualPivotQuicksort: ...

class EmptyStackException(java.lang.RuntimeException):
    def __init__(self): ...

_Enumeration__E = _py_TypeVar('_Enumeration__E')  # <E>
class Enumeration(_py_Generic[_Enumeration__E]):
    def hasMoreElements(self) -> bool: ...
    def nextElement(self) -> _Enumeration__E: ...

class EventListener: ...

class EventObject(java.io.Serializable):
    def __init__(self, object: _py_Any): ...
    def getSource(self) -> _py_Any: ...
    def toString(self) -> str: ...

class Formattable:
    def formatTo(self, formatter: 'Formatter', int: int, int2: int, int3: int) -> None: ...

class FormattableFlags:
    LEFT_JUSTIFY: _py_ClassVar[int] = ...
    UPPERCASE: _py_ClassVar[int] = ...
    ALTERNATE: _py_ClassVar[int] = ...

class Formatter(java.io.Closeable, java.io.Flushable):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, file: java.io.File): ...
    @overload
    def __init__(self, file: java.io.File, string: str): ...
    @overload
    def __init__(self, file: java.io.File, string: str, locale: 'Locale'): ...
    @overload
    def __init__(self, outputStream: java.io.OutputStream): ...
    @overload
    def __init__(self, outputStream: java.io.OutputStream, string: str): ...
    @overload
    def __init__(self, outputStream: java.io.OutputStream, string: str, locale: 'Locale'): ...
    @overload
    def __init__(self, printStream: java.io.PrintStream): ...
    @overload
    def __init__(self, appendable: java.lang.Appendable): ...
    @overload
    def __init__(self, appendable: java.lang.Appendable, locale: 'Locale'): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, string2: str): ...
    @overload
    def __init__(self, string: str, string2: str, locale: 'Locale'): ...
    @overload
    def __init__(self, locale: 'Locale'): ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @overload
    def format(self, string: str, objectArray: _py_List[_py_Any]) -> 'Formatter': ...
    @overload
    def format(self, locale: 'Locale', string: str, objectArray: _py_List[_py_Any]) -> 'Formatter': ...
    def ioException(self) -> java.io.IOException: ...
    def locale(self) -> 'Locale': ...
    def out(self) -> java.lang.Appendable: ...
    def toString(self) -> str: ...
    class BigDecimalLayoutForm(java.lang.Enum['Formatter.BigDecimalLayoutForm']):
        SCIENTIFIC: _py_ClassVar['Formatter.BigDecimalLayoutForm'] = ...
        DECIMAL_FLOAT: _py_ClassVar['Formatter.BigDecimalLayoutForm'] = ...
        _valueOf_0__T = _py_TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @overload
        def valueOf(cls, class_: _py_Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @classmethod
        @overload
        def valueOf(cls, string: str) -> 'Formatter.BigDecimalLayoutForm': ...
        @classmethod
        def values(cls) -> _py_List['Formatter.BigDecimalLayoutForm']: ...

class FormatterClosedException(java.lang.IllegalStateException):
    def __init__(self): ...

class IllegalFormatException(java.lang.IllegalArgumentException): ...

class IllformedLocaleException(java.lang.RuntimeException):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, int: int): ...
    def getErrorIndex(self) -> int: ...

class IntSummaryStatistics(java.util.function.IntConsumer):
    def __init__(self): ...
    def accept(self, int: int) -> None: ...
    def combine(self, intSummaryStatistics: 'IntSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> int: ...
    def getMin(self) -> int: ...
    def getSum(self) -> int: ...
    def toString(self) -> str: ...

class InvalidPropertiesFormatException(java.io.IOException):
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, throwable: java.lang.Throwable): ...

_Iterator__E = _py_TypeVar('_Iterator__E')  # <E>
class Iterator(_py_Generic[_Iterator__E]):
    def forEachRemaining(self, consumer: java.util.function.Consumer[_Iterator__E]) -> None: ...
    def hasNext(self) -> bool: ...
    def next(self) -> _Iterator__E: ...
    def remove(self) -> None: ...

class Locale(java.lang.Cloneable, java.io.Serializable):
    ENGLISH: _py_ClassVar['Locale'] = ...
    FRENCH: _py_ClassVar['Locale'] = ...
    GERMAN: _py_ClassVar['Locale'] = ...
    ITALIAN: _py_ClassVar['Locale'] = ...
    JAPANESE: _py_ClassVar['Locale'] = ...
    KOREAN: _py_ClassVar['Locale'] = ...
    CHINESE: _py_ClassVar['Locale'] = ...
    SIMPLIFIED_CHINESE: _py_ClassVar['Locale'] = ...
    TRADITIONAL_CHINESE: _py_ClassVar['Locale'] = ...
    FRANCE: _py_ClassVar['Locale'] = ...
    GERMANY: _py_ClassVar['Locale'] = ...
    ITALY: _py_ClassVar['Locale'] = ...
    JAPAN: _py_ClassVar['Locale'] = ...
    KOREA: _py_ClassVar['Locale'] = ...
    CHINA: _py_ClassVar['Locale'] = ...
    PRC: _py_ClassVar['Locale'] = ...
    TAIWAN: _py_ClassVar['Locale'] = ...
    UK: _py_ClassVar['Locale'] = ...
    US: _py_ClassVar['Locale'] = ...
    CANADA: _py_ClassVar['Locale'] = ...
    CANADA_FRENCH: _py_ClassVar['Locale'] = ...
    ROOT: _py_ClassVar['Locale'] = ...
    PRIVATE_USE_EXTENSION: _py_ClassVar[str] = ...
    UNICODE_LOCALE_EXTENSION: _py_ClassVar[str] = ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, string2: str): ...
    @overload
    def __init__(self, string: str, string2: str, string3: str): ...
    def clone(self) -> _py_Any: ...
    def equals(self, object: _py_Any) -> bool: ...
    @classmethod
    @overload
    def filter(cls, list: 'List'['Locale.LanguageRange'], collection: Collection['Locale']) -> 'List'['Locale']: ...
    @classmethod
    @overload
    def filter(cls, list: 'List'['Locale.LanguageRange'], collection: Collection['Locale'], filteringMode: 'Locale.FilteringMode') -> 'List'['Locale']: ...
    @classmethod
    @overload
    def filterTags(cls, list: 'List'['Locale.LanguageRange'], collection: Collection[str]) -> 'List'[str]: ...
    @classmethod
    @overload
    def filterTags(cls, list: 'List'['Locale.LanguageRange'], collection: Collection[str], filteringMode: 'Locale.FilteringMode') -> 'List'[str]: ...
    @classmethod
    def forLanguageTag(cls, string: str) -> 'Locale': ...
    @classmethod
    def getAvailableLocales(cls) -> _py_List['Locale']: ...
    def getCountry(self) -> str: ...
    @classmethod
    @overload
    def getDefault(cls) -> 'Locale': ...
    @classmethod
    @overload
    def getDefault(cls, category: 'Locale.Category') -> 'Locale': ...
    @overload
    def getDisplayCountry(self) -> str: ...
    @overload
    def getDisplayCountry(self, locale: 'Locale') -> str: ...
    @overload
    def getDisplayLanguage(self) -> str: ...
    @overload
    def getDisplayLanguage(self, locale: 'Locale') -> str: ...
    @overload
    def getDisplayName(self) -> str: ...
    @overload
    def getDisplayName(self, locale: 'Locale') -> str: ...
    @overload
    def getDisplayScript(self) -> str: ...
    @overload
    def getDisplayScript(self, locale: 'Locale') -> str: ...
    @overload
    def getDisplayVariant(self) -> str: ...
    @overload
    def getDisplayVariant(self, locale: 'Locale') -> str: ...
    def getExtension(self, char: str) -> str: ...
    def getExtensionKeys(self) -> 'Set'[str]: ...
    def getISO3Country(self) -> str: ...
    def getISO3Language(self) -> str: ...
    @classmethod
    def getISOCountries(cls) -> _py_List[str]: ...
    @classmethod
    def getISOLanguages(cls) -> _py_List[str]: ...
    def getLanguage(self) -> str: ...
    def getScript(self) -> str: ...
    def getUnicodeLocaleAttributes(self) -> 'Set'[str]: ...
    def getUnicodeLocaleKeys(self) -> 'Set'[str]: ...
    def getUnicodeLocaleType(self, string: str) -> str: ...
    def getVariant(self) -> str: ...
    def hasExtensions(self) -> bool: ...
    def hashCode(self) -> int: ...
    @classmethod
    def lookup(cls, list: 'List'['Locale.LanguageRange'], collection: Collection['Locale']) -> 'Locale': ...
    @classmethod
    def lookupTag(cls, list: 'List'['Locale.LanguageRange'], collection: Collection[str]) -> str: ...
    @classmethod
    @overload
    def setDefault(cls, category: 'Locale.Category', locale: 'Locale') -> None: ...
    @classmethod
    @overload
    def setDefault(cls, locale: 'Locale') -> None: ...
    def stripExtensions(self) -> 'Locale': ...
    def toLanguageTag(self) -> str: ...
    def toString(self) -> str: ...
    class Builder:
        def __init__(self): ...
        def addUnicodeLocaleAttribute(self, string: str) -> 'Locale.Builder': ...
        def build(self) -> 'Locale': ...
        def clear(self) -> 'Locale.Builder': ...
        def clearExtensions(self) -> 'Locale.Builder': ...
        def removeUnicodeLocaleAttribute(self, string: str) -> 'Locale.Builder': ...
        def setExtension(self, char: str, string: str) -> 'Locale.Builder': ...
        def setLanguage(self, string: str) -> 'Locale.Builder': ...
        def setLanguageTag(self, string: str) -> 'Locale.Builder': ...
        def setLocale(self, locale: 'Locale') -> 'Locale.Builder': ...
        def setRegion(self, string: str) -> 'Locale.Builder': ...
        def setScript(self, string: str) -> 'Locale.Builder': ...
        def setUnicodeLocaleKeyword(self, string: str, string2: str) -> 'Locale.Builder': ...
        def setVariant(self, string: str) -> 'Locale.Builder': ...
    class Category(java.lang.Enum['Locale.Category']):
        DISPLAY: _py_ClassVar['Locale.Category'] = ...
        FORMAT: _py_ClassVar['Locale.Category'] = ...
        _valueOf_0__T = _py_TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @overload
        def valueOf(cls, class_: _py_Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @classmethod
        @overload
        def valueOf(cls, string: str) -> 'Locale.Category': ...
        @classmethod
        def values(cls) -> _py_List['Locale.Category']: ...
    class FilteringMode(java.lang.Enum['Locale.FilteringMode']):
        AUTOSELECT_FILTERING: _py_ClassVar['Locale.FilteringMode'] = ...
        EXTENDED_FILTERING: _py_ClassVar['Locale.FilteringMode'] = ...
        IGNORE_EXTENDED_RANGES: _py_ClassVar['Locale.FilteringMode'] = ...
        MAP_EXTENDED_RANGES: _py_ClassVar['Locale.FilteringMode'] = ...
        REJECT_EXTENDED_RANGES: _py_ClassVar['Locale.FilteringMode'] = ...
        _valueOf_0__T = _py_TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @classmethod
        @overload
        def valueOf(cls, class_: _py_Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @classmethod
        @overload
        def valueOf(cls, string: str) -> 'Locale.FilteringMode': ...
        @classmethod
        def values(cls) -> _py_List['Locale.FilteringMode']: ...
    class LanguageRange:
        MAX_WEIGHT: _py_ClassVar[float] = ...
        MIN_WEIGHT: _py_ClassVar[float] = ...
        @overload
        def __init__(self, string: str): ...
        @overload
        def __init__(self, string: str, double: float): ...
        def equals(self, object: _py_Any) -> bool: ...
        def getRange(self) -> str: ...
        def getWeight(self) -> float: ...
        def hashCode(self) -> int: ...
        @classmethod
        def mapEquivalents(cls, list: 'List'['Locale.LanguageRange'], map: 'Map'[str, 'List'[str]]) -> 'List'['Locale.LanguageRange']: ...
        @classmethod
        @overload
        def parse(cls, string: str) -> 'List'['Locale.LanguageRange']: ...
        @classmethod
        @overload
        def parse(cls, string: str, map: 'Map'[str, 'List'[str]]) -> 'List'['Locale.LanguageRange']: ...

class LocaleISOData: ...

class LongSummaryStatistics(java.util.function.LongConsumer, java.util.function.IntConsumer):
    def __init__(self): ...
    @overload
    def accept(self, int: int) -> None: ...
    @overload
    def accept(self, long: int) -> None: ...
    def combine(self, longSummaryStatistics: 'LongSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> int: ...
    def getMin(self) -> int: ...
    def getSum(self) -> int: ...
    def toString(self) -> str: ...

_Map__Entry__K = _py_TypeVar('_Map__Entry__K')  # <K>
_Map__Entry__V = _py_TypeVar('_Map__Entry__V')  # <V>
_Map__K = _py_TypeVar('_Map__K')  # <K>
_Map__V = _py_TypeVar('_Map__V')  # <V>
class Map(_py_Generic[_Map__K, _Map__V], _py_Mapping[_Map__K, _Map__V]):
    def clear(self) -> None: ...
    def compute(self, k: _Map__K, biFunction: java.util.function.BiFunction[_Map__K, _Map__V, _Map__V]) -> _Map__V: ...
    def computeIfAbsent(self, k: _Map__K, function: java.util.function.Function[_Map__K, _Map__V]) -> _Map__V: ...
    def computeIfPresent(self, k: _Map__K, biFunction: java.util.function.BiFunction[_Map__K, _Map__V, _Map__V]) -> _Map__V: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> 'Set'['Map.Entry'[_Map__K, _Map__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_Map__K, _Map__V]) -> None: ...
    def get(self, object: _py_Any) -> _Map__V: ...
    def getOrDefault(self, object: _py_Any, v: _Map__V) -> _Map__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'Set'[_Map__K]: ...
    def merge(self, k: _Map__K, v: _Map__V, biFunction: java.util.function.BiFunction[_Map__V, _Map__V, _Map__V]) -> _Map__V: ...
    def put(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    def putAll(self, map: 'Map'[_Map__K, _Map__V]) -> None: ...
    def putIfAbsent(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    @overload
    def remove(self, object: _py_Any) -> _Map__V: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def replace(self, k: _Map__K, v: _Map__V, v2: _Map__V) -> bool: ...
    @overload
    def replace(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_Map__K, _Map__V, _Map__V]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_Map__V]: ...
    class Entry(_py_Generic[_Map__Entry__K, _Map__Entry__V]):
        _comparingByKey_0__K = _py_TypeVar('_comparingByKey_0__K', bound=java.lang.Comparable)  # <K>
        _comparingByKey_0__V = _py_TypeVar('_comparingByKey_0__V')  # <V>
        @classmethod
        @overload
        def comparingByKey(cls) -> Comparator['Map.Entry'[_comparingByKey_0__K, _comparingByKey_0__V]]: ...
        _comparingByKey_1__K = _py_TypeVar('_comparingByKey_1__K')  # <K>
        _comparingByKey_1__V = _py_TypeVar('_comparingByKey_1__V')  # <V>
        @classmethod
        @overload
        def comparingByKey(cls, comparator: Comparator[_comparingByKey_1__K]) -> Comparator['Map.Entry'[_comparingByKey_1__K, _comparingByKey_1__V]]: ...
        _comparingByValue_0__K = _py_TypeVar('_comparingByValue_0__K')  # <K>
        _comparingByValue_0__V = _py_TypeVar('_comparingByValue_0__V', bound=java.lang.Comparable)  # <V>
        @classmethod
        @overload
        def comparingByValue(cls) -> Comparator['Map.Entry'[_comparingByValue_0__K, _comparingByValue_0__V]]: ...
        _comparingByValue_1__K = _py_TypeVar('_comparingByValue_1__K')  # <K>
        _comparingByValue_1__V = _py_TypeVar('_comparingByValue_1__V')  # <V>
        @classmethod
        @overload
        def comparingByValue(cls, comparator: Comparator[_comparingByValue_1__V]) -> Comparator['Map.Entry'[_comparingByValue_1__K, _comparingByValue_1__V]]: ...
        def equals(self, object: _py_Any) -> bool: ...
        def getKey(self) -> _Map__Entry__K: ...
        def getValue(self) -> _Map__Entry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _Map__Entry__V) -> _Map__Entry__V: ...

class MissingResourceException(java.lang.RuntimeException):
    def __init__(self, string: str, string2: str, string3: str): ...
    def getClassName(self) -> str: ...
    def getKey(self) -> str: ...

class NoSuchElementException(java.lang.RuntimeException):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str): ...

class Objects:
    _compare__T = _py_TypeVar('_compare__T')  # <T>
    @classmethod
    def compare(cls, t: _compare__T, t2: _compare__T, comparator: Comparator[_compare__T]) -> int: ...
    @classmethod
    def deepEquals(cls, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def equals(self, object: _py_Any) -> bool: ...
    @classmethod
    @overload
    def equals(cls, object: _py_Any, object2: _py_Any) -> bool: ...
    @classmethod
    def hash(cls, objectArray: _py_List[_py_Any]) -> int: ...
    @overload
    def hashCode(self) -> int: ...
    @classmethod
    @overload
    def hashCode(cls, object: _py_Any) -> int: ...
    @classmethod
    def isNull(cls, object: _py_Any) -> bool: ...
    @classmethod
    def nonNull(cls, object: _py_Any) -> bool: ...
    _requireNonNull_0__T = _py_TypeVar('_requireNonNull_0__T')  # <T>
    @classmethod
    @overload
    def requireNonNull(cls, t: _requireNonNull_0__T) -> _requireNonNull_0__T: ...
    _requireNonNull_1__T = _py_TypeVar('_requireNonNull_1__T')  # <T>
    @classmethod
    @overload
    def requireNonNull(cls, t: _requireNonNull_1__T, string: str) -> _requireNonNull_1__T: ...
    _requireNonNull_2__T = _py_TypeVar('_requireNonNull_2__T')  # <T>
    @classmethod
    @overload
    def requireNonNull(cls, t: _requireNonNull_2__T, supplier: java.util.function.Supplier[str]) -> _requireNonNull_2__T: ...
    @overload
    def toString(self) -> str: ...
    @classmethod
    @overload
    def toString(cls, object: _py_Any) -> str: ...
    @classmethod
    @overload
    def toString(cls, object: _py_Any, string: str) -> str: ...

class Observable:
    def __init__(self): ...
    def addObserver(self, observer: 'Observer') -> None: ...
    def countObservers(self) -> int: ...
    def deleteObserver(self, observer: 'Observer') -> None: ...
    def deleteObservers(self) -> None: ...
    def hasChanged(self) -> bool: ...
    @overload
    def notifyObservers(self) -> None: ...
    @overload
    def notifyObservers(self, object: _py_Any) -> None: ...

class Observer:
    def update(self, observable: Observable, object: _py_Any) -> None: ...

_Optional__T = _py_TypeVar('_Optional__T')  # <T>
class Optional(_py_Generic[_Optional__T]):
    _empty__T = _py_TypeVar('_empty__T')  # <T>
    @classmethod
    def empty(cls) -> 'Optional'[_empty__T]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def filter(self, predicate: java.util.function.Predicate[_Optional__T]) -> 'Optional'[_Optional__T]: ...
    _flatMap__U = _py_TypeVar('_flatMap__U')  # <U>
    def flatMap(self, function: java.util.function.Function[_Optional__T, 'Optional'[_flatMap__U]]) -> 'Optional'[_flatMap__U]: ...
    def get(self) -> _Optional__T: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, consumer: java.util.function.Consumer[_Optional__T]) -> None: ...
    def isPresent(self) -> bool: ...
    _map__U = _py_TypeVar('_map__U')  # <U>
    def map(self, function: java.util.function.Function[_Optional__T, _map__U]) -> 'Optional'[_map__U]: ...
    _of__T = _py_TypeVar('_of__T')  # <T>
    @classmethod
    def of(cls, t: _of__T) -> 'Optional'[_of__T]: ...
    _ofNullable__T = _py_TypeVar('_ofNullable__T')  # <T>
    @classmethod
    def ofNullable(cls, t: _ofNullable__T) -> 'Optional'[_ofNullable__T]: ...
    def orElse(self, t: _Optional__T) -> _Optional__T: ...
    def orElseGet(self, supplier: java.util.function.Supplier[_Optional__T]) -> _Optional__T: ...
    _orElseThrow__X = _py_TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: java.util.function.Supplier[_orElseThrow__X]) -> _Optional__T: ...
    def toString(self) -> str: ...

class OptionalDouble:
    @classmethod
    def empty(cls) -> 'OptionalDouble': ...
    def equals(self, object: _py_Any) -> bool: ...
    def getAsDouble(self) -> float: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, doubleConsumer: java.util.function.DoubleConsumer) -> None: ...
    def isPresent(self) -> bool: ...
    @classmethod
    def of(cls, double: float) -> 'OptionalDouble': ...
    def orElse(self, double: float) -> float: ...
    def orElseGet(self, doubleSupplier: java.util.function.DoubleSupplier) -> float: ...
    _orElseThrow__X = _py_TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: java.util.function.Supplier[_orElseThrow__X]) -> float: ...
    def toString(self) -> str: ...

class OptionalInt:
    @classmethod
    def empty(cls) -> 'OptionalInt': ...
    def equals(self, object: _py_Any) -> bool: ...
    def getAsInt(self) -> int: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, intConsumer: java.util.function.IntConsumer) -> None: ...
    def isPresent(self) -> bool: ...
    @classmethod
    def of(cls, int: int) -> 'OptionalInt': ...
    def orElse(self, int: int) -> int: ...
    def orElseGet(self, intSupplier: java.util.function.IntSupplier) -> int: ...
    _orElseThrow__X = _py_TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: java.util.function.Supplier[_orElseThrow__X]) -> int: ...
    def toString(self) -> str: ...

class OptionalLong:
    @classmethod
    def empty(cls) -> 'OptionalLong': ...
    def equals(self, object: _py_Any) -> bool: ...
    def getAsLong(self) -> int: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, longConsumer: java.util.function.LongConsumer) -> None: ...
    def isPresent(self) -> bool: ...
    @classmethod
    def of(cls, long: int) -> 'OptionalLong': ...
    def orElse(self, long: int) -> int: ...
    def orElseGet(self, longSupplier: java.util.function.LongSupplier) -> int: ...
    _orElseThrow__X = _py_TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: java.util.function.Supplier[_orElseThrow__X]) -> int: ...
    def toString(self) -> str: ...

class PropertyPermission(java.security.BasicPermission):
    def __init__(self, string: str, string2: str): ...
    def equals(self, object: _py_Any) -> bool: ...
    def getActions(self) -> str: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: java.security.Permission) -> bool: ...
    def newPermissionCollection(self) -> java.security.PermissionCollection: ...

class PropertyPermissionCollection(java.security.PermissionCollection, java.io.Serializable):
    def __init__(self): ...
    def add(self, permission: java.security.Permission) -> None: ...
    def elements(self) -> Enumeration[java.security.Permission]: ...
    def implies(self, permission: java.security.Permission) -> bool: ...

class Random(java.io.Serializable):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, long: int): ...
    @overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self, long: int) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self, long: int, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @overload
    def ints(self) -> java.util.stream.IntStream: ...
    @overload
    def ints(self, int: int, int2: int) -> java.util.stream.IntStream: ...
    @overload
    def ints(self, long: int) -> java.util.stream.IntStream: ...
    @overload
    def ints(self, long: int, int: int, int2: int) -> java.util.stream.IntStream: ...
    @overload
    def longs(self) -> java.util.stream.LongStream: ...
    @overload
    def longs(self, long: int) -> java.util.stream.LongStream: ...
    @overload
    def longs(self, long: int, long2: int) -> java.util.stream.LongStream: ...
    @overload
    def longs(self, long: int, long2: int, long3: int) -> java.util.stream.LongStream: ...
    def nextBoolean(self) -> bool: ...
    def nextBytes(self, byteArray: _py_List[int]) -> None: ...
    def nextDouble(self) -> float: ...
    def nextFloat(self) -> float: ...
    def nextGaussian(self) -> float: ...
    @overload
    def nextInt(self) -> int: ...
    @overload
    def nextInt(self, int: int) -> int: ...
    def nextLong(self) -> int: ...
    def setSeed(self, long: int) -> None: ...

class RandomAccess: ...

class ResourceBundle:
    def __init__(self): ...
    @classmethod
    @overload
    def clearCache(cls) -> None: ...
    @classmethod
    @overload
    def clearCache(cls, classLoader: java.lang.ClassLoader) -> None: ...
    def containsKey(self, string: str) -> bool: ...
    def getBaseBundleName(self) -> str: ...
    @classmethod
    @overload
    def getBundle(cls, string: str) -> 'ResourceBundle': ...
    @classmethod
    @overload
    def getBundle(cls, string: str, locale: Locale) -> 'ResourceBundle': ...
    @classmethod
    @overload
    def getBundle(cls, string: str, locale: Locale, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    @classmethod
    @overload
    def getBundle(cls, string: str, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    @classmethod
    @overload
    def getBundle(cls, string: str, locale: Locale, classLoader: java.lang.ClassLoader) -> 'ResourceBundle': ...
    @classmethod
    @overload
    def getBundle(cls, string: str, locale: Locale, classLoader: java.lang.ClassLoader, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    def getKeys(self) -> Enumeration[str]: ...
    def getLocale(self) -> Locale: ...
    def getObject(self, string: str) -> _py_Any: ...
    def getString(self, string: str) -> str: ...
    def getStringArray(self, string: str) -> _py_List[str]: ...
    def keySet(self) -> 'Set'[str]: ...
    class Control:
        FORMAT_DEFAULT: _py_ClassVar['List'] = ...
        FORMAT_CLASS: _py_ClassVar['List'] = ...
        FORMAT_PROPERTIES: _py_ClassVar['List'] = ...
        TTL_DONT_CACHE: _py_ClassVar[int] = ...
        TTL_NO_EXPIRATION_CONTROL: _py_ClassVar[int] = ...
        def getCandidateLocales(self, string: str, locale: Locale) -> 'List'[Locale]: ...
        @classmethod
        def getControl(cls, list: 'List'[str]) -> 'ResourceBundle.Control': ...
        def getFallbackLocale(self, string: str, locale: Locale) -> Locale: ...
        def getFormats(self, string: str) -> 'List'[str]: ...
        @classmethod
        def getNoFallbackControl(cls, list: 'List'[str]) -> 'ResourceBundle.Control': ...
        def getTimeToLive(self, string: str, locale: Locale) -> int: ...
        def needsReload(self, string: str, locale: Locale, string2: str, classLoader: java.lang.ClassLoader, resourceBundle: 'ResourceBundle', long: int) -> bool: ...
        def newBundle(self, string: str, locale: Locale, string2: str, classLoader: java.lang.ClassLoader, boolean: bool) -> 'ResourceBundle': ...
        def toBundleName(self, string: str, locale: Locale) -> str: ...
        def toResourceName(self, string: str, string2: str) -> str: ...

class ServiceConfigurationError(java.lang.Error):
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...

_ServiceLoader__S = _py_TypeVar('_ServiceLoader__S')  # <S>
class ServiceLoader(java.lang.Iterable[_ServiceLoader__S], _py_Generic[_ServiceLoader__S]):
    def iterator(self) -> Iterator[_ServiceLoader__S]: ...
    _load_0__S = _py_TypeVar('_load_0__S')  # <S>
    @classmethod
    @overload
    def load(cls, class_: _py_Type[_load_0__S]) -> 'ServiceLoader'[_load_0__S]: ...
    _load_1__S = _py_TypeVar('_load_1__S')  # <S>
    @classmethod
    @overload
    def load(cls, class_: _py_Type[_load_1__S], classLoader: java.lang.ClassLoader) -> 'ServiceLoader'[_load_1__S]: ...
    _loadInstalled__S = _py_TypeVar('_loadInstalled__S')  # <S>
    @classmethod
    def loadInstalled(cls, class_: _py_Type[_loadInstalled__S]) -> 'ServiceLoader'[_loadInstalled__S]: ...
    def reload(self) -> None: ...
    def toString(self) -> str: ...

class SplittableRandom:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, long: int): ...
    @overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self, long: int) -> java.util.stream.DoubleStream: ...
    @overload
    def doubles(self, long: int, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @overload
    def ints(self) -> java.util.stream.IntStream: ...
    @overload
    def ints(self, int: int, int2: int) -> java.util.stream.IntStream: ...
    @overload
    def ints(self, long: int) -> java.util.stream.IntStream: ...
    @overload
    def ints(self, long: int, int: int, int2: int) -> java.util.stream.IntStream: ...
    @overload
    def longs(self) -> java.util.stream.LongStream: ...
    @overload
    def longs(self, long: int) -> java.util.stream.LongStream: ...
    @overload
    def longs(self, long: int, long2: int) -> java.util.stream.LongStream: ...
    @overload
    def longs(self, long: int, long2: int, long3: int) -> java.util.stream.LongStream: ...
    def nextBoolean(self) -> bool: ...
    @overload
    def nextDouble(self) -> float: ...
    @overload
    def nextDouble(self, double: float) -> float: ...
    @overload
    def nextDouble(self, double: float, double2: float) -> float: ...
    @overload
    def nextInt(self) -> int: ...
    @overload
    def nextInt(self, int: int) -> int: ...
    @overload
    def nextInt(self, int: int, int2: int) -> int: ...
    @overload
    def nextLong(self) -> int: ...
    @overload
    def nextLong(self, long: int) -> int: ...
    @overload
    def nextLong(self, long: int, long2: int) -> int: ...
    def split(self) -> 'SplittableRandom': ...

class StringJoiner:
    @overload
    def __init__(self, charSequence: java.lang.CharSequence): ...
    @overload
    def __init__(self, charSequence: java.lang.CharSequence, charSequence2: java.lang.CharSequence, charSequence3: java.lang.CharSequence): ...
    def add(self, charSequence: java.lang.CharSequence) -> 'StringJoiner': ...
    def length(self) -> int: ...
    def merge(self, stringJoiner: 'StringJoiner') -> 'StringJoiner': ...
    def setEmptyValue(self, charSequence: java.lang.CharSequence) -> 'StringJoiner': ...
    def toString(self) -> str: ...

class TaskQueue: ...

_TimSort__T = _py_TypeVar('_TimSort__T')  # <T>
class TimSort(_py_Generic[_TimSort__T]): ...

class TimeZone(java.io.Serializable, java.lang.Cloneable):
    SHORT: _py_ClassVar[int] = ...
    LONG: _py_ClassVar[int] = ...
    def __init__(self): ...
    def clone(self) -> _py_Any: ...
    @classmethod
    @overload
    def getAvailableIDs(cls) -> _py_List[str]: ...
    @classmethod
    @overload
    def getAvailableIDs(cls, int: int) -> _py_List[str]: ...
    def getDSTSavings(self) -> int: ...
    @classmethod
    def getDefault(cls) -> 'TimeZone': ...
    @overload
    def getDisplayName(self) -> str: ...
    @overload
    def getDisplayName(self, boolean: bool, int: int) -> str: ...
    @overload
    def getDisplayName(self, locale: Locale) -> str: ...
    @overload
    def getDisplayName(self, boolean: bool, int: int, locale: Locale) -> str: ...
    def getID(self) -> str: ...
    @overload
    def getOffset(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    @overload
    def getOffset(self, long: int) -> int: ...
    def getRawOffset(self) -> int: ...
    @classmethod
    @overload
    def getTimeZone(cls, zoneId: java.time.ZoneId) -> 'TimeZone': ...
    @classmethod
    @overload
    def getTimeZone(cls, string: str) -> 'TimeZone': ...
    def hasSameRules(self, timeZone: 'TimeZone') -> bool: ...
    def inDaylightTime(self, date: Date) -> bool: ...
    def observesDaylightTime(self) -> bool: ...
    @classmethod
    def setDefault(cls, timeZone: 'TimeZone') -> None: ...
    def setID(self, string: str) -> None: ...
    def setRawOffset(self, int: int) -> None: ...
    def toZoneId(self) -> java.time.ZoneId: ...
    def useDaylightTime(self) -> bool: ...

class Timer:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, boolean: bool): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, boolean: bool): ...
    def cancel(self) -> None: ...
    def purge(self) -> int: ...
    @overload
    def schedule(self, timerTask: 'TimerTask', date: Date) -> None: ...
    @overload
    def schedule(self, timerTask: 'TimerTask', date: Date, long: int) -> None: ...
    @overload
    def schedule(self, timerTask: 'TimerTask', long: int) -> None: ...
    @overload
    def schedule(self, timerTask: 'TimerTask', long: int, long2: int) -> None: ...
    @overload
    def scheduleAtFixedRate(self, timerTask: 'TimerTask', date: Date, long: int) -> None: ...
    @overload
    def scheduleAtFixedRate(self, timerTask: 'TimerTask', long: int, long2: int) -> None: ...

class TimerTask(java.lang.Runnable):
    def cancel(self) -> bool: ...
    def run(self) -> None: ...
    def scheduledExecutionTime(self) -> int: ...

class TimerThread(java.lang.Thread):
    def run(self) -> None: ...

class TooManyListenersException(java.lang.Exception):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str): ...

class Tripwire: ...

class UUID(java.io.Serializable, java.lang.Comparable['UUID']):
    def __init__(self, long: int, long2: int): ...
    def clockSequence(self) -> int: ...
    @overload
    def compareTo(self, object: _py_Any) -> int: ...
    @overload
    def compareTo(self, uUID: 'UUID') -> int: ...
    def equals(self, object: _py_Any) -> bool: ...
    @classmethod
    def fromString(cls, string: str) -> 'UUID': ...
    def getLeastSignificantBits(self) -> int: ...
    def getMostSignificantBits(self) -> int: ...
    def hashCode(self) -> int: ...
    @classmethod
    def nameUUIDFromBytes(cls, byteArray: _py_List[int]) -> 'UUID': ...
    def node(self) -> int: ...
    @classmethod
    def randomUUID(cls) -> 'UUID': ...
    def timestamp(self) -> int: ...
    def toString(self) -> str: ...
    def variant(self) -> int: ...
    def version(self) -> int: ...

_AbstractCollection__E = _py_TypeVar('_AbstractCollection__E')  # <E>
class AbstractCollection(Collection[_AbstractCollection__E], _py_Generic[_AbstractCollection__E]):
    def add(self, e: _AbstractCollection__E) -> bool: ...
    def addAll(self, collection: Collection[_AbstractCollection__E]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_AbstractCollection__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def size(self) -> int: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...
    def toString(self) -> str: ...

class DuplicateFormatFlagsException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

_EventListenerProxy__T = _py_TypeVar('_EventListenerProxy__T', bound=EventListener)  # <T>
class EventListenerProxy(EventListener, _py_Generic[_EventListenerProxy__T]):
    def __init__(self, t: _EventListenerProxy__T): ...
    def getListener(self) -> _EventListenerProxy__T: ...

class FormatFlagsConversionMismatchException(IllegalFormatException):
    def __init__(self, string: str, char: str): ...
    def getConversion(self) -> str: ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

class GregorianCalendar(Calendar):
    BC: _py_ClassVar[int] = ...
    AD: _py_ClassVar[int] = ...
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int): ...
    @overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int): ...
    @overload
    def __init__(self, locale: Locale): ...
    @overload
    def __init__(self, timeZone: TimeZone): ...
    @overload
    def __init__(self, timeZone: TimeZone, locale: Locale): ...
    def add(self, int: int, int2: int) -> None: ...
    def clone(self) -> _py_Any: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getActualMaximum(self, int: int) -> int: ...
    def getActualMinimum(self, int: int) -> int: ...
    def getCalendarType(self) -> str: ...
    def getGreatestMinimum(self, int: int) -> int: ...
    def getGregorianChange(self) -> Date: ...
    def getLeastMaximum(self, int: int) -> int: ...
    def getMaximum(self, int: int) -> int: ...
    def getMinimum(self, int: int) -> int: ...
    def getTimeZone(self) -> TimeZone: ...
    def getWeekYear(self) -> int: ...
    def getWeeksInWeekYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isLeapYear(self, int: int) -> bool: ...
    def isWeekDateSupported(self) -> bool: ...
    @overload
    def roll(self, int: int, boolean: bool) -> None: ...
    @overload
    def roll(self, int: int, int2: int) -> None: ...
    def setGregorianChange(self, date: Date) -> None: ...
    def setTimeZone(self, timeZone: TimeZone) -> None: ...
    def setWeekDate(self, int: int, int2: int, int3: int) -> None: ...
    def toZonedDateTime(self) -> java.time.ZonedDateTime: ...

_Hashtable__K = _py_TypeVar('_Hashtable__K')  # <K>
_Hashtable__V = _py_TypeVar('_Hashtable__V')  # <V>
class Hashtable(Dictionary[_Hashtable__K, _Hashtable__V], Map[_Hashtable__K, _Hashtable__V], java.lang.Cloneable, java.io.Serializable, _py_Generic[_Hashtable__K, _Hashtable__V]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, float: float): ...
    @overload
    def __init__(self, map: Map[_Hashtable__K, _Hashtable__V]): ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def compute(self, k: _Hashtable__K, biFunction: java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V]) -> _Hashtable__V: ...
    def computeIfAbsent(self, k: _Hashtable__K, function: java.util.function.Function[_Hashtable__K, _Hashtable__V]) -> _Hashtable__V: ...
    def computeIfPresent(self, k: _Hashtable__K, biFunction: java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V]) -> _Hashtable__V: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def elements(self) -> Enumeration[_Hashtable__V]: ...
    def entrySet(self) -> 'Set'[Map.Entry[_Hashtable__K, _Hashtable__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_Hashtable__K, _Hashtable__V]) -> None: ...
    def get(self, object: _py_Any) -> _Hashtable__V: ...
    def getOrDefault(self, object: _py_Any, v: _Hashtable__V) -> _Hashtable__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'Set'[_Hashtable__K]: ...
    def keys(self) -> Enumeration[_Hashtable__K]: ...
    def merge(self, k: _Hashtable__K, v: _Hashtable__V, biFunction: java.util.function.BiFunction[_Hashtable__V, _Hashtable__V, _Hashtable__V]) -> _Hashtable__V: ...
    def put(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    def putAll(self, map: Map[_Hashtable__K, _Hashtable__V]) -> None: ...
    def putIfAbsent(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def remove(self, object: _py_Any) -> _Hashtable__V: ...
    @overload
    def replace(self, k: _Hashtable__K, v: _Hashtable__V, v2: _Hashtable__V) -> bool: ...
    @overload
    def replace(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V]) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def values(self) -> Collection[_Hashtable__V]: ...

class IllegalFormatCodePointException(IllegalFormatException):
    def __init__(self, int: int): ...
    def getCodePoint(self) -> int: ...
    def getMessage(self) -> str: ...

class IllegalFormatConversionException(IllegalFormatException):
    def __init__(self, char: str, class_: _py_Type[_py_Any]): ...
    def getArgumentClass(self) -> _py_Type[_py_Any]: ...
    def getConversion(self) -> str: ...
    def getMessage(self) -> str: ...

class IllegalFormatFlagsException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

class IllegalFormatPrecisionException(IllegalFormatException):
    def __init__(self, int: int): ...
    def getMessage(self) -> str: ...
    def getPrecision(self) -> int: ...

class IllegalFormatWidthException(IllegalFormatException):
    def __init__(self, int: int): ...
    def getMessage(self) -> str: ...
    def getWidth(self) -> int: ...

class InputMismatchException(NoSuchElementException):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, string: str): ...

class JapaneseImperialCalendar(Calendar):
    BEFORE_MEIJI: _py_ClassVar[int] = ...
    MEIJI: _py_ClassVar[int] = ...
    TAISHO: _py_ClassVar[int] = ...
    SHOWA: _py_ClassVar[int] = ...
    HEISEI: _py_ClassVar[int] = ...
    def add(self, int: int, int2: int) -> None: ...
    def clone(self) -> _py_Any: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getActualMaximum(self, int: int) -> int: ...
    def getActualMinimum(self, int: int) -> int: ...
    def getCalendarType(self) -> str: ...
    def getDisplayName(self, int: int, int2: int, locale: Locale) -> str: ...
    def getDisplayNames(self, int: int, int2: int, locale: Locale) -> Map[str, int]: ...
    def getGreatestMinimum(self, int: int) -> int: ...
    def getLeastMaximum(self, int: int) -> int: ...
    def getMaximum(self, int: int) -> int: ...
    def getMinimum(self, int: int) -> int: ...
    def getTimeZone(self) -> TimeZone: ...
    def hashCode(self) -> int: ...
    @overload
    def roll(self, int: int, boolean: bool) -> None: ...
    @overload
    def roll(self, int: int, int2: int) -> None: ...
    def setTimeZone(self, timeZone: TimeZone) -> None: ...

_List__E = _py_TypeVar('_List__E')  # <E>
class List(Collection[_List__E], _py_Generic[_List__E], _py_List[_List__E]):
    @overload
    def add(self, e: _List__E) -> bool: ...
    @overload
    def add(self, int: int, e: _List__E) -> None: ...
    @overload
    def addAll(self, int: int, collection: Collection[_List__E]) -> bool: ...
    @overload
    def addAll(self, collection: Collection[_List__E]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def equals(self, object: _py_Any) -> bool: ...
    def get(self, int: int) -> _List__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, object: _py_Any) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_List__E]: ...
    def lastIndexOf(self, object: _py_Any) -> int: ...
    @overload
    def listIterator(self) -> 'ListIterator'[_List__E]: ...
    @overload
    def listIterator(self, int: int) -> 'ListIterator'[_List__E]: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self, int: int) -> _List__E: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def replaceAll(self, unaryOperator: java.util.function.UnaryOperator[_List__E]) -> None: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def set(self, int: int, e: _List__E) -> _List__E: ...
    def size(self) -> int: ...
    def sort(self, comparator: Comparator[_List__E]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_List__E]: ...
    def subList(self, int: int, int2: int) -> 'List'[_List__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...

_ListIterator__E = _py_TypeVar('_ListIterator__E')  # <E>
class ListIterator(Iterator[_ListIterator__E], _py_Generic[_ListIterator__E]):
    def add(self, e: _ListIterator__E) -> None: ...
    def hasNext(self) -> bool: ...
    def hasPrevious(self) -> bool: ...
    def next(self) -> _ListIterator__E: ...
    def nextIndex(self) -> int: ...
    def previous(self) -> _ListIterator__E: ...
    def previousIndex(self) -> int: ...
    def remove(self) -> None: ...
    def set(self, e: _ListIterator__E) -> None: ...

class ListResourceBundle(ResourceBundle):
    def __init__(self): ...
    def getKeys(self) -> Enumeration[str]: ...
    def handleGetObject(self, string: str) -> _py_Any: ...

class MissingFormatArgumentException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFormatSpecifier(self) -> str: ...
    def getMessage(self) -> str: ...

class MissingFormatWidthException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFormatSpecifier(self) -> str: ...
    def getMessage(self) -> str: ...

class PropertyResourceBundle(ResourceBundle):
    @overload
    def __init__(self, inputStream: java.io.InputStream): ...
    @overload
    def __init__(self, reader: java.io.Reader): ...
    def getKeys(self) -> Enumeration[str]: ...
    def handleGetObject(self, string: str) -> _py_Any: ...

_Queue__E = _py_TypeVar('_Queue__E')  # <E>
class Queue(Collection[_Queue__E], _py_Generic[_Queue__E]):
    def add(self, e: _Queue__E) -> bool: ...
    def element(self) -> _Queue__E: ...
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def offer(self, e: _Queue__E) -> bool: ...
    def peek(self) -> _Queue__E: ...
    def poll(self) -> _Queue__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self) -> _Queue__E: ...

class Scanner(Iterator[str], java.io.Closeable):
    @overload
    def __init__(self, file: java.io.File): ...
    @overload
    def __init__(self, file: java.io.File, string: str): ...
    @overload
    def __init__(self, inputStream: java.io.InputStream): ...
    @overload
    def __init__(self, inputStream: java.io.InputStream, string: str): ...
    @overload
    def __init__(self, readable: java.lang.Readable): ...
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, readableByteChannel: java.nio.channels.ReadableByteChannel): ...
    @overload
    def __init__(self, readableByteChannel: java.nio.channels.ReadableByteChannel, string: str): ...
    @overload
    def __init__(self, path: java.nio.file.Path): ...
    @overload
    def __init__(self, path: java.nio.file.Path, string: str): ...
    def close(self) -> None: ...
    def delimiter(self) -> java.util.regex.Pattern: ...
    @overload
    def findInLine(self, string: str) -> str: ...
    @overload
    def findInLine(self, pattern: java.util.regex.Pattern) -> str: ...
    @overload
    def findWithinHorizon(self, string: str, int: int) -> str: ...
    @overload
    def findWithinHorizon(self, pattern: java.util.regex.Pattern, int: int) -> str: ...
    @overload
    def hasNext(self) -> bool: ...
    @overload
    def hasNext(self, string: str) -> bool: ...
    @overload
    def hasNext(self, pattern: java.util.regex.Pattern) -> bool: ...
    def hasNextBigDecimal(self) -> bool: ...
    @overload
    def hasNextBigInteger(self) -> bool: ...
    @overload
    def hasNextBigInteger(self, int: int) -> bool: ...
    def hasNextBoolean(self) -> bool: ...
    @overload
    def hasNextByte(self) -> bool: ...
    @overload
    def hasNextByte(self, int: int) -> bool: ...
    def hasNextDouble(self) -> bool: ...
    def hasNextFloat(self) -> bool: ...
    @overload
    def hasNextInt(self) -> bool: ...
    @overload
    def hasNextInt(self, int: int) -> bool: ...
    def hasNextLine(self) -> bool: ...
    @overload
    def hasNextLong(self) -> bool: ...
    @overload
    def hasNextLong(self, int: int) -> bool: ...
    @overload
    def hasNextShort(self) -> bool: ...
    @overload
    def hasNextShort(self, int: int) -> bool: ...
    def ioException(self) -> java.io.IOException: ...
    def locale(self) -> Locale: ...
    def match(self) -> java.util.regex.MatchResult: ...
    @overload
    def next(self) -> _py_Any: ...
    @overload
    def next(self) -> str: ...
    @overload
    def next(self, string: str) -> str: ...
    @overload
    def next(self, pattern: java.util.regex.Pattern) -> str: ...
    def nextBigDecimal(self) -> java.math.BigDecimal: ...
    @overload
    def nextBigInteger(self) -> java.math.BigInteger: ...
    @overload
    def nextBigInteger(self, int: int) -> java.math.BigInteger: ...
    def nextBoolean(self) -> bool: ...
    @overload
    def nextByte(self) -> int: ...
    @overload
    def nextByte(self, int: int) -> int: ...
    def nextDouble(self) -> float: ...
    def nextFloat(self) -> float: ...
    @overload
    def nextInt(self) -> int: ...
    @overload
    def nextInt(self, int: int) -> int: ...
    def nextLine(self) -> str: ...
    @overload
    def nextLong(self) -> int: ...
    @overload
    def nextLong(self, int: int) -> int: ...
    @overload
    def nextShort(self) -> int: ...
    @overload
    def nextShort(self, int: int) -> int: ...
    def radix(self) -> int: ...
    def remove(self) -> None: ...
    def reset(self) -> 'Scanner': ...
    @overload
    def skip(self, string: str) -> 'Scanner': ...
    @overload
    def skip(self, pattern: java.util.regex.Pattern) -> 'Scanner': ...
    def toString(self) -> str: ...
    @overload
    def useDelimiter(self, string: str) -> 'Scanner': ...
    @overload
    def useDelimiter(self, pattern: java.util.regex.Pattern) -> 'Scanner': ...
    def useLocale(self, locale: Locale) -> 'Scanner': ...
    def useRadix(self, int: int) -> 'Scanner': ...

_Set__E = _py_TypeVar('_Set__E')  # <E>
class Set(Collection[_Set__E], _py_Generic[_Set__E], _py_Set[_Set__E]):
    def add(self, e: _Set__E) -> bool: ...
    def addAll(self, collection: Collection[_Set__E]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_Set__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_Set__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...

class SimpleTimeZone(TimeZone):
    WALL_TIME: _py_ClassVar[int] = ...
    STANDARD_TIME: _py_ClassVar[int] = ...
    UTC_TIME: _py_ClassVar[int] = ...
    @overload
    def __init__(self, int: int, string: str): ...
    @overload
    def __init__(self, int: int, string: str, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int): ...
    @overload
    def __init__(self, int: int, string: str, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int, int10: int): ...
    @overload
    def __init__(self, int: int, string: str, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int, int10: int, int11: int, int12: int): ...
    def clone(self) -> _py_Any: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getDSTSavings(self) -> int: ...
    @overload
    def getOffset(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    @overload
    def getOffset(self, long: int) -> int: ...
    def getRawOffset(self) -> int: ...
    def hasSameRules(self, timeZone: TimeZone) -> bool: ...
    def hashCode(self) -> int: ...
    def inDaylightTime(self, date: Date) -> bool: ...
    def observesDaylightTime(self) -> bool: ...
    def setDSTSavings(self, int: int) -> None: ...
    @overload
    def setEndRule(self, int: int, int2: int, int3: int) -> None: ...
    @overload
    def setEndRule(self, int: int, int2: int, int3: int, int4: int) -> None: ...
    @overload
    def setEndRule(self, int: int, int2: int, int3: int, int4: int, boolean: bool) -> None: ...
    def setRawOffset(self, int: int) -> None: ...
    @overload
    def setStartRule(self, int: int, int2: int, int3: int) -> None: ...
    @overload
    def setStartRule(self, int: int, int2: int, int3: int, int4: int) -> None: ...
    @overload
    def setStartRule(self, int: int, int2: int, int3: int, int4: int, boolean: bool) -> None: ...
    def setStartYear(self, int: int) -> None: ...
    def toString(self) -> str: ...
    def useDaylightTime(self) -> bool: ...

_SortedMap__K = _py_TypeVar('_SortedMap__K')  # <K>
_SortedMap__V = _py_TypeVar('_SortedMap__V')  # <V>
class SortedMap(Map[_SortedMap__K, _SortedMap__V], _py_Generic[_SortedMap__K, _SortedMap__V]):
    def comparator(self) -> Comparator[_SortedMap__K]: ...
    def entrySet(self) -> Set[Map.Entry[_SortedMap__K, _SortedMap__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def firstKey(self) -> _SortedMap__K: ...
    def hashCode(self) -> int: ...
    def headMap(self, k: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def keySet(self) -> Set[_SortedMap__K]: ...
    def lastKey(self) -> _SortedMap__K: ...
    def subMap(self, k: _SortedMap__K, k2: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def tailMap(self, k: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def values(self) -> Collection[_SortedMap__V]: ...

class StringTokenizer(Enumeration[_py_Any]):
    @overload
    def __init__(self, string: str): ...
    @overload
    def __init__(self, string: str, string2: str): ...
    @overload
    def __init__(self, string: str, string2: str, boolean: bool): ...
    def countTokens(self) -> int: ...
    def hasMoreElements(self) -> bool: ...
    def hasMoreTokens(self) -> bool: ...
    def nextElement(self) -> _py_Any: ...
    @overload
    def nextToken(self) -> str: ...
    @overload
    def nextToken(self, string: str) -> str: ...

class UnknownFormatConversionException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getConversion(self) -> str: ...
    def getMessage(self) -> str: ...

class UnknownFormatFlagsException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

_AbstractList__E = _py_TypeVar('_AbstractList__E')  # <E>
class AbstractList(AbstractCollection[_AbstractList__E], List[_AbstractList__E], _py_Generic[_AbstractList__E]):
    @overload
    def add(self, e: _AbstractList__E) -> bool: ...
    @overload
    def add(self, int: int, e: _AbstractList__E) -> None: ...
    @overload
    def addAll(self, collection: Collection[_AbstractList__E]) -> bool: ...
    @overload
    def addAll(self, int: int, collection: Collection[_AbstractList__E]) -> bool: ...
    def clear(self) -> None: ...
    def equals(self, object: _py_Any) -> bool: ...
    def get(self, int: int) -> _AbstractList__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, object: _py_Any) -> int: ...
    def iterator(self) -> Iterator[_AbstractList__E]: ...
    def lastIndexOf(self, object: _py_Any) -> int: ...
    @overload
    def listIterator(self) -> ListIterator[_AbstractList__E]: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_AbstractList__E]: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self, int: int) -> _AbstractList__E: ...
    def set(self, int: int, e: _AbstractList__E) -> _AbstractList__E: ...
    def subList(self, int: int, int2: int) -> List[_AbstractList__E]: ...

_AbstractQueue__E = _py_TypeVar('_AbstractQueue__E')  # <E>
class AbstractQueue(AbstractCollection[_AbstractQueue__E], Queue[_AbstractQueue__E], _py_Generic[_AbstractQueue__E]):
    def add(self, e: _AbstractQueue__E) -> bool: ...
    def addAll(self, collection: Collection[_AbstractQueue__E]) -> bool: ...
    def clear(self) -> None: ...
    def element(self) -> _AbstractQueue__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self) -> _AbstractQueue__E: ...

_AbstractSet__E = _py_TypeVar('_AbstractSet__E')  # <E>
class AbstractSet(AbstractCollection[_AbstractSet__E], Set[_AbstractSet__E], _py_Generic[_AbstractSet__E]):
    def equals(self, object: _py_Any) -> bool: ...
    def hashCode(self) -> int: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...

_Deque__E = _py_TypeVar('_Deque__E')  # <E>
class Deque(Queue[_Deque__E], _py_Generic[_Deque__E]):
    def add(self, e: _Deque__E) -> bool: ...
    def addFirst(self, e: _Deque__E) -> None: ...
    def addLast(self, e: _Deque__E) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_Deque__E]: ...
    def element(self) -> _Deque__E: ...
    def equals(self, object: _py_Any) -> bool: ...
    def getFirst(self) -> _Deque__E: ...
    def getLast(self) -> _Deque__E: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> Iterator[_Deque__E]: ...
    def offer(self, e: _Deque__E) -> bool: ...
    def offerFirst(self, e: _Deque__E) -> bool: ...
    def offerLast(self, e: _Deque__E) -> bool: ...
    def peek(self) -> _Deque__E: ...
    def peekFirst(self) -> _Deque__E: ...
    def peekLast(self) -> _Deque__E: ...
    def poll(self) -> _Deque__E: ...
    def pollFirst(self) -> _Deque__E: ...
    def pollLast(self) -> _Deque__E: ...
    def pop(self) -> _Deque__E: ...
    def push(self, e: _Deque__E) -> None: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self) -> _Deque__E: ...
    def removeFirst(self) -> _Deque__E: ...
    def removeFirstOccurrence(self, object: _py_Any) -> bool: ...
    def removeLast(self) -> _Deque__E: ...
    def removeLastOccurrence(self, object: _py_Any) -> bool: ...
    def size(self) -> int: ...

_NavigableMap__K = _py_TypeVar('_NavigableMap__K')  # <K>
_NavigableMap__V = _py_TypeVar('_NavigableMap__V')  # <V>
class NavigableMap(SortedMap[_NavigableMap__K, _NavigableMap__V], _py_Generic[_NavigableMap__K, _NavigableMap__V]):
    def ceilingEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def ceilingKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def descendingKeySet(self) -> 'NavigableSet'[_NavigableMap__K]: ...
    def descendingMap(self) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def firstEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def floorEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def floorKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def hashCode(self) -> int: ...
    @overload
    def headMap(self, k: _NavigableMap__K, boolean: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @overload
    def headMap(self, k: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...
    def higherEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def higherKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def lastEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def lowerEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def lowerKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def navigableKeySet(self) -> 'NavigableSet'[_NavigableMap__K]: ...
    def pollFirstEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def pollLastEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    @overload
    def subMap(self, k: _NavigableMap__K, boolean: bool, k2: _NavigableMap__K, boolean2: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @overload
    def subMap(self, k: _NavigableMap__K, k2: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...
    @overload
    def tailMap(self, k: _NavigableMap__K, boolean: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @overload
    def tailMap(self, k: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...

class Properties(Hashtable[_py_Any, _py_Any]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, properties: 'Properties'): ...
    @overload
    def getProperty(self, string: str) -> str: ...
    @overload
    def getProperty(self, string: str, string2: str) -> str: ...
    @overload
    def list(self, printStream: java.io.PrintStream) -> None: ...
    @overload
    def list(self, printWriter: java.io.PrintWriter) -> None: ...
    @overload
    def load(self, inputStream: java.io.InputStream) -> None: ...
    @overload
    def load(self, reader: java.io.Reader) -> None: ...
    def loadFromXML(self, inputStream: java.io.InputStream) -> None: ...
    def propertyNames(self) -> Enumeration[_py_Any]: ...
    def save(self, outputStream: java.io.OutputStream, string: str) -> None: ...
    def setProperty(self, string: str, string2: str) -> _py_Any: ...
    @overload
    def store(self, outputStream: java.io.OutputStream, string: str) -> None: ...
    @overload
    def store(self, writer: java.io.Writer, string: str) -> None: ...
    @overload
    def storeToXML(self, outputStream: java.io.OutputStream, string: str) -> None: ...
    @overload
    def storeToXML(self, outputStream: java.io.OutputStream, string: str, string2: str) -> None: ...
    def stringPropertyNames(self) -> Set[str]: ...

_SortedSet__E = _py_TypeVar('_SortedSet__E')  # <E>
class SortedSet(Set[_SortedSet__E], _py_Generic[_SortedSet__E]):
    def comparator(self) -> Comparator[_SortedSet__E]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def first(self) -> _SortedSet__E: ...
    def hashCode(self) -> int: ...
    def headSet(self, e: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...
    def last(self) -> _SortedSet__E: ...
    def spliterator(self) -> 'Spliterator'[_SortedSet__E]: ...
    def subSet(self, e: _SortedSet__E, e2: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...
    def tailSet(self, e: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...

_AbstractSequentialList__E = _py_TypeVar('_AbstractSequentialList__E')  # <E>
class AbstractSequentialList(AbstractList[_AbstractSequentialList__E], _py_Generic[_AbstractSequentialList__E]):
    @overload
    def add(self, e: _AbstractSequentialList__E) -> bool: ...
    @overload
    def add(self, int: int, e: _AbstractSequentialList__E) -> None: ...
    @overload
    def addAll(self, collection: Collection[_AbstractSequentialList__E]) -> bool: ...
    @overload
    def addAll(self, int: int, collection: Collection[_AbstractSequentialList__E]) -> bool: ...
    def get(self, int: int) -> _AbstractSequentialList__E: ...
    def iterator(self) -> Iterator[_AbstractSequentialList__E]: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_AbstractSequentialList__E]: ...
    @overload
    def listIterator(self) -> ListIterator[_AbstractSequentialList__E]: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self, int: int) -> _AbstractSequentialList__E: ...
    def set(self, int: int, e: _AbstractSequentialList__E) -> _AbstractSequentialList__E: ...

_ArrayDeque__E = _py_TypeVar('_ArrayDeque__E')  # <E>
class ArrayDeque(AbstractCollection[_ArrayDeque__E], Deque[_ArrayDeque__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_ArrayDeque__E]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, collection: Collection[_ArrayDeque__E]): ...
    def add(self, e: _ArrayDeque__E) -> bool: ...
    def addFirst(self, e: _ArrayDeque__E) -> None: ...
    def addLast(self, e: _ArrayDeque__E) -> None: ...
    def clear(self) -> None: ...
    @overload
    def clone(self) -> _py_Any: ...
    @overload
    def clone(self) -> 'ArrayDeque'[_ArrayDeque__E]: ...
    def contains(self, object: _py_Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_ArrayDeque__E]: ...
    def element(self) -> _ArrayDeque__E: ...
    def getFirst(self) -> _ArrayDeque__E: ...
    def getLast(self) -> _ArrayDeque__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_ArrayDeque__E]: ...
    def offer(self, e: _ArrayDeque__E) -> bool: ...
    def offerFirst(self, e: _ArrayDeque__E) -> bool: ...
    def offerLast(self, e: _ArrayDeque__E) -> bool: ...
    def peek(self) -> _ArrayDeque__E: ...
    def peekFirst(self) -> _ArrayDeque__E: ...
    def peekLast(self) -> _ArrayDeque__E: ...
    def poll(self) -> _ArrayDeque__E: ...
    def pollFirst(self) -> _ArrayDeque__E: ...
    def pollLast(self) -> _ArrayDeque__E: ...
    def pop(self) -> _ArrayDeque__E: ...
    def push(self, e: _ArrayDeque__E) -> None: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self) -> _ArrayDeque__E: ...
    def removeFirst(self) -> _ArrayDeque__E: ...
    def removeFirstOccurrence(self, object: _py_Any) -> bool: ...
    def removeLast(self) -> _ArrayDeque__E: ...
    def removeLastOccurrence(self, object: _py_Any) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_ArrayDeque__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...

_ArrayList__E = _py_TypeVar('_ArrayList__E')  # <E>
class ArrayList(AbstractList[_ArrayList__E], List[_ArrayList__E], RandomAccess, java.lang.Cloneable, java.io.Serializable, _py_Generic[_ArrayList__E]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, collection: Collection[_ArrayList__E]): ...
    @overload
    def add(self, e: _ArrayList__E) -> bool: ...
    @overload
    def add(self, int: int, e: _ArrayList__E) -> None: ...
    @overload
    def addAll(self, int: int, collection: Collection[_ArrayList__E]) -> bool: ...
    @overload
    def addAll(self, collection: Collection[_ArrayList__E]) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def contains(self, object: _py_Any) -> bool: ...
    def ensureCapacity(self, int: int) -> None: ...
    def forEach(self, consumer: java.util.function.Consumer[_ArrayList__E]) -> None: ...
    def get(self, int: int) -> _ArrayList__E: ...
    def indexOf(self, object: _py_Any) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_ArrayList__E]: ...
    def lastIndexOf(self, object: _py_Any) -> int: ...
    @overload
    def listIterator(self) -> ListIterator[_ArrayList__E]: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_ArrayList__E]: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self, int: int) -> _ArrayList__E: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def removeIf(self, predicate: java.util.function.Predicate[_ArrayList__E]) -> bool: ...
    def replaceAll(self, unaryOperator: java.util.function.UnaryOperator[_ArrayList__E]) -> None: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def set(self, int: int, e: _ArrayList__E) -> _ArrayList__E: ...
    def size(self) -> int: ...
    def sort(self, comparator: Comparator[_ArrayList__E]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_ArrayList__E]: ...
    def subList(self, int: int, int2: int) -> List[_ArrayList__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...
    def trimToSize(self) -> None: ...

_EnumSet__E = _py_TypeVar('_EnumSet__E', bound=java.lang.Enum)  # <E>
class EnumSet(AbstractSet[_EnumSet__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_EnumSet__E]):
    _allOf__E = _py_TypeVar('_allOf__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def allOf(cls, class_: _py_Type[_allOf__E]) -> 'EnumSet'[_allOf__E]: ...
    @overload
    def clone(self) -> _py_Any: ...
    @overload
    def clone(self) -> 'EnumSet'[_EnumSet__E]: ...
    _complementOf__E = _py_TypeVar('_complementOf__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def complementOf(cls, enumSet: 'EnumSet'[_complementOf__E]) -> 'EnumSet'[_complementOf__E]: ...
    _copyOf_0__E = _py_TypeVar('_copyOf_0__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def copyOf(cls, collection: Collection[_copyOf_0__E]) -> 'EnumSet'[_copyOf_0__E]: ...
    _copyOf_1__E = _py_TypeVar('_copyOf_1__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def copyOf(cls, enumSet: 'EnumSet'[_copyOf_1__E]) -> 'EnumSet'[_copyOf_1__E]: ...
    _noneOf__E = _py_TypeVar('_noneOf__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def noneOf(cls, class_: _py_Type[_noneOf__E]) -> 'EnumSet'[_noneOf__E]: ...
    _of_0__E = _py_TypeVar('_of_0__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_0__E) -> 'EnumSet'[_of_0__E]: ...
    _of_1__E = _py_TypeVar('_of_1__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_1__E, e2: _of_1__E) -> 'EnumSet'[_of_1__E]: ...
    _of_2__E = _py_TypeVar('_of_2__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_2__E, e2: _of_2__E, e3: _of_2__E) -> 'EnumSet'[_of_2__E]: ...
    _of_3__E = _py_TypeVar('_of_3__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_3__E, e2: _of_3__E, e3: _of_3__E, e4: _of_3__E) -> 'EnumSet'[_of_3__E]: ...
    _of_4__E = _py_TypeVar('_of_4__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_4__E, e2: _of_4__E, e3: _of_4__E, e4: _of_4__E, e5: _of_4__E) -> 'EnumSet'[_of_4__E]: ...
    _of_5__E = _py_TypeVar('_of_5__E', bound=java.lang.Enum)  # <E>
    @classmethod
    @overload
    def of(cls, e: _of_5__E, eArray: _py_List[_of_5__E]) -> 'EnumSet'[_of_5__E]: ...
    _range__E = _py_TypeVar('_range__E', bound=java.lang.Enum)  # <E>
    @classmethod
    def range(cls, e: _range__E, e2: _range__E) -> 'EnumSet'[_range__E]: ...

_HashSet__E = _py_TypeVar('_HashSet__E')  # <E>
class HashSet(AbstractSet[_HashSet__E], Set[_HashSet__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_HashSet__E]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, float: float): ...
    @overload
    def __init__(self, collection: Collection[_HashSet__E]): ...
    def add(self, e: _HashSet__E) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def contains(self, object: _py_Any) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_HashSet__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_HashSet__E]: ...

_NavigableSet__E = _py_TypeVar('_NavigableSet__E')  # <E>
class NavigableSet(SortedSet[_NavigableSet__E], _py_Generic[_NavigableSet__E]):
    def ceiling(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def descendingIterator(self) -> Iterator[_NavigableSet__E]: ...
    def descendingSet(self) -> 'NavigableSet'[_NavigableSet__E]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def floor(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def hashCode(self) -> int: ...
    @overload
    def headSet(self, e: _NavigableSet__E, boolean: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    @overload
    def headSet(self, e: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...
    def higher(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def iterator(self) -> Iterator[_NavigableSet__E]: ...
    def lower(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def pollFirst(self) -> _NavigableSet__E: ...
    def pollLast(self) -> _NavigableSet__E: ...
    @overload
    def subSet(self, e: _NavigableSet__E, boolean: bool, e2: _NavigableSet__E, boolean2: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    @overload
    def subSet(self, e: _NavigableSet__E, e2: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...
    @overload
    def tailSet(self, e: _NavigableSet__E, boolean: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    @overload
    def tailSet(self, e: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...

_PriorityQueue__E = _py_TypeVar('_PriorityQueue__E')  # <E>
class PriorityQueue(AbstractQueue[_PriorityQueue__E], java.io.Serializable, _py_Generic[_PriorityQueue__E]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, comparator: Comparator[_PriorityQueue__E]): ...
    @overload
    def __init__(self, collection: Collection[_PriorityQueue__E]): ...
    @overload
    def __init__(self, comparator: Comparator[_PriorityQueue__E]): ...
    @overload
    def __init__(self, priorityQueue: 'PriorityQueue'[_PriorityQueue__E]): ...
    @overload
    def __init__(self, sortedSet: SortedSet[_PriorityQueue__E]): ...
    def add(self, e: _PriorityQueue__E) -> bool: ...
    def clear(self) -> None: ...
    def comparator(self) -> Comparator[_PriorityQueue__E]: ...
    def contains(self, object: _py_Any) -> bool: ...
    def iterator(self) -> Iterator[_PriorityQueue__E]: ...
    def offer(self, e: _PriorityQueue__E) -> bool: ...
    def peek(self) -> _PriorityQueue__E: ...
    def poll(self) -> _PriorityQueue__E: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self) -> _PriorityQueue__E: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_PriorityQueue__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...

_SubList__E = _py_TypeVar('_SubList__E')  # <E>
class SubList(AbstractList[_SubList__E], _py_Generic[_SubList__E]):
    @overload
    def add(self, e: _SubList__E) -> bool: ...
    @overload
    def add(self, int: int, e: _SubList__E) -> None: ...
    @overload
    def addAll(self, int: int, collection: Collection[_SubList__E]) -> bool: ...
    @overload
    def addAll(self, collection: Collection[_SubList__E]) -> bool: ...
    def get(self, int: int) -> _SubList__E: ...
    def iterator(self) -> Iterator[_SubList__E]: ...
    @overload
    def listIterator(self) -> ListIterator[_SubList__E]: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_SubList__E]: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self, int: int) -> _SubList__E: ...
    def set(self, int: int, e: _SubList__E) -> _SubList__E: ...
    def size(self) -> int: ...
    def subList(self, int: int, int2: int) -> List[_SubList__E]: ...

_Vector__E = _py_TypeVar('_Vector__E')  # <E>
class Vector(AbstractList[_Vector__E], List[_Vector__E], RandomAccess, java.lang.Cloneable, java.io.Serializable, _py_Generic[_Vector__E]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, int2: int): ...
    @overload
    def __init__(self, collection: Collection[_Vector__E]): ...
    @overload
    def add(self, e: _Vector__E) -> bool: ...
    @overload
    def add(self, int: int, e: _Vector__E) -> None: ...
    @overload
    def addAll(self, int: int, collection: Collection[_Vector__E]) -> bool: ...
    @overload
    def addAll(self, collection: Collection[_Vector__E]) -> bool: ...
    def addElement(self, e: _Vector__E) -> None: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def copyInto(self, objectArray: _py_List[_py_Any]) -> None: ...
    def elementAt(self, int: int) -> _Vector__E: ...
    def elements(self) -> Enumeration[_Vector__E]: ...
    def ensureCapacity(self, int: int) -> None: ...
    def equals(self, object: _py_Any) -> bool: ...
    def firstElement(self) -> _Vector__E: ...
    def forEach(self, consumer: java.util.function.Consumer[_Vector__E]) -> None: ...
    def get(self, int: int) -> _Vector__E: ...
    def hashCode(self) -> int: ...
    @overload
    def indexOf(self, object: _py_Any) -> int: ...
    @overload
    def indexOf(self, object: _py_Any, int: int) -> int: ...
    def insertElementAt(self, e: _Vector__E, int: int) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_Vector__E]: ...
    def lastElement(self) -> _Vector__E: ...
    @overload
    def lastIndexOf(self, object: _py_Any) -> int: ...
    @overload
    def lastIndexOf(self, object: _py_Any, int: int) -> int: ...
    @overload
    def listIterator(self) -> ListIterator[_Vector__E]: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_Vector__E]: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self, int: int) -> _Vector__E: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def removeAllElements(self) -> None: ...
    def removeElement(self, object: _py_Any) -> bool: ...
    def removeElementAt(self, int: int) -> None: ...
    def removeIf(self, predicate: java.util.function.Predicate[_Vector__E]) -> bool: ...
    def replaceAll(self, unaryOperator: java.util.function.UnaryOperator[_Vector__E]) -> None: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def set(self, int: int, e: _Vector__E) -> _Vector__E: ...
    def setElementAt(self, e: _Vector__E, int: int) -> None: ...
    def setSize(self, int: int) -> None: ...
    def size(self) -> int: ...
    def sort(self, comparator: Comparator[_Vector__E]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_Vector__E]: ...
    def subList(self, int: int, int2: int) -> List[_Vector__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...
    def toString(self) -> str: ...
    def trimToSize(self) -> None: ...

_JumboEnumSet__E = _py_TypeVar('_JumboEnumSet__E', bound=java.lang.Enum)  # <E>
class JumboEnumSet(EnumSet[_JumboEnumSet__E], _py_Generic[_JumboEnumSet__E]):
    @overload
    def add(self, e: _JumboEnumSet__E) -> bool: ...
    @overload
    def add(self, object: _py_Any) -> bool: ...
    def addAll(self, collection: Collection[_JumboEnumSet__E]) -> bool: ...
    def clear(self) -> None: ...
    @overload
    def clone(self) -> _py_Any: ...
    @overload
    def clone(self) -> EnumSet[_JumboEnumSet__E]: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def equals(self, object: _py_Any) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_JumboEnumSet__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def size(self) -> int: ...

_LinkedHashSet__E = _py_TypeVar('_LinkedHashSet__E')  # <E>
class LinkedHashSet(HashSet[_LinkedHashSet__E], Set[_LinkedHashSet__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_LinkedHashSet__E]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, float: float): ...
    @overload
    def __init__(self, collection: Collection[_LinkedHashSet__E]): ...
    def spliterator(self) -> 'Spliterator'[_LinkedHashSet__E]: ...

_LinkedList__E = _py_TypeVar('_LinkedList__E')  # <E>
class LinkedList(AbstractSequentialList[_LinkedList__E], List[_LinkedList__E], Deque[_LinkedList__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_LinkedList__E]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, collection: Collection[_LinkedList__E]): ...
    @overload
    def add(self, e: _LinkedList__E) -> bool: ...
    @overload
    def add(self, int: int, e: _LinkedList__E) -> None: ...
    @overload
    def addAll(self, int: int, collection: Collection[_LinkedList__E]) -> bool: ...
    @overload
    def addAll(self, collection: Collection[_LinkedList__E]) -> bool: ...
    def addFirst(self, e: _LinkedList__E) -> None: ...
    def addLast(self, e: _LinkedList__E) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def contains(self, object: _py_Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_LinkedList__E]: ...
    def element(self) -> _LinkedList__E: ...
    def get(self, int: int) -> _LinkedList__E: ...
    def getFirst(self) -> _LinkedList__E: ...
    def getLast(self) -> _LinkedList__E: ...
    def indexOf(self, object: _py_Any) -> int: ...
    def lastIndexOf(self, object: _py_Any) -> int: ...
    @overload
    def listIterator(self) -> ListIterator[_LinkedList__E]: ...
    @overload
    def listIterator(self, int: int) -> ListIterator[_LinkedList__E]: ...
    def offer(self, e: _LinkedList__E) -> bool: ...
    def offerFirst(self, e: _LinkedList__E) -> bool: ...
    def offerLast(self, e: _LinkedList__E) -> bool: ...
    def peek(self) -> _LinkedList__E: ...
    def peekFirst(self) -> _LinkedList__E: ...
    def peekLast(self) -> _LinkedList__E: ...
    def poll(self) -> _LinkedList__E: ...
    def pollFirst(self) -> _LinkedList__E: ...
    def pollLast(self) -> _LinkedList__E: ...
    def pop(self) -> _LinkedList__E: ...
    def push(self, e: _LinkedList__E) -> None: ...
    @overload
    def remove(self, object: _py_Any) -> bool: ...
    @overload
    def remove(self) -> _LinkedList__E: ...
    @overload
    def remove(self, int: int) -> _LinkedList__E: ...
    def removeFirst(self) -> _LinkedList__E: ...
    def removeFirstOccurrence(self, object: _py_Any) -> bool: ...
    def removeLast(self) -> _LinkedList__E: ...
    def removeLastOccurrence(self, object: _py_Any) -> bool: ...
    def set(self, int: int, e: _LinkedList__E) -> _LinkedList__E: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_LinkedList__E]: ...
    @overload
    def toArray(self) -> _py_List[_py_Any]: ...
    _toArray_1__T = _py_TypeVar('_toArray_1__T')  # <T>
    @overload
    def toArray(self, tArray: _py_List[_toArray_1__T]) -> _py_List[_toArray_1__T]: ...

_RandomAccessSubList__E = _py_TypeVar('_RandomAccessSubList__E')  # <E>
class RandomAccessSubList(SubList[_RandomAccessSubList__E], RandomAccess, _py_Generic[_RandomAccessSubList__E]):
    def subList(self, int: int, int2: int) -> List[_RandomAccessSubList__E]: ...

_RegularEnumSet__E = _py_TypeVar('_RegularEnumSet__E', bound=java.lang.Enum)  # <E>
class RegularEnumSet(EnumSet[_RegularEnumSet__E], _py_Generic[_RegularEnumSet__E]):
    @overload
    def add(self, e: _RegularEnumSet__E) -> bool: ...
    @overload
    def add(self, object: _py_Any) -> bool: ...
    def addAll(self, collection: Collection[_RegularEnumSet__E]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: _py_Any) -> bool: ...
    def containsAll(self, collection: Collection[_py_Any]) -> bool: ...
    def equals(self, object: _py_Any) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_RegularEnumSet__E]: ...
    def remove(self, object: _py_Any) -> bool: ...
    def removeAll(self, collection: Collection[_py_Any]) -> bool: ...
    def retainAll(self, collection: Collection[_py_Any]) -> bool: ...
    def size(self) -> int: ...

_Stack__E = _py_TypeVar('_Stack__E')  # <E>
class Stack(Vector[_Stack__E], _py_Generic[_Stack__E]):
    def __init__(self): ...
    def empty(self) -> bool: ...
    def peek(self) -> _Stack__E: ...
    def pop(self) -> _Stack__E: ...
    def push(self, e: _Stack__E) -> _Stack__E: ...
    def search(self, object: _py_Any) -> int: ...

_TreeSet__E = _py_TypeVar('_TreeSet__E')  # <E>
class TreeSet(AbstractSet[_TreeSet__E], NavigableSet[_TreeSet__E], java.lang.Cloneable, java.io.Serializable, _py_Generic[_TreeSet__E]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, collection: Collection[_TreeSet__E]): ...
    @overload
    def __init__(self, comparator: Comparator[_TreeSet__E]): ...
    @overload
    def __init__(self, sortedSet: SortedSet[_TreeSet__E]): ...
    def add(self, e: _TreeSet__E) -> bool: ...
    def addAll(self, collection: Collection[_TreeSet__E]) -> bool: ...
    def ceiling(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def comparator(self) -> Comparator[_TreeSet__E]: ...
    def contains(self, object: _py_Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_TreeSet__E]: ...
    def descendingSet(self) -> NavigableSet[_TreeSet__E]: ...
    def first(self) -> _TreeSet__E: ...
    def floor(self, e: _TreeSet__E) -> _TreeSet__E: ...
    @overload
    def headSet(self, e: _TreeSet__E, boolean: bool) -> NavigableSet[_TreeSet__E]: ...
    @overload
    def headSet(self, e: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...
    def higher(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_TreeSet__E]: ...
    def last(self) -> _TreeSet__E: ...
    def lower(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def pollFirst(self) -> _TreeSet__E: ...
    def pollLast(self) -> _TreeSet__E: ...
    def remove(self, object: _py_Any) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_TreeSet__E]: ...
    @overload
    def subSet(self, e: _TreeSet__E, boolean: bool, e2: _TreeSet__E, boolean2: bool) -> NavigableSet[_TreeSet__E]: ...
    @overload
    def subSet(self, e: _TreeSet__E, e2: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...
    @overload
    def tailSet(self, e: _TreeSet__E, boolean: bool) -> NavigableSet[_TreeSet__E]: ...
    @overload
    def tailSet(self, e: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...

_AbstractMap__SimpleEntry__K = _py_TypeVar('_AbstractMap__SimpleEntry__K')  # <K>
_AbstractMap__SimpleEntry__V = _py_TypeVar('_AbstractMap__SimpleEntry__V')  # <V>
_AbstractMap__SimpleImmutableEntry__K = _py_TypeVar('_AbstractMap__SimpleImmutableEntry__K')  # <K>
_AbstractMap__SimpleImmutableEntry__V = _py_TypeVar('_AbstractMap__SimpleImmutableEntry__V')  # <V>
_AbstractMap__K = _py_TypeVar('_AbstractMap__K')  # <K>
_AbstractMap__V = _py_TypeVar('_AbstractMap__V')  # <V>
class AbstractMap(Map[_AbstractMap__K, _AbstractMap__V], _py_Generic[_AbstractMap__K, _AbstractMap__V]):
    def clear(self) -> None: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_AbstractMap__K, _AbstractMap__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def get(self, object: _py_Any) -> _AbstractMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_AbstractMap__K]: ...
    def put(self, k: _AbstractMap__K, v: _AbstractMap__V) -> _AbstractMap__V: ...
    def putAll(self, map: Map[_AbstractMap__K, _AbstractMap__V]) -> None: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def remove(self, object: _py_Any) -> _AbstractMap__V: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def values(self) -> Collection[_AbstractMap__V]: ...
    class SimpleEntry(Map.Entry[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V], java.io.Serializable, _py_Generic[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V]):
        @overload
        def __init__(self, k: _AbstractMap__SimpleEntry__K, v: _AbstractMap__SimpleEntry__V): ...
        @overload
        def __init__(self, entry: Map.Entry[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V]): ...
        def equals(self, object: _py_Any) -> bool: ...
        def getKey(self) -> _AbstractMap__SimpleEntry__K: ...
        def getValue(self) -> _AbstractMap__SimpleEntry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _AbstractMap__SimpleEntry__V) -> _AbstractMap__SimpleEntry__V: ...
        def toString(self) -> str: ...
    class SimpleImmutableEntry(Map.Entry[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V], java.io.Serializable, _py_Generic[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V]):
        @overload
        def __init__(self, k: _AbstractMap__SimpleImmutableEntry__K, v: _AbstractMap__SimpleImmutableEntry__V): ...
        @overload
        def __init__(self, entry: Map.Entry[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V]): ...
        def equals(self, object: _py_Any) -> bool: ...
        def getKey(self) -> _AbstractMap__SimpleImmutableEntry__K: ...
        def getValue(self) -> _AbstractMap__SimpleImmutableEntry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _AbstractMap__SimpleImmutableEntry__V) -> _AbstractMap__SimpleImmutableEntry__V: ...
        def toString(self) -> str: ...

_EnumMap__K = _py_TypeVar('_EnumMap__K', bound=java.lang.Enum)  # <K>
_EnumMap__V = _py_TypeVar('_EnumMap__V')  # <V>
class EnumMap(AbstractMap[_EnumMap__K, _EnumMap__V], java.io.Serializable, java.lang.Cloneable, _py_Generic[_EnumMap__K, _EnumMap__V]):
    @overload
    def __init__(self, class_: _py_Type[_EnumMap__K]): ...
    @overload
    def __init__(self, enumMap: 'EnumMap'[_EnumMap__K, _EnumMap__V]): ...
    @overload
    def __init__(self, map: Map[_EnumMap__K, _EnumMap__V]): ...
    def clear(self) -> None: ...
    @overload
    def clone(self) -> _py_Any: ...
    @overload
    def clone(self) -> 'EnumMap'[_EnumMap__K, _EnumMap__V]: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_EnumMap__K, _EnumMap__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def get(self, object: _py_Any) -> _EnumMap__V: ...
    def hashCode(self) -> int: ...
    def keySet(self) -> Set[_EnumMap__K]: ...
    @overload
    def put(self, k: _EnumMap__K, v: _EnumMap__V) -> _EnumMap__V: ...
    @overload
    def put(self, object: _py_Any, object2: _py_Any) -> _py_Any: ...
    def putAll(self, map: Map[_EnumMap__K, _EnumMap__V]) -> None: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def remove(self, object: _py_Any) -> _EnumMap__V: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_EnumMap__V]: ...

_HashMap__K = _py_TypeVar('_HashMap__K')  # <K>
_HashMap__V = _py_TypeVar('_HashMap__V')  # <V>
class HashMap(AbstractMap[_HashMap__K, _HashMap__V], Map[_HashMap__K, _HashMap__V], java.lang.Cloneable, java.io.Serializable, _py_Generic[_HashMap__K, _HashMap__V]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, float: float): ...
    @overload
    def __init__(self, map: Map[_HashMap__K, _HashMap__V]): ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def compute(self, k: _HashMap__K, biFunction: java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V]) -> _HashMap__V: ...
    def computeIfAbsent(self, k: _HashMap__K, function: java.util.function.Function[_HashMap__K, _HashMap__V]) -> _HashMap__V: ...
    def computeIfPresent(self, k: _HashMap__K, biFunction: java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V]) -> _HashMap__V: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_HashMap__K, _HashMap__V]]: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_HashMap__K, _HashMap__V]) -> None: ...
    def get(self, object: _py_Any) -> _HashMap__V: ...
    def getOrDefault(self, object: _py_Any, v: _HashMap__V) -> _HashMap__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_HashMap__K]: ...
    def merge(self, k: _HashMap__K, v: _HashMap__V, biFunction: java.util.function.BiFunction[_HashMap__V, _HashMap__V, _HashMap__V]) -> _HashMap__V: ...
    def put(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    def putAll(self, map: Map[_HashMap__K, _HashMap__V]) -> None: ...
    def putIfAbsent(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def remove(self, object: _py_Any) -> _HashMap__V: ...
    @overload
    def replace(self, k: _HashMap__K, v: _HashMap__V, v2: _HashMap__V) -> bool: ...
    @overload
    def replace(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_HashMap__V]: ...

_IdentityHashMap__K = _py_TypeVar('_IdentityHashMap__K')  # <K>
_IdentityHashMap__V = _py_TypeVar('_IdentityHashMap__V')  # <V>
class IdentityHashMap(AbstractMap[_IdentityHashMap__K, _IdentityHashMap__V], Map[_IdentityHashMap__K, _IdentityHashMap__V], java.io.Serializable, java.lang.Cloneable, _py_Generic[_IdentityHashMap__K, _IdentityHashMap__V]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, map: Map[_IdentityHashMap__K, _IdentityHashMap__V]): ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_IdentityHashMap__K, _IdentityHashMap__V]]: ...
    def equals(self, object: _py_Any) -> bool: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_IdentityHashMap__K, _IdentityHashMap__V]) -> None: ...
    def get(self, object: _py_Any) -> _IdentityHashMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_IdentityHashMap__K]: ...
    def put(self, k: _IdentityHashMap__K, v: _IdentityHashMap__V) -> _IdentityHashMap__V: ...
    def putAll(self, map: Map[_IdentityHashMap__K, _IdentityHashMap__V]) -> None: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def remove(self, object: _py_Any) -> _IdentityHashMap__V: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_IdentityHashMap__K, _IdentityHashMap__V, _IdentityHashMap__V]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_IdentityHashMap__V]: ...

_LinkedHashMap__K = _py_TypeVar('_LinkedHashMap__K')  # <K>
_LinkedHashMap__V = _py_TypeVar('_LinkedHashMap__V')  # <V>
class LinkedHashMap(HashMap[_LinkedHashMap__K, _LinkedHashMap__V], Map[_LinkedHashMap__K, _LinkedHashMap__V], _py_Generic[_LinkedHashMap__K, _LinkedHashMap__V]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, float: float): ...
    @overload
    def __init__(self, int: int, float: float, boolean: bool): ...
    @overload
    def __init__(self, map: Map[_LinkedHashMap__K, _LinkedHashMap__V]): ...
    def clear(self) -> None: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_LinkedHashMap__K, _LinkedHashMap__V]]: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_LinkedHashMap__K, _LinkedHashMap__V]) -> None: ...
    def get(self, object: _py_Any) -> _LinkedHashMap__V: ...
    def getOrDefault(self, object: _py_Any, v: _LinkedHashMap__V) -> _LinkedHashMap__V: ...
    def keySet(self) -> Set[_LinkedHashMap__K]: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_LinkedHashMap__K, _LinkedHashMap__V, _LinkedHashMap__V]) -> None: ...
    def values(self) -> Collection[_LinkedHashMap__V]: ...

_PrimitiveIterator__T = _py_TypeVar('_PrimitiveIterator__T')  # <T>
_PrimitiveIterator__T_CONS = _py_TypeVar('_PrimitiveIterator__T_CONS')  # <T_CONS>
class PrimitiveIterator(Iterator[_PrimitiveIterator__T], _py_Generic[_PrimitiveIterator__T, _PrimitiveIterator__T_CONS]):
    @overload
    def forEachRemaining(self, t_CONS: _PrimitiveIterator__T_CONS) -> None: ...
    @overload
    def forEachRemaining(self, consumer: java.util.function.Consumer[_py_Any]) -> None: ...
    class OfDouble(java.util.PrimitiveIterator[float, java.util.function.DoubleConsumer]):
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[float]) -> None: ...
        @overload
        def forEachRemaining(self, doubleConsumer: java.util.function.DoubleConsumer) -> None: ...
        @overload
        def next(self) -> float: ...
        @overload
        def next(self) -> _py_Any: ...
        def nextDouble(self) -> float: ...
    class OfInt(java.util.PrimitiveIterator[int, java.util.function.IntConsumer]):
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[int]) -> None: ...
        @overload
        def forEachRemaining(self, intConsumer: java.util.function.IntConsumer) -> None: ...
        @overload
        def next(self) -> int: ...
        @overload
        def next(self) -> _py_Any: ...
        def nextInt(self) -> int: ...
    class OfLong(java.util.PrimitiveIterator[int, java.util.function.LongConsumer]):
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[int]) -> None: ...
        @overload
        def forEachRemaining(self, longConsumer: java.util.function.LongConsumer) -> None: ...
        @overload
        def next(self) -> int: ...
        @overload
        def next(self) -> _py_Any: ...
        def nextLong(self) -> int: ...

_Spliterator__OfPrimitive__T = _py_TypeVar('_Spliterator__OfPrimitive__T')  # <T>
_Spliterator__OfPrimitive__T_CONS = _py_TypeVar('_Spliterator__OfPrimitive__T_CONS')  # <T_CONS>
_Spliterator__OfPrimitive__T_SPLITR = _py_TypeVar('_Spliterator__OfPrimitive__T_SPLITR', bound='Spliterator.OfPrimitive')  # <T_SPLITR>
_Spliterator__T = _py_TypeVar('_Spliterator__T')  # <T>
class Spliterator(_py_Generic[_Spliterator__T]):
    ORDERED: _py_ClassVar[int] = ...
    DISTINCT: _py_ClassVar[int] = ...
    SORTED: _py_ClassVar[int] = ...
    SIZED: _py_ClassVar[int] = ...
    NONNULL: _py_ClassVar[int] = ...
    IMMUTABLE: _py_ClassVar[int] = ...
    CONCURRENT: _py_ClassVar[int] = ...
    SUBSIZED: _py_ClassVar[int] = ...
    def characteristics(self) -> int: ...
    def estimateSize(self) -> int: ...
    def forEachRemaining(self, consumer: java.util.function.Consumer[_Spliterator__T]) -> None: ...
    def getComparator(self) -> Comparator[_Spliterator__T]: ...
    def getExactSizeIfKnown(self) -> int: ...
    def hasCharacteristics(self, int: int) -> bool: ...
    def tryAdvance(self, consumer: java.util.function.Consumer[_Spliterator__T]) -> bool: ...
    def trySplit(self) -> 'Spliterator'[_Spliterator__T]: ...
    class OfDouble(java.util.Spliterator.OfPrimitive[float, java.util.function.DoubleConsumer, 'Spliterator.OfDouble']):
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[float]) -> None: ...
        @overload
        def forEachRemaining(self, doubleConsumer: java.util.function.DoubleConsumer) -> None: ...
        @overload
        def tryAdvance(self, doubleConsumer: java.util.function.DoubleConsumer) -> bool: ...
        @overload
        def tryAdvance(self, object: _py_Any) -> bool: ...
        @overload
        def tryAdvance(self, consumer: java.util.function.Consumer[float]) -> bool: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfDouble': ...
        @overload
        def trySplit(self) -> 'Spliterator': ...
        @overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
    class OfInt(java.util.Spliterator.OfPrimitive[int, java.util.function.IntConsumer, 'Spliterator.OfInt']):
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[int]) -> None: ...
        @overload
        def forEachRemaining(self, intConsumer: java.util.function.IntConsumer) -> None: ...
        @overload
        def tryAdvance(self, intConsumer: java.util.function.IntConsumer) -> bool: ...
        @overload
        def tryAdvance(self, object: _py_Any) -> bool: ...
        @overload
        def tryAdvance(self, consumer: java.util.function.Consumer[int]) -> bool: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfInt': ...
        @overload
        def trySplit(self) -> 'Spliterator': ...
        @overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
    class OfLong(java.util.Spliterator.OfPrimitive[int, java.util.function.LongConsumer, 'Spliterator.OfLong']):
        @overload
        def forEachRemaining(self, object: _py_Any) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[int]) -> None: ...
        @overload
        def forEachRemaining(self, longConsumer: java.util.function.LongConsumer) -> None: ...
        @overload
        def tryAdvance(self, longConsumer: java.util.function.LongConsumer) -> bool: ...
        @overload
        def tryAdvance(self, object: _py_Any) -> bool: ...
        @overload
        def tryAdvance(self, consumer: java.util.function.Consumer[int]) -> bool: ...
        @overload
        def trySplit(self) -> 'Spliterator.OfLong': ...
        @overload
        def trySplit(self) -> 'Spliterator': ...
        @overload
        def trySplit(self) -> 'Spliterator.OfPrimitive': ...
    class OfPrimitive(java.util.Spliterator[_Spliterator__OfPrimitive__T], _py_Generic[_Spliterator__OfPrimitive__T, _Spliterator__OfPrimitive__T_CONS, _Spliterator__OfPrimitive__T_SPLITR]):
        @overload
        def forEachRemaining(self, t_CONS: _Spliterator__OfPrimitive__T_CONS) -> None: ...
        @overload
        def forEachRemaining(self, consumer: java.util.function.Consumer[_Spliterator__OfPrimitive__T]) -> None: ...
        @overload
        def tryAdvance(self, t_CONS: _Spliterator__OfPrimitive__T_CONS) -> bool: ...
        @overload
        def tryAdvance(self, consumer: java.util.function.Consumer[_Spliterator__OfPrimitive__T]) -> bool: ...
        @overload
        def trySplit(self) -> _Spliterator__OfPrimitive__T_SPLITR: ...
        @overload
        def trySplit(self) -> 'Spliterator': ...

_Spliterators__AbstractSpliterator__T = _py_TypeVar('_Spliterators__AbstractSpliterator__T')  # <T>
class Spliterators:
    @classmethod
    def emptyDoubleSpliterator(cls) -> Spliterator.OfDouble: ...
    @classmethod
    def emptyIntSpliterator(cls) -> Spliterator.OfInt: ...
    @classmethod
    def emptyLongSpliterator(cls) -> Spliterator.OfLong: ...
    _emptySpliterator__T = _py_TypeVar('_emptySpliterator__T')  # <T>
    @classmethod
    def emptySpliterator(cls) -> Spliterator[_emptySpliterator__T]: ...
    _iterator_0__T = _py_TypeVar('_iterator_0__T')  # <T>
    @classmethod
    @overload
    def iterator(cls, spliterator: Spliterator[_iterator_0__T]) -> Iterator[_iterator_0__T]: ...
    @classmethod
    @overload
    def iterator(cls, ofDouble: Spliterator.OfDouble) -> PrimitiveIterator.OfDouble: ...
    @classmethod
    @overload
    def iterator(cls, ofInt: Spliterator.OfInt) -> PrimitiveIterator.OfInt: ...
    @classmethod
    @overload
    def iterator(cls, ofLong: Spliterator.OfLong) -> PrimitiveIterator.OfLong: ...
    _spliterator_0__T = _py_TypeVar('_spliterator_0__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, objectArray: _py_List[_py_Any], int: int) -> Spliterator[_spliterator_0__T]: ...
    _spliterator_1__T = _py_TypeVar('_spliterator_1__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, objectArray: _py_List[_py_Any], int: int, int2: int, int3: int) -> Spliterator[_spliterator_1__T]: ...
    _spliterator_2__T = _py_TypeVar('_spliterator_2__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, collection: Collection[_spliterator_2__T], int: int) -> Spliterator[_spliterator_2__T]: ...
    _spliterator_3__T = _py_TypeVar('_spliterator_3__T')  # <T>
    @classmethod
    @overload
    def spliterator(cls, iterator: Iterator[_spliterator_3__T], long: int, int: int) -> Spliterator[_spliterator_3__T]: ...
    @classmethod
    @overload
    def spliterator(cls, doubleArray: _py_List[float], int: int) -> Spliterator.OfDouble: ...
    @classmethod
    @overload
    def spliterator(cls, doubleArray: _py_List[float], int: int, int2: int, int3: int) -> Spliterator.OfDouble: ...
    @classmethod
    @overload
    def spliterator(cls, ofDouble: PrimitiveIterator.OfDouble, long: int, int: int) -> Spliterator.OfDouble: ...
    @classmethod
    @overload
    def spliterator(cls, intArray: _py_List[int], int2: int) -> Spliterator.OfInt: ...
    @classmethod
    @overload
    def spliterator(cls, intArray: _py_List[int], int2: int, int3: int, int4: int) -> Spliterator.OfInt: ...
    @classmethod
    @overload
    def spliterator(cls, ofInt: PrimitiveIterator.OfInt, long: int, int: int) -> Spliterator.OfInt: ...
    @classmethod
    @overload
    def spliterator(cls, ofLong: PrimitiveIterator.OfLong, long: int, int: int) -> Spliterator.OfLong: ...
    @classmethod
    @overload
    def spliterator(cls, longArray: _py_List[int], int: int) -> Spliterator.OfLong: ...
    @classmethod
    @overload
    def spliterator(cls, longArray: _py_List[int], int: int, int2: int, int3: int) -> Spliterator.OfLong: ...
    _spliteratorUnknownSize_0__T = _py_TypeVar('_spliteratorUnknownSize_0__T')  # <T>
    @classmethod
    @overload
    def spliteratorUnknownSize(cls, iterator: Iterator[_spliteratorUnknownSize_0__T], int: int) -> Spliterator[_spliteratorUnknownSize_0__T]: ...
    @classmethod
    @overload
    def spliteratorUnknownSize(cls, ofDouble: PrimitiveIterator.OfDouble, int: int) -> Spliterator.OfDouble: ...
    @classmethod
    @overload
    def spliteratorUnknownSize(cls, ofInt: PrimitiveIterator.OfInt, int: int) -> Spliterator.OfInt: ...
    @classmethod
    @overload
    def spliteratorUnknownSize(cls, ofLong: PrimitiveIterator.OfLong, int: int) -> Spliterator.OfLong: ...
    class AbstractDoubleSpliterator(Spliterator.OfDouble):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        @overload
        def trySplit(self) -> Spliterator: ...
        @overload
        def trySplit(self) -> Spliterator.OfDouble: ...
        @overload
        def trySplit(self) -> Spliterator.OfPrimitive: ...
    class AbstractIntSpliterator(Spliterator.OfInt):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        @overload
        def trySplit(self) -> Spliterator: ...
        @overload
        def trySplit(self) -> Spliterator.OfInt: ...
        @overload
        def trySplit(self) -> Spliterator.OfPrimitive: ...
    class AbstractLongSpliterator(Spliterator.OfLong):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        @overload
        def trySplit(self) -> Spliterator: ...
        @overload
        def trySplit(self) -> Spliterator.OfLong: ...
        @overload
        def trySplit(self) -> Spliterator.OfPrimitive: ...
    class AbstractSpliterator(Spliterator[_Spliterators__AbstractSpliterator__T], _py_Generic[_Spliterators__AbstractSpliterator__T]):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        def trySplit(self) -> Spliterator[_Spliterators__AbstractSpliterator__T]: ...

_TreeMap__K = _py_TypeVar('_TreeMap__K')  # <K>
_TreeMap__V = _py_TypeVar('_TreeMap__V')  # <V>
class TreeMap(AbstractMap[_TreeMap__K, _TreeMap__V], NavigableMap[_TreeMap__K, _TreeMap__V], java.lang.Cloneable, java.io.Serializable, _py_Generic[_TreeMap__K, _TreeMap__V]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, comparator: Comparator[_TreeMap__K]): ...
    @overload
    def __init__(self, map: Map[_TreeMap__K, _TreeMap__V]): ...
    @overload
    def __init__(self, sortedMap: SortedMap[_TreeMap__K, _TreeMap__V]): ...
    def ceilingEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def ceilingKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def clear(self) -> None: ...
    def clone(self) -> _py_Any: ...
    def comparator(self) -> Comparator[_TreeMap__K]: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def descendingKeySet(self) -> NavigableSet[_TreeMap__K]: ...
    def descendingMap(self) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    def entrySet(self) -> Set[Map.Entry[_TreeMap__K, _TreeMap__V]]: ...
    def firstEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def firstKey(self) -> _TreeMap__K: ...
    def floorEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def floorKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_TreeMap__K, _TreeMap__V]) -> None: ...
    def get(self, object: _py_Any) -> _TreeMap__V: ...
    @overload
    def headMap(self, k: _TreeMap__K, boolean: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    @overload
    def headMap(self, k: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    def higherEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def higherKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def keySet(self) -> Set[_TreeMap__K]: ...
    def lastEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def lastKey(self) -> _TreeMap__K: ...
    def lowerEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def lowerKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def navigableKeySet(self) -> NavigableSet[_TreeMap__K]: ...
    def pollFirstEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def pollLastEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def put(self, k: _TreeMap__K, v: _TreeMap__V) -> _TreeMap__V: ...
    def putAll(self, map: Map[_TreeMap__K, _TreeMap__V]) -> None: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def remove(self, object: _py_Any) -> _TreeMap__V: ...
    @overload
    def replace(self, k: _TreeMap__K, v: _TreeMap__V, v2: _TreeMap__V) -> bool: ...
    @overload
    def replace(self, k: _TreeMap__K, v: _TreeMap__V) -> _TreeMap__V: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_TreeMap__K, _TreeMap__V, _TreeMap__V]) -> None: ...
    def size(self) -> int: ...
    @overload
    def subMap(self, k: _TreeMap__K, boolean: bool, k2: _TreeMap__K, boolean2: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    @overload
    def subMap(self, k: _TreeMap__K, k2: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    @overload
    def tailMap(self, k: _TreeMap__K, boolean: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    @overload
    def tailMap(self, k: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    def values(self) -> Collection[_TreeMap__V]: ...

_WeakHashMap__K = _py_TypeVar('_WeakHashMap__K')  # <K>
_WeakHashMap__V = _py_TypeVar('_WeakHashMap__V')  # <V>
class WeakHashMap(AbstractMap[_WeakHashMap__K, _WeakHashMap__V], Map[_WeakHashMap__K, _WeakHashMap__V], _py_Generic[_WeakHashMap__K, _WeakHashMap__V]):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, int: int): ...
    @overload
    def __init__(self, int: int, float: float): ...
    @overload
    def __init__(self, map: Map[_WeakHashMap__K, _WeakHashMap__V]): ...
    def clear(self) -> None: ...
    def containsKey(self, object: _py_Any) -> bool: ...
    def containsValue(self, object: _py_Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_WeakHashMap__K, _WeakHashMap__V]]: ...
    def forEach(self, biConsumer: java.util.function.BiConsumer[_WeakHashMap__K, _WeakHashMap__V]) -> None: ...
    def get(self, object: _py_Any) -> _WeakHashMap__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_WeakHashMap__K]: ...
    def put(self, k: _WeakHashMap__K, v: _WeakHashMap__V) -> _WeakHashMap__V: ...
    def putAll(self, map: Map[_WeakHashMap__K, _WeakHashMap__V]) -> None: ...
    @overload
    def remove(self, object: _py_Any, object2: _py_Any) -> bool: ...
    @overload
    def remove(self, object: _py_Any) -> _WeakHashMap__V: ...
    def replaceAll(self, biFunction: java.util.function.BiFunction[_WeakHashMap__K, _WeakHashMap__V, _WeakHashMap__V]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_WeakHashMap__V]: ...
